# P1.3: eBPF Event Struct Format Specification

**Status:** ðŸ”’ FROZEN
**Version:** v1.0
**Date:** 2026-02-24
**Owner:** eBPF Agent
**SHA256:** `SHA256_PLACEHOLDER_TO_BE_FILLED_ON_SIGNING`

---

## Overview

This specification defines the binary format of eBPF event structures used for kernel-level monitoring in ClawOS. These structures are shared between:

- **Kernel Space:** eBPF programs (Aya-rs framework)
- **Userspace:** Observability Agent (Rust receiver)

**Critical Requirement:** Both eBPF Agent and Observability Agent MUST use version v1.0. Any breaking change requires version bump and coordinated update.

---

## Design Principles

1. **CO-RE Compatibility:** All structs must be compatible with BTF (BPF Type Format) for Compile Once, Run Everywhere
2. **Fixed Size:** All kernel-space structs must have fixed size (no dynamic allocation)
3. **Alignment:** All fields aligned to natural boundaries (8-byte for u64, 4-byte for u32)
4. **Endianness:** Little-endian (x86_64 standard)
5. **Versioning:** Version field in each event for future compatibility

---

## Type System

### Rust Types (Userspace)

| Rust Type | Size | Description |
|-----------|------|-------------|
| `u8` | 1 byte | Unsigned 8-bit integer |
| `u16` | 2 bytes | Unsigned 16-bit integer |
| `u32` | 4 bytes | Unsigned 32-bit integer |
| `u64` | 8 bytes | Unsigned 64-bit integer |
| `i32` | 4 bytes | Signed 32-bit integer |
| `[u8; N]` | N bytes | Fixed-size byte array |
| `String` | Variable | UTF-8 string (userspace only) |
| `HashMap<K, V>` | Variable | Hash map (userspace only) |

### C Types (Kernel Space)

| C Type | Size | Description |
|--------|------|-------------|
| `__u8` | 1 byte | Unsigned 8-bit integer |
| `__u16` | 2 bytes | Unsigned 16-bit integer |
| `__u32` | 4 bytes | Unsigned 32-bit integer |
| `__u64` | 8 bytes | Unsigned 64-bit integer |
| `__s32` | 4 bytes | Signed 32-bit integer |
| `char[N]` | N bytes | Fixed-size character array |

---

## Enum Definitions

### EventType

Event type classification for AnomalyEvent.

| Value | Name | Description |
|-------|------|-------------|
| 0 | UNKNOWN | Unknown event type |
| 1 | SYSCALL_ANOMALY | Syscall pattern anomaly |
| 2 | FILE_ACCESS_VIOLATION | File access violation |
| 3 | NETWORK_SUSPICIOUS | Suspicious network activity |
| 4 | CGROUP_THRESHOLD | Cgroup resource threshold exceeded |
| 5 | PROCESS_ANOMALY | Process behavior anomaly |
| 6 | SECURITY_VIOLATION | Security policy violation |

**Rust:**
```rust
#[repr(u8)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum EventType {
    Unknown = 0,
    SyscallAnomaly = 1,
    FileAccessViolation = 2,
    NetworkSuspicious = 3,
    CgroupThreshold = 4,
    ProcessAnomaly = 5,
    SecurityViolation = 6,
}
```

**C:**
```c
enum event_type {
    EVENT_TYPE_UNKNOWN = 0,
    EVENT_TYPE_SYSCALL_ANOMALY = 1,
    EVENT_TYPE_FILE_ACCESS_VIOLATION = 2,
    EVENT_TYPE_NETWORK_SUSPICIOUS = 3,
    EVENT_TYPE_CGROUP_THRESHOLD = 4,
    EVENT_TYPE_PROCESS_ANOMALY = 5,
    EVENT_TYPE_SECURITY_VIOLATION = 6,
};
```

### SeverityCode

Severity level for anomaly events.

| Value | Name | Description |
|-------|------|-------------|
| 0 | INFO | Informational |
| 1 | LOW | Low severity |
| 2 | MEDIUM | Medium severity |
| 3 | HIGH | High severity |
| 4 | CRITICAL | Critical severity |

**Rust:**
```rust
#[repr(u8)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum SeverityCode {
    Info = 0,
    Low = 1,
    Medium = 2,
    High = 3,
    Critical = 4,
}
```

**C:**
```c
enum severity_code {
    SEVERITY_INFO = 0,
    SEVERITY_LOW = 1,
    SEVERITY_MEDIUM = 2,
    SEVERITY_HIGH = 3,
    SEVERITY_CRITICAL = 4,
};
```

### FileOperation

File access operation type.

| Value | Name | Description |
|-------|------|-------------|
| 0 | READ | Read operation |
| 1 | WRITE | Write operation |
| 2 | EXECUTE | Execute operation |
| 3 | DELETE | Delete operation |
| 4 | CREATE | Create operation |
| 5 | RENAME | Rename operation |

**Rust:**
```rust
#[repr(u8)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum FileOperation {
    Read = 0,
    Write = 1,
    Execute = 2,
    Delete = 3,
    Create = 4,
    Rename = 5,
}
```

**C:**
```c
enum file_operation {
    FILE_OP_READ = 0,
    FILE_OP_WRITE = 1,
    FILE_OP_EXECUTE = 2,
    FILE_OP_DELETE = 3,
    FILE_OP_CREATE = 4,
    FILE_OP_RENAME = 5,
};
```

### NetworkProtocol

Network protocol type.

| Value | Name | Description |
|-------|------|-------------|
| 0 | UNKNOWN | Unknown protocol |
| 1 | TCP | TCP protocol |
| 2 | UDP | UDP protocol |
| 3 | ICMP | ICMP protocol |
| 4 | ICMPV6 | ICMPv6 protocol |

**Rust:**
```rust
#[repr(u8)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum NetworkProtocol {
    Unknown = 0,
    Tcp = 1,
    Udp = 2,
    Icmp = 3,
    IcmpV6 = 4,
}
```

**C:**
```c
enum network_protocol {
    PROTOCOL_UNKNOWN = 0,
    PROTOCOL_TCP = 1,
    PROTOCOL_UDP = 2,
    PROTOCOL_ICMP = 3,
    PROTOCOL_ICMPV6 = 4,
};
```

### NetworkDirection

Network connection direction.

| Value | Name | Description |
|-------|------|-------------|
| 0 | UNKNOWN | Unknown direction |
| 1 | INBOUND | Inbound connection |
| 2 | OUTBOUND | Outbound connection |

**Rust:**
```rust
#[repr(u8)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum NetworkDirection {
    Unknown = 0,
    Inbound = 1,
    Outbound = 2,
}
```

**C:**
```c
enum network_direction {
    DIRECTION_UNKNOWN = 0,
    DIRECTION_INBOUND = 1,
    DIRECTION_OUTBOUND = 2,
};
```

### CgroupMetricType

Cgroup metric type for monitoring.

| Value | Name | Description |
|-------|------|-------------|
| 0 | UNKNOWN | Unknown metric |
| 1 | MEMORY_USAGE | Memory usage in bytes |
| 2 | CPU_USAGE | CPU usage percentage |
| 3 | PID_COUNT | Process count |
| 4 | IO_READ_BYTES | I/O read bytes |
| 5 | IO_WRITE_BYTES | I/O write bytes |
| 6 | NETWORK_RX_BYTES | Network receive bytes |
| 7 | NETWORK_TX_BYTES | Network transmit bytes |

**Rust:**
```rust
#[repr(u8)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum CgroupMetricType {
    Unknown = 0,
    MemoryUsage = 1,
    CpuUsage = 2,
    PidCount = 3,
    IoReadBytes = 4,
    IoWriteBytes = 5,
    NetworkRxBytes = 6,
    NetworkTxBytes = 7,
}
```

**C:**
```c
enum cgroup_metric_type {
    METRIC_UNKNOWN = 0,
    METRIC_MEMORY_USAGE = 1,
    METRIC_CPU_USAGE = 2,
    METRIC_PID_COUNT = 3,
    METRIC_IO_READ_BYTES = 4,
    METRIC_IO_WRITE_BYTES = 5,
    METRIC_NETWORK_RX_BYTES = 6,
    METRIC_NETWORK_TX_BYTES = 7,
};
```

---

## Event Struct Definitions

### 1. AnomalyEvent

General anomaly event structure for security and monitoring alerts.

**Purpose:** Unified anomaly detection event that can represent various security and monitoring alerts.

**Fields:**

| Field | Type | Size | Description |
|-------|------|------|-------------|
| `version` | `u8` | 1 byte | Event format version (must be 1) |
| `event_type` | `u8` | 1 byte | Event type (see EventType enum) |
| `severity_code` | `u8` | 1 byte | Severity level (see SeverityCode enum) |
| `reserved` | `u8` | 1 byte | Reserved for future use (must be 0) |
| `timestamp_ns` | `u64` | 8 bytes | Timestamp in nanoseconds (CLOCK_MONOTONIC) |
| `pid` | `u32` | 4 bytes | Process ID |
| `tid` | `u32` | 4 bytes | Thread ID |
| `uid` | `u32` | 4 bytes | User ID |
| `gid` | `u32` | 4 bytes | Group ID |
| `description_len` | `u16` | 2 bytes | Length of description string |
| `metadata_count` | `u16` | 2 bytes | Number of metadata key-value pairs |
| `description` | `[u8; 256]` | 256 bytes | Description string (null-terminated) |
| `metadata_keys` | `[[u8; 32]; 8]` | 256 bytes | Metadata keys (max 8, each 32 bytes) |
| `metadata_values` | `[[u8; 64]; 8]` | 512 bytes | Metadata values (max 8, each 64 bytes) |

**Total Size:** 1056 bytes

**Rust Definition:**
```rust
#[repr(C, packed)]
#[derive(Clone, Copy, Debug)]
pub struct AnomalyEvent {
    pub version: u8,
    pub event_type: u8,
    pub severity_code: u8,
    pub reserved: u8,
    pub timestamp_ns: u64,
    pub pid: u32,
    pub tid: u32,
    pub uid: u32,
    pub gid: u32,
    pub description_len: u16,
    pub metadata_count: u16,
    pub description: [u8; 256],
    pub metadata_keys: [[u8; 32]; 8],
    pub metadata_values: [[u8; 64]; 8],
}

impl Default for AnomalyEvent {
    fn default() -> Self {
        Self {
            version: 1,
            event_type: 0,
            severity_code: 0,
            reserved: 0,
            timestamp_ns: 0,
            pid: 0,
            tid: 0,
            uid: 0,
            gid: 0,
            description_len: 0,
            metadata_count: 0,
            description: [0; 256],
            metadata_keys: [[0; 32]; 8],
            metadata_values: [[0; 64]; 8],
        }
    }
}
```

**C Definition:**
```c
struct anomaly_event {
    __u8 version;
    __u8 event_type;
    __u8 severity_code;
    __u8 reserved;
    __u64 timestamp_ns;
    __u32 pid;
    __u32 tid;
    __u32 uid;
    __u32 gid;
    __u16 description_len;
    __u16 metadata_count;
    char description[256];
    char metadata_keys[8][32];
    char metadata_values[8][64];
} __attribute__((packed));
```

**Binary Layout:**
```
Offset  Field               Size  Type
------  ------------------  ----  ------
0x00    version             1     u8
0x01    event_type          1     u8
0x02    severity_code       1     u8
0x03    reserved            1     u8
0x04    timestamp_ns        8     u64
0x0C    pid                 4     u32
0x10    tid                 4     u32
0x14    uid                 4     u32
0x18    gid                 4     u32
0x1C    description_len     2     u16
0x1E    metadata_count      2     u16
0x20    description         256   [u8; 256]
0x120   metadata_keys       256   [[u8; 32]; 8]
0x220   metadata_values     512   [[u8; 64]; 8]
Total:  1056 bytes
```

---

### 2. SyscallTraceEvent

System call tracing event for monitoring process behavior.

**Purpose:** Capture detailed information about system calls including arguments and return values.

**Fields:**

| Field | Type | Size | Description |
|-------|------|------|-------------|
| `version` | `u8` | 1 byte | Event format version (must be 1) |
| `reserved` | `u8` | 1 byte | Reserved for future use (must be 0) |
| `sysnum` | `u16` | 2 bytes | System call number |
| `timestamp_ns` | `u64` | 8 bytes | Timestamp in nanoseconds (CLOCK_MONOTONIC) |
| `pid` | `u32` | 4 bytes | Process ID |
| `tid` | `u32` | 4 bytes | Thread ID |
| `return_value` | `i64` | 8 bytes | System call return value |
| `duration_ns` | `u64` | 8 bytes | System call duration in nanoseconds |
| `arg_count` | `u8` | 1 byte | Number of arguments (max 6) |
| `args` | `[u64; 6]` | 48 bytes | System call arguments (up to 6) |
| `comm` | `[u8; 16]` | 16 bytes | Process command name (null-terminated) |

**Total Size:** 104 bytes

**Rust Definition:**
```rust
#[repr(C, packed)]
#[derive(Clone, Copy, Debug)]
pub struct SyscallTraceEvent {
    pub version: u8,
    pub reserved: u8,
    pub sysnum: u16,
    pub timestamp_ns: u64,
    pub pid: u32,
    pub tid: u32,
    pub return_value: i64,
    pub duration_ns: u64,
    pub arg_count: u8,
    pub args: [u64; 6],
    pub comm: [u8; 16],
}

impl Default for SyscallTraceEvent {
    fn default() -> Self {
        Self {
            version: 1,
            reserved: 0,
            sysnum: 0,
            timestamp_ns: 0,
            pid: 0,
            tid: 0,
            return_value: 0,
            duration_ns: 0,
            arg_count: 0,
            args: [0; 6],
            comm: [0; 16],
        }
    }
}
```

**C Definition:**
```c
struct syscall_trace_event {
    __u8 version;
    __u8 reserved;
    __u16 sysnum;
    __u64 timestamp_ns;
    __u32 pid;
    __u32 tid;
    __s64 return_value;
    __u64 duration_ns;
    __u8 arg_count;
    __u64 args[6];
    char comm[16];
} __attribute__((packed));
```

**Binary Layout:**
```
Offset  Field           Size  Type
------  --------------  ----  ------
0x00    version         1     u8
0x01    reserved        1     u8
0x02    sysnum          2     u16
0x04    timestamp_ns    8     u64
0x0C    pid             4     u32
0x10    tid             4     u32
0x14    return_value    8     i64
0x1C    duration_ns     8     u64
0x24    arg_count       1     u8
0x25    padding         3     [u8; 3]
0x28    args            48    [u64; 6]
0x58    comm            16    [u8; 16]
Total:  104 bytes
```

---

### 3. FileAccessEvent

File access monitoring event for tracking file operations.

**Purpose:** Monitor file access patterns including read, write, execute operations and permission checks.

**Fields:**

| Field | Type | Size | Description |
|-------|------|------|-------------|
| `version` | `u8` | 1 byte | Event format version (must be 1) |
| `operation` | `u8` | 1 byte | File operation type (see FileOperation enum) |
| `permission_result` | `u8` | 1 byte | Permission check result (0=denied, 1=granted) |
| `reserved` | `u8` | 1 byte | Reserved for future use (must be 0) |
| `timestamp_ns` | `u64` | 8 bytes | Timestamp in nanoseconds (CLOCK_MONOTONIC) |
| `pid` | `u32` | 4 bytes | Process ID |
| `tid` | `u32` | 4 bytes | Thread ID |
| `uid` | `u32` | 4 bytes | User ID |
| `gid` | `u32` | 4 bytes | Group ID |
| `inode` | `u64` | 8 bytes | File inode number |
| `device_id` | `u32` | 4 bytes | Device ID (major/minor) |
| `mode` | `u32` | 4 bytes | File mode (permissions + type) |
| `path_len` | `u16` | 2 bytes | Length of path string |
| `path` | `[u8; 256]` | 256 bytes | File path (null-terminated) |

**Total Size:** 304 bytes

**Rust Definition:**
```rust
#[repr(C, packed)]
#[derive(Clone, Copy, Debug)]
pub struct FileAccessEvent {
    pub version: u8,
    pub operation: u8,
    pub permission_result: u8,
    pub reserved: u8,
    pub timestamp_ns: u64,
    pub pid: u32,
    pub tid: u32,
    pub uid: u32,
    pub gid: u32,
    pub inode: u64,
    pub device_id: u32,
    pub mode: u32,
    pub path_len: u16,
    pub path: [u8; 256],
}

impl Default for FileAccessEvent {
    fn default() -> Self {
        Self {
            version: 1,
            operation: 0,
            permission_result: 0,
            reserved: 0,
            timestamp_ns: 0,
            pid: 0,
            tid: 0,
            uid: 0,
            gid: 0,
            inode: 0,
            device_id: 0,
            mode: 0,
            path_len: 0,
            path: [0; 256],
        }
    }
}
```

**C Definition:**
```c
struct file_access_event {
    __u8 version;
    __u8 operation;
    __u8 permission_result;
    __u8 reserved;
    __u64 timestamp_ns;
    __u32 pid;
    __u32 tid;
    __u32 uid;
    __u32 gid;
    __u64 inode;
    __u32 device_id;
    __u32 mode;
    __u16 path_len;
    char path[256];
} __attribute__((packed));
```

**Binary Layout:**
```
Offset  Field               Size  Type
------  ------------------  ----  ------
0x00    version             1     u8
0x01    operation           1     u8
0x02    permission_result   1     u8
0x03    reserved            1     u8
0x04    timestamp_ns        8     u64
0x0C    pid                 4     u32
0x10    tid                 4     u32
0x14    uid                 4     u32
0x18    gid                 4     u32
0x1C    inode               8     u64
0x24    device_id           4     u32
0x28    mode                4     u32
0x2C    path_len            2     u16
0x2E    padding             2     [u8; 2]
0x30    path                256   [u8; 256]
Total:  304 bytes
```

---

### 4. NetworkEvent

Network activity monitoring event for tracking connections and traffic.

**Purpose:** Monitor network connections including source/destination addresses, ports, and protocol information.

**Fields:**

| Field | Type | Size | Description |
|-------|------|------|-------------|
| `version` | `u8` | 1 byte | Event format version (must be 1) |
| `protocol` | `u8` | 1 byte | Network protocol (see NetworkProtocol enum) |
| `direction` | `u8` | 1 byte | Connection direction (see NetworkDirection enum) |
| `reserved` | `u8` | 1 byte | Reserved for future use (must be 0) |
| `timestamp_ns` | `u64` | 8 bytes | Timestamp in nanoseconds (CLOCK_MONOTONIC) |
| `pid` | `u32` | 4 bytes | Process ID |
| `tid` | `u32` | 4 bytes | Thread ID |
| `src_ip` | `[u8; 16]` | 16 bytes | Source IP address (IPv4 or IPv6) |
| `dst_ip` | `[u8; 16]` | 16 bytes | Destination IP address (IPv4 or IPv6) |
| `src_port` | `u16` | 2 bytes | Source port |
| `dst_port` | `u16` | 2 bytes | Destination port |
| `packet_size` | `u32` | 4 bytes | Packet size in bytes |
| `is_ipv4` | `u8` | 1 byte | IP version flag (1=IPv4, 0=IPv6) |
| `padding` | `[u8; 3]` | 3 bytes | Padding for alignment |

**Total Size:** 72 bytes

**Rust Definition:**
```rust
#[repr(C, packed)]
#[derive(Clone, Copy, Debug)]
pub struct NetworkEvent {
    pub version: u8,
    pub protocol: u8,
    pub direction: u8,
    pub reserved: u8,
    pub timestamp_ns: u64,
    pub pid: u32,
    pub tid: u32,
    pub src_ip: [u8; 16],
    pub dst_ip: [u8; 16],
    pub src_port: u16,
    pub dst_port: u16,
    pub packet_size: u32,
    pub is_ipv4: u8,
    pub padding: [u8; 3],
}

impl Default for NetworkEvent {
    fn default() -> Self {
        Self {
            version: 1,
            protocol: 0,
            direction: 0,
            reserved: 0,
            timestamp_ns: 0,
            pid: 0,
            tid: 0,
            src_ip: [0; 16],
            dst_ip: [0; 16],
            src_port: 0,
            dst_port: 0,
            packet_size: 0,
            is_ipv4: 0,
            padding: [0; 3],
        }
    }
}
```

**C Definition:**
```c
struct network_event {
    __u8 version;
    __u8 protocol;
    __u8 direction;
    __u8 reserved;
    __u64 timestamp_ns;
    __u32 pid;
    __u32 tid;
    __u8 src_ip[16];
    __u8 dst_ip[16];
    __u16 src_port;
    __u16 dst_port;
    __u32 packet_size;
    __u8 is_ipv4;
    __u8 padding[3];
} __attribute__((packed));
```

**Binary Layout:**
```
Offset  Field           Size  Type
------  --------------  ----  ------
0x00    version         1     u8
0x01    protocol        1     u8
0x02    direction       1     u8
0x03    reserved        1     u8
0x04    timestamp_ns    8     u64
0x0C    pid             4     u32
0x10    tid             4     u32
0x14    src_ip          16    [u8; 16]
0x24    dst_ip          16    [u8; 16]
0x34    src_port        2     u16
0x36    dst_port        2     u16
0x38    packet_size     4     u32
0x3C    is_ipv4         1     u8
0x3D    padding         3     [u8; 3]
Total:  72 bytes
```

---

### 5. CgroupEvent

Cgroup resource monitoring event for tracking resource usage and thresholds.

**Purpose:** Monitor cgroup resource usage and generate alerts when thresholds are exceeded.

**Fields:**

| Field | Type | Size | Description |
|-------|------|------|-------------|
| `version` | `u8` | 1 byte | Event format version (must be 1) |
| `metric_type` | `u8` | 1 byte | Metric type (see CgroupMetricType enum) |
| `alert_flag` | `u8` | 1 byte | Alert flag (0=normal, 1=threshold exceeded) |
| `reserved` | `u8` | 1 byte | Reserved for future use (must be 0) |
| `timestamp_ns` | `u64` | 8 bytes | Timestamp in nanoseconds (CLOCK_MONOTONIC) |
| `cgroup_id` | `u64` | 8 bytes | Cgroup ID (from cgroup_id()) |
| `value` | `u64` | 8 bytes | Current metric value |
| `threshold` | `u64` | 8 bytes | Threshold value for alert |
| `pid_count` | `u32` | 4 bytes | Number of processes in cgroup |
| `cgroup_path_len` | `u16` | 2 bytes | Length of cgroup path string |
| `cgroup_path` | `[u8; 256]` | 256 bytes | Cgroup path (null-terminated) |

**Total Size:** 304 bytes

**Rust Definition:**
```rust
#[repr(C, packed)]
#[derive(Clone, Copy, Debug)]
pub struct CgroupEvent {
    pub version: u8,
    pub metric_type: u8,
    pub alert_flag: u8,
    pub reserved: u8,
    pub timestamp_ns: u64,
    pub cgroup_id: u64,
    pub value: u64,
    pub threshold: u64,
    pub pid_count: u32,
    pub cgroup_path_len: u16,
    pub cgroup_path: [u8; 256],
}

impl Default for CgroupEvent {
    fn default() -> Self {
        Self {
            version: 1,
            metric_type: 0,
            alert_flag: 0,
            reserved: 0,
            timestamp_ns: 0,
            cgroup_id: 0,
            value: 0,
            threshold: 0,
            pid_count: 0,
            cgroup_path_len: 0,
            cgroup_path: [0; 256],
        }
    }
}
```

**C Definition:**
```c
struct cgroup_event {
    __u8 version;
    __u8 metric_type;
    __u8 alert_flag;
    __u8 reserved;
    __u64 timestamp_ns;
    __u64 cgroup_id;
    __u64 value;
    __u64 threshold;
    __u32 pid_count;
    __u16 cgroup_path_len;
    char cgroup_path[256];
} __attribute__((packed));
```

**Binary Layout:**
```
Offset  Field               Size  Type
------  ------------------  ----  ------
0x00    version             1     u8
0x01    metric_type         1     u8
0x02    alert_flag          1     u8
0x03    reserved            1     u8
0x04    timestamp_ns        8     u64
0x0C    cgroup_id           8     u64
0x14    value               8     u64
0x1C    threshold           8     u64
0x24    pid_count           4     u32
0x28    cgroup_path_len     2     u16
0x2A    padding             2     [u8; 2]
0x2C    cgroup_path         256   [u8; 256]
Total:  304 bytes
```

---

## Event Type Discriminator

All events share a common header for type identification:

```rust
#[repr(C, packed)]
#[derive(Clone, Copy, Debug)]
pub struct EventHeader {
    pub version: u8,
    pub event_id: u8,
    pub reserved: [u8; 2],
    pub timestamp_ns: u64,
}
```

**Event ID Mapping:**

| Event ID | Event Type | Struct |
|----------|------------|--------|
| 1 | ANOMALY | AnomalyEvent |
| 2 | SYSCALL_TRACE | SyscallTraceEvent |
| 3 | FILE_ACCESS | FileAccessEvent |
| 4 | NETWORK | NetworkEvent |
| 5 | CGROUP | CgroupEvent |

---

## CO-RE Compatibility Requirements

### BTF Type Information

All structs must include BTF type information for CO-RE compatibility:

```c
// BTF type annotations (for bpftool)
struct anomaly_event {
    __u8 version;                    /* offset: 0, size: 1 */
    __u8 event_type;                 /* offset: 1, size: 1 */
    __u8 severity_code;              /* offset: 2, size: 1 */
    __u8 reserved;                   /* offset: 3, size: 1 */
    __u64 timestamp_ns;              /* offset: 4, size: 8 */
    // ... rest of fields
};
```

### Field Offset Verification

When using CO-RE, verify field offsets at runtime:

```rust
use aya::Btf;

fn verify_offsets() {
    let btf = Btf::from_sys_fs()?;
    assert_eq!(btf.field_offset("anomaly_event", "timestamp_ns")?, 4);
    assert_eq!(btf.field_offset("anomaly_event", "pid")?, 12);
    // ... verify all critical offsets
}
```

---

## Ring Buffer Configuration

### Buffer Size Recommendations

| Event Type | Max Events/sec | Recommended Ring Buffer Size |
|------------|----------------|----------------------------|
| AnomalyEvent | 100 | 64 KB |
| SyscallTraceEvent | 10,000 | 2 MB |
| FileAccessEvent | 5,000 | 1 MB |
| NetworkEvent | 20,000 | 4 MB |
| CgroupEvent | 500 | 128 KB |

### Event Loss Handling

If ring buffer is full, events are dropped. Userspace receiver should:

1. Monitor `bpftool prog show` for dropped events
2. Implement backpressure mechanism
3. Log event loss statistics

---

## Version Compatibility

### Version 1.0 (Current)

- Initial release
- All structs defined above
- CO-RE compatible
- Aya-rs 0.13+ support

### Future Versioning Rules

1. **Minor Version (1.x):** Add new fields at the end, maintain backward compatibility
2. **Major Version (2.0):** Breaking changes, requires coordinated update
3. **Version Check:** Always verify `version` field before parsing

---

## Security Considerations

### Data Validation

Userspace receiver must validate:

1. `version` field equals expected version
2. String lengths do not exceed buffer sizes
3. Enum values are within valid ranges
4. Timestamps are reasonable (not in future)

### Memory Safety

- All kernel-space structs use fixed-size arrays
- No dynamic allocation in eBPF programs
- String fields are null-terminated
- Padding bytes must be zero-initialized

---

## Testing Requirements

### Unit Tests

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_anomaly_event_size() {
        assert_eq!(std::mem::size_of::<AnomalyEvent>(), 1056);
    }

    #[test]
    fn test_syscall_trace_event_size() {
        assert_eq!(std::mem::size_of::<SyscallTraceEvent>(), 104);
    }

    #[test]
    fn test_file_access_event_size() {
        assert_eq!(std::mem::size_of::<FileAccessEvent>(), 304);
    }

    #[test]
    fn test_network_event_size() {
        assert_eq!(std::mem::size_of::<NetworkEvent>(), 72);
    }

    #[test]
    fn test_cgroup_event_size() {
        assert_eq!(std::mem::size_of::<CgroupEvent>(), 304);
    }
}
```

### Integration Tests

1. Load eBPF program with Aya-rs
2. Generate test events from kernel space
3. Verify userspace receiver parses correctly
4. Validate field offsets match BTF

---

## References

- Aya-rs Documentation: https://aya-rs.dev/
- BPF Type Format (BTF): https://www.kernel.org/doc/html/latest/bpf/btf.html
- CO-RE (Compile Once, Run Everywhere): https://nakryiko.com/posts/bpf-portability/
- Linux Kernel eBPF Documentation: https://www.kernel.org/doc/html/latest/bpf/index.html

---

## Appendix: Complete C Header File

```c
#ifndef CLAWOS_EBPF_EVENTS_H
#define CLAWOS_EBPF_EVENTS_H

#include <linux/types.h>

/* Event Types */
enum event_type {
    EVENT_TYPE_UNKNOWN = 0,
    EVENT_TYPE_SYSCALL_ANOMALY = 1,
    EVENT_TYPE_FILE_ACCESS_VIOLATION = 2,
    EVENT_TYPE_NETWORK_SUSPICIOUS = 3,
    EVENT_TYPE_CGROUP_THRESHOLD = 4,
    EVENT_TYPE_PROCESS_ANOMALY = 5,
    EVENT_TYPE_SECURITY_VIOLATION = 6,
};

/* Severity Codes */
enum severity_code {
    SEVERITY_INFO = 0,
    SEVERITY_LOW = 1,
    SEVERITY_MEDIUM = 2,
    SEVERITY_HIGH = 3,
    SEVERITY_CRITICAL = 4,
};

/* File Operations */
enum file_operation {
    FILE_OP_READ = 0,
    FILE_OP_WRITE = 1,
    FILE_OP_EXECUTE = 2,
    FILE_OP_DELETE = 3,
    FILE_OP_CREATE = 4,
    FILE_OP_RENAME = 5,
};

/* Network Protocols */
enum network_protocol {
    PROTOCOL_UNKNOWN = 0,
    PROTOCOL_TCP = 1,
    PROTOCOL_UDP = 2,
    PROTOCOL_ICMP = 3,
    PROTOCOL_ICMPV6 = 4,
};

/* Network Directions */
enum network_direction {
    DIRECTION_UNKNOWN = 0,
    DIRECTION_INBOUND = 1,
    DIRECTION_OUTBOUND = 2,
};

/* Cgroup Metric Types */
enum cgroup_metric_type {
    METRIC_UNKNOWN = 0,
    METRIC_MEMORY_USAGE = 1,
    METRIC_CPU_USAGE = 2,
    METRIC_PID_COUNT = 3,
    METRIC_IO_READ_BYTES = 4,
    METRIC_IO_WRITE_BYTES = 5,
    METRIC_NETWORK_RX_BYTES = 6,
    METRIC_NETWORK_TX_BYTES = 7,
};

/* Event Header */
struct event_header {
    __u8 version;
    __u8 event_id;
    __u8 reserved[2];
    __u64 timestamp_ns;
} __attribute__((packed));

/* Anomaly Event */
struct anomaly_event {
    __u8 version;
    __u8 event_type;
    __u8 severity_code;
    __u8 reserved;
    __u64 timestamp_ns;
    __u32 pid;
    __u32 tid;
    __u32 uid;
    __u32 gid;
    __u16 description_len;
    __u16 metadata_count;
    char description[256];
    char metadata_keys[8][32];
    char metadata_values[8][64];
} __attribute__((packed));

/* Syscall Trace Event */
struct syscall_trace_event {
    __u8 version;
    __u8 reserved;
    __u16 sysnum;
    __u64 timestamp_ns;
    __u32 pid;
    __u32 tid;
    __s64 return_value;
    __u64 duration_ns;
    __u8 arg_count;
    __u64 args[6];
    char comm[16];
} __attribute__((packed));

/* File Access Event */
struct file_access_event {
    __u8 version;
    __u8 operation;
    __u8 permission_result;
    __u8 reserved;
    __u64 timestamp_ns;
    __u32 pid;
    __u32 tid;
    __u32 uid;
    __u32 gid;
    __u64 inode;
    __u32 device_id;
    __u32 mode;
    __u16 path_len;
    char path[256];
} __attribute__((packed));

/* Network Event */
struct network_event {
    __u8 version;
    __u8 protocol;
    __u8 direction;
    __u8 reserved;
    __u64 timestamp_ns;
    __u32 pid;
    __u32 tid;
    __u8 src_ip[16];
    __u8 dst_ip[16];
    __u16 src_port;
    __u16 dst_port;
    __u32 packet_size;
    __u8 is_ipv4;
    __u8 padding[3];
} __attribute__((packed));

/* Cgroup Event */
struct cgroup_event {
    __u8 version;
    __u8 metric_type;
    __u8 alert_flag;
    __u8 reserved;
    __u64 timestamp_ns;
    __u64 cgroup_id;
    __u64 value;
    __u64 threshold;
    __u32 pid_count;
    __u16 cgroup_path_len;
    char cgroup_path[256];
} __attribute__((packed));

/* Event IDs */
#define EVENT_ID_ANOMALY 1
#define EVENT_ID_SYSCALL_TRACE 2
#define EVENT_ID_FILE_ACCESS 3
#define EVENT_ID_NETWORK 4
#define EVENT_ID_CGROUP 5

/* Version */
#define EVENT_VERSION 1

#endif /* CLAWOS_EBPF_EVENTS_H */
```

---

**END OF SPECIFICATION**
