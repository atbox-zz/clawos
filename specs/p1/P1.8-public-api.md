# P1.8: ClawOS Public API Surface Specification

**Status:** ðŸ”’ FROZEN
**Version:** v1.0.0
**Date:** 2026-02-24
**Owner:** Core Dev Agent
**SHA256:** `PLACEHOLDER_SHA256_SIGNATURE`

---

## Overview

This specification defines the **ClawOS Public API Surface** - the syscall interface exposed to userspace tools and components. The API extends Linux 6.6 LTS syscalls with ClawOS-specific calls, providing a secure, monitored interface for AI agent tools running in WASM sandboxes.

### Scope

The public API surface includes:
- **ClawOS-specific syscalls** for file system, network, process, memory, security, and monitoring operations
- **WIT bindings** for WASM tools (reference P1.1)
- **Error code mappings** to P1.7 IPC protocol
- **Security requirements** for each syscall
- **Performance characteristics** for latency-sensitive operations
- **API versioning and deprecation policies**

### Design Principles

1. **Security-First**: All syscalls are monitored by eBPF LSM hooks
2. **Capability-Based**: Resources accessed through handles, not direct memory
3. **Explicit Error Handling**: All operations return explicit error codes
4. **Namespace Isolation**: Process operations isolated in user namespaces
5. **XDP-Monitored Network**: All network traffic monitored by XDP layer

---

## Table of Contents

1. [API Versioning Strategy](#api-versioning-strategy)
2. [Deprecation Policy](#deprecation-policy)
3. [ABI Stability Guarantees](#abi-stability-guarantees)
4. [Error Code Mapping](#error-code-mapping)
5. [Syscall Categories](#syscall-categories)
   - [File System Syscalls](#file-system-syscalls)
   - [Network Syscalls](#network-syscalls)
   - [Process Syscalls](#process-syscalls)
   - [Memory Syscalls](#memory-syscalls)
   - [Security Syscalls](#security-syscalls)
   - [Monitoring Syscalls](#monitoring-syscalls)
6. [WIT Bindings](#wit-bindings)
7. [Usage Examples](#usage-examples)
8. [Appendices](#appendices)

---

## API Versioning Strategy

### Semantic Versioning (SemVer)

ClawOS public API follows **Semantic Versioning 2.0.0**:

```
MAJOR.MINOR.PATCH
```

| Component | Meaning                                     | Example           |
| ----------| --------------------------------------------| ------------------|
| **MAJOR** | Incompatible API changes                    | `1.0.0` â†’ `2.0.0` |
| **MINOR** | Backward-compatible functionality additions | `1.0.0` â†’ `1.1.0` |
| **PATCH** | Backward-compatible bug fixes               | `1.0.0` â†’ `1.0.1` |

### Version Numbering Rules

1. **MAJOR Version Bump** (Breaking Changes):
   - Remove or rename a syscall
   - Change syscall signature (parameter types, order)
   - Change error code mapping
   - Remove a required capability

2. **MINOR Version Bump** (Additive Changes):
   - Add new syscalls
   - Add new optional parameters to existing syscalls
   - Add new error codes (existing codes unchanged)
   - Add new capabilities

3. **PATCH Version Bump** (Bug Fixes):
   - Fix syscall behavior without changing signature
   - Update documentation
   - Improve performance without API changes

### Version Detection

Tools can query the API version at runtime:

```c
// C example
struct clawos_api_version {
    uint32_t major;
    uint32_t minor;
    uint32_t patch;
};

int claw_api_get_version(struct clawos_api_version *version);
```

```rust
// Rust example
#[repr(C)]
pub struct ClawosApiVersion {
    pub major: u32,
    pub minor: u32,
    pub patch: u32,
}

extern "C" {
    fn claw_api_get_version(version: *mut ClawosApiVersion) -> i32;
}
```

---

## Deprecation Policy

### Deprecation Timeline

| Phase              | Duration        | Description                                   |
| -------------------| ----------------| ----------------------------------------------|
| **Announcement**   | Day 0           | Deprecation notice published in release notes |
| **Warning Period** | 12 months       | Deprecation warnings logged on each use       |
| **Removal**        | After 12 months | Deprecated API removed in next MAJOR version  |

### Deprecation Process

1. **Announcement**:
   - Document deprecation in release notes
   - Add `@deprecated` attribute to syscall documentation
   - Provide migration guide with examples

2. **Warning Period**:
   - Each deprecated syscall call logs a warning via `claw_log_write`
   - Warning includes: deprecated syscall name, replacement, removal date
   - No functional changes during warning period

3. **Removal**:
   - Deprecated syscalls removed in next MAJOR version bump
   - Attempting to call removed syscall returns `EPROTO` (5)

### Example Deprecation Notice

```
DEPRECATION WARNING: claw_fs_open_v1 is deprecated and will be removed in v2.0.0.
Use claw_fs_open_v2 instead. Removal date: 2027-02-24.
See: https://clawos.org/docs/api/migration/v1-to-v2
```

### Migration Support

- **Migration Guides**: Published for each deprecation
- **Compatibility Shims**: Optional compatibility layer for transition period
- **Automated Tools**: Linting tools to detect deprecated API usage

---

## ABI Stability Guarantees

### Stability Contract

| API Version    | Stability Guarantee | Duration                 |
| ---------------| --------------------| -------------------------|
| **Same MAJOR** | Binary compatible   | Until next MAJOR version |
| **Same MINOR** | Source compatible   | Until next MAJOR version |
| **Same PATCH** | Behavior compatible | Until next MINOR version |

### Binary Compatibility

**Guaranteed within same MAJOR version:**
- Syscall numbers unchanged
- Syscall signatures unchanged (parameter types, order)
- Return value types unchanged
- Error code mappings unchanged
- Data structure layouts unchanged

**Example:**
```c
// Binary compiled against ClawOS v1.0.0 will work on v1.5.0 without recompilation
// Binary compiled against ClawOS v1.0.0 will NOT work on v2.0.0 (recompile required)
```

### Source Compatibility

**Guaranteed within same MAJOR version:**
- New syscalls added (old code continues to work)
- New optional parameters added (old code continues to work)
- New error codes added (old code continues to work)

**Example:**
```c
// Code written for ClawOS v1.0.0 will compile on v1.5.0 without changes
// Code written for ClawOS v1.0.0 may require changes for v2.0.0
```

### Behavior Compatibility

**Guaranteed within same MINOR version:**
- Bug fixes only
- Performance improvements
- Documentation updates

**Example:**
```c
// Code behavior on ClawOS v1.0.0 matches v1.0.5 (bug fixes only)
// Code behavior on ClawOS v1.0.0 may differ from v1.1.0 (new features)
```

### Breaking Changes

**Breaking changes require MAJOR version bump:**
- Syscall removal
- Syscall signature change
- Error code mapping change
- Required capability change
- Data structure layout change

---

## Error Code Mapping

### Mapping to P1.7 IPC Protocol

All ClawOS syscalls return error codes that map 1:1 to P1.7 IPC protocol error codes:

| IPC Code | Name      | Description                            | Syscall Mapping |
| ---------| ----------| ---------------------------------------| ----------------|
| 0        | SUCCESS   | Operation completed successfully       | Return 0        |
| 1        | EAGAIN    | Operation would block                  | Return 1        |
| 2        | EIO       | I/O error                              | Return 2        |
| 3        | ENOENT    | Entity not found                       | Return 3        |
| 4        | EPERM     | Permission denied                      | Return 4        |
| 5        | EPROTO    | Protocol error                         | Return 5        |
| 6        | ETIMEOUT  | Operation timeout                      | Return 6        |
| 7        | EINTERNAL | Internal error (should be logged)      | Return 7        |
| 8        | EPANIC    | Unrecoverable error (trigger rollback) | Return 8        |

### Error Handling Best Practices

1. **Always check return values**: All syscalls return error codes
2. **Handle errors explicitly**: Never ignore errors
3. **Log errors**: Use `claw_log_write` for debugging
4. **Propagate errors**: Return errors to callers when appropriate
5. **Clean up resources**: Always close resources even on error

### Error Code Constants

```c
// C header: clawos_errno.h
#define CLAW_SUCCESS  0
#define CLAW_EAGAIN   1
#define CLAW_EIO      2
#define CLAW_ENOENT   3
#define CLAW_EPERM    4
#define CLAW_EPROTO   5
#define CLAW_ETIMEOUT 6
#define CLAW_EINTERNAL 7
#define CLAW_EPANIC   8
```

```rust
// Rust module: clawos::errno
pub const CLAW_SUCCESS: i32 = 0;
pub const CLAW_EAGAIN: i32 = 1;
pub const CLAW_EIO: i32 = 2;
pub const CLAW_ENOENT: i32 = 3;
pub const CLAW_EPERM: i32 = 4;
pub const CLAW_EPROTO: i32 = 5;
pub const CLAW_ETIMEOUT: i32 = 6;
pub const CLAW_EINTERNAL: i32 = 7;
pub const CLAW_EPANIC: i32 = 8;
```

---

## Syscall Categories

### File System Syscalls

File system syscalls provide secure access to ClawFS (AI-aware filesystem with vector index and encryption).

#### claw_fs_open

Open a file in ClawFS and return a file descriptor handle.

**Signature:**
```c
int claw_fs_open(
    const char *path,           // File path (relative to ClawFS root)
    uint32_t flags,             // Open flags (O_RDONLY, O_WRONLY, O_RDWR, O_CREAT, etc.)
    uint32_t mode,              // File permissions (used when creating)
    int *fd_out                 // Output: file descriptor handle
);
```

**Parameters:**
| Parameter | Type          | Description                                                                                                                   |
| ----------| --------------| ------------------------------------------------------------------------------------------------------------------------------|
| `path`    | `const char*` | File path (relative to ClawFS root, max 4096 bytes)                                                                           |
| `flags`   | `uint32_t`    | Open flags (bitmask: 0x01=O_RDONLY, 0x02=O_WRONLY, 0x04=O_RDWR, 0x100=O_CREAT, 0x200=O_EXCL, 0x1000=O_TRUNC, 0x2000=O_APPEND) |
| `mode`    | `uint32_t`    | File permissions (octal: 0o644 for rw-r--r--, used when O_CREAT set)                                                          |
| `fd_out`  | `int*`        | Output: file descriptor handle (valid on success)                                                                             |

**Return Value:**
| Value | Description                               |
| ------| ------------------------------------------|
| `0`   | Success (file descriptor in `fd_out`)     |
| `1`   | EAGAIN - Resource temporarily unavailable |
| `2`   | EIO - I/O error                           |
| `3`   | ENOENT - File not found                   |
| `4`   | EPERM - Permission denied                 |
| `5`   | EPROTO - Invalid path or flags            |
| `7`   | EINTERNAL - Internal error                |

**Security Requirements:**
- **Capability**: `CAP_CLAWFS_READ` for read, `CAP_CLAWFS_WRITE` for write
- **cgroup**: Must be member of `/sys/fs/cgroup/clawos/tools/<tool-name>`
- **AppArmor**: Path must match allowed paths in AppArmor profile (P1.6)
- **eBPF Monitoring**: All file opens logged via eBPF LSM hook

**Performance Characteristics:**
- **Blocking**: Yes (synchronous I/O)
- **Timeout**: 5 seconds (configurable via cgroup)
- **Latency**: ~100Î¼s (local file), ~10ms (encrypted file)
- **Throughput**: Up to 1 GB/s (local SSD)

**Example (C):**
```c
#include "clawos_api.h"

int fd;
int ret = claw_fs_open("/clawfs/tools/mytool/config.json",
                       O_RDONLY, 0, &fd);
if (ret != CLAW_SUCCESS) {
    claw_log_write(LOG_ERROR, "Failed to open file: error %d", ret);
    return ret;
}

// Use file descriptor...
close(fd);
```

**Example (Rust):**
```rust
use clawos::fs;

let fd = fs::claw_fs_open(
    "/clawfs/tools/mytool/config.json",
    libc::O_RDONLY,
    0
)?;

// Use file descriptor...
// Note: File descriptor is automatically closed when dropped
```

---

#### claw_fs_read

Read data from an open file descriptor.

**Signature:**
```c
int claw_fs_read(
    int fd,                     // File descriptor handle
    void *buffer,               // Buffer to read data into
    size_t count,               // Maximum number of bytes to read
    size_t *bytes_read_out      // Output: actual bytes read
);
```

**Parameters:**
| Parameter        | Type      | Description                                      |
| -----------------| ----------| -------------------------------------------------|
| `fd`             | `int`     | File descriptor handle (from `claw_fs_open`)     |
| `buffer`         | `void*`   | Buffer to read data into (must be pre-allocated) |
| `count`          | `size_t`  | Maximum number of bytes to read                  |
| `bytes_read_out` | `size_t*` | Output: actual bytes read (valid on success)     |

**Return Value:**
| Value | Description                              |
| ------| -----------------------------------------|
| `0`   | Success (bytes read in `bytes_read_out`) |
| `1`   | EAGAIN - Would block (non-blocking mode) |
| `2`   | EIO - I/O error                          |
| `3`   | ENOENT - Invalid file descriptor         |
| `4`   | EPERM - Permission denied                |
| `5`   | EPROTO - Invalid buffer                  |
| `7`   | EINTERNAL - Internal error               |

**Security Requirements:**
- **Capability**: `CAP_CLAWFS_READ`
- **cgroup**: Must be member of tool's cgroup
- **AppArmor**: Read access verified via AppArmor profile
- **eBPF Monitoring**: All file reads logged via eBPF LSM hook

**Performance Characteristics:**
- **Blocking**: Yes (synchronous I/O)
- **Timeout**: 5 seconds (configurable via cgroup)
- **Latency**: ~50Î¼s (local file), ~5ms (encrypted file)
- **Throughput**: Up to 1 GB/s (local SSD)

**Example (C):**
```c
#include "clawos_api.h"

char buffer[4096];
size_t bytes_read;
int ret = claw_fs_read(fd, buffer, sizeof(buffer), &bytes_read);
if (ret != CLAW_SUCCESS) {
    claw_log_write(LOG_ERROR, "Failed to read file: error %d", ret);
    return ret;
}

printf("Read %zu bytes\n", bytes_read);
```

**Example (Rust):**
```rust
use clawos::fs;

let mut buffer = vec![0u8; 4096];
let bytes_read = fs::claw_fs_read(fd, &mut buffer)?;

println!("Read {} bytes", bytes_read);
```

---

#### claw_fs_write

Write data to an open file descriptor.

**Signature:**
```c
int claw_fs_write(
    int fd,                     // File descriptor handle
    const void *buffer,         // Buffer containing data to write
    size_t count,               // Number of bytes to write
    size_t *bytes_written_out   // Output: actual bytes written
);
```

**Parameters:**
| Parameter           | Type          | Description                                     |
| --------------------| --------------| ------------------------------------------------|
| `fd`                | `int`         | File descriptor handle (from `claw_fs_open`)    |
| `buffer`            | `const void*` | Buffer containing data to write                 |
| `count`             | `size_t`      | Number of bytes to write                        |
| `bytes_written_out` | `size_t*`     | Output: actual bytes written (valid on success) |

**Return Value:**
| Value | Description                                    |
| ------| -----------------------------------------------|
| `0`   | Success (bytes written in `bytes_written_out`) |
| `1`   | EAGAIN - Would block (non-blocking mode)       |
| `2`   | EIO - I/O error                                |
| `3`   | ENOENT - Invalid file descriptor               |
| `4`   | EPERM - Permission denied                      |
| `5`   | EPROTO - Invalid buffer                        |
| `7`   | EINTERNAL - Internal error                     |

**Security Requirements:**
- **Capability**: `CAP_CLAWFS_WRITE`
- **cgroup**: Must be member of tool's cgroup
- **AppArmor**: Write access verified via AppArmor profile
- **eBPF Monitoring**: All file writes logged via eBPF LSM hook

**Performance Characteristics:**
- **Blocking**: Yes (synchronous I/O)
- **Timeout**: 5 seconds (configurable via cgroup)
- **Latency**: ~50Î¼s (local file), ~10ms (encrypted file)
- **Throughput**: Up to 1 GB/s (local SSD)

**Example (C):**
```c
#include "clawos_api.h"

const char *data = "Hello, ClawOS!";
size_t bytes_written;
int ret = claw_fs_write(fd, data, strlen(data), &bytes_written);
if (ret != CLAW_SUCCESS) {
    claw_log_write(LOG_ERROR, "Failed to write file: error %d", ret);
    return ret;
}

printf("Wrote %zu bytes\n", bytes_written);
```

**Example (Rust):**
```rust
use clawos::fs;

let data = b"Hello, ClawOS!";
let bytes_written = fs::claw_fs_write(fd, data)?;

println!("Wrote {} bytes", bytes_written);
```

---

#### claw_fs_close

Close an open file descriptor.

**Signature:**
```c
int claw_fs_close(
    int fd                      // File descriptor handle
);
```

**Parameters:**
| Parameter | Type  | Description                                  |
| ----------| ------| ---------------------------------------------|
| `fd`      | `int` | File descriptor handle (from `claw_fs_open`) |

**Return Value:**
| Value | Description                      |
| ------| ---------------------------------|
| `0`   | Success                          |
| `2`   | EIO - I/O error during close     |
| `3`   | ENOENT - Invalid file descriptor |
| `7`   | EINTERNAL - Internal error       |

**Security Requirements:**
- **Capability**: None (any tool can close its own file descriptors)
- **cgroup**: Must be member of tool's cgroup
- **eBPF Monitoring**: All file closes logged via eBPF LSM hook

**Performance Characteristics:**
- **Blocking**: No (immediate)
- **Timeout**: None
- **Latency**: ~10Î¼s

**Example (C):**
```c
#include "clawos_api.h"

int ret = claw_fs_close(fd);
if (ret != CLAW_SUCCESS) {
    claw_log_write(LOG_ERROR, "Failed to close file: error %d", ret);
    return ret;
}
```

**Example (Rust):**
```rust
use clawos::fs;

fs::claw_fs_close(fd)?;
// Note: In Rust, file descriptors are typically wrapped in types that auto-close on drop
```

---

#### claw_fs_stat

Get file status information (metadata).

**Signature:**
```c
struct claw_fs_stat {
    uint64_t size;              // File size in bytes
    uint32_t mode;              // File mode (permissions + type)
    uint64_t mtime;             // Last modification time (Unix timestamp, nanoseconds)
    uint64_t atime;             // Last access time (Unix timestamp, nanoseconds)
    uint64_t ctime;             // Last status change time (Unix timestamp, nanoseconds)
    uint64_t ino;               // Inode number
    uint64_t dev;               // Device ID
    uint64_t nlink;             // Number of hard links
    uint32_t uid;               // User ID
    uint32_t gid;               // Group ID
    uint64_t blksize;           // Block size
    uint64_t blocks;            // Number of blocks
};

int claw_fs_stat(
    const char *path,           // File path
    struct claw_fs_stat *stat_out // Output: file status information
);
```

**Parameters:**
| Parameter  | Type                   | Description                                         |
| -----------| -----------------------| ----------------------------------------------------|
| `path`     | `const char*`          | File path (relative to ClawFS root, max 4096 bytes) |
| `stat_out` | `struct claw_fs_stat*` | Output: file status information (valid on success)  |

**Return Value:**
| Value | Description                         |
| ------| ------------------------------------|
| `0`   | Success (file status in `stat_out`) |
| `2`   | EIO - I/O error                     |
| `3`   | ENOENT - File not found             |
| `4`   | EPERM - Permission denied           |
| `5`   | EPROTO - Invalid path               |
| `7`   | EINTERNAL - Internal error          |

**Security Requirements:**
- **Capability**: `CAP_CLAWFS_READ`
- **cgroup**: Must be member of tool's cgroup
- **AppArmor**: Path must match allowed paths in AppArmor profile
- **eBPF Monitoring**: All stat calls logged via eBPF LSM hook

**Performance Characteristics:**
- **Blocking**: No (metadata cached)
- **Timeout**: None
- **Latency**: ~10Î¼s (cached), ~1ms (uncached)

**Example (C):**
```c
#include "clawos_api.h"

struct claw_fs_stat stat;
int ret = claw_fs_stat("/clawfs/tools/mytool/config.json", &stat);
if (ret != CLAW_SUCCESS) {
    claw_log_write(LOG_ERROR, "Failed to stat file: error %d", ret);
    return ret;
}

printf("File size: %llu bytes\n", (unsigned long long)stat.size);
printf("Last modified: %llu\n", (unsigned long long)stat.mtime);
```

**Example (Rust):**
```rust
use clawos::fs;

let stat = fs::claw_fs_stat("/clawfs/tools/mytool/config.json")?;

println!("File size: {} bytes", stat.size);
println!("Last modified: {}", stat.mtime);
```

---

### Network Syscalls

Network syscalls provide secure network communication through XDP-monitored kernel hooks. All network traffic is monitored and filtered at the XDP layer for security.

#### claw_net_connect

Connect to a remote host via TCP/UDP (XDP-monitored).

**Signature:**
```c
int claw_net_connect(
    const char *host,           // Remote host address (IPv4, IPv6, or hostname)
    uint16_t port,              // Remote port
    uint32_t protocol,          // Protocol (1=TCP, 2=UDP)
    int *sock_out               // Output: socket handle
);
```

**Parameters:**
| Parameter  | Type          | Description                                                  |
| -----------| --------------| -------------------------------------------------------------|
| `host`     | `const char*` | Remote host address (IPv4, IPv6, or hostname, max 256 bytes) |
| `port`     | `uint16_t`    | Remote port (0-65535)                                        |
| `protocol` | `uint32_t`    | Protocol (1=TCP, 2=UDP)                                      |
| `sock_out` | `int*`        | Output: socket handle (valid on success)                     |

**Return Value:**
| Value | Description                                    |
| ------| -----------------------------------------------|
| `0`   | Success (socket handle in `sock_out`)          |
| `1`   | EAGAIN - Connection in progress (non-blocking) |
| `2`   | EIO - Network error                            |
| `3`   | ENOENT - Host not found                        |
| `4`   | EPERM - Permission denied (port not allowed)   |
| `5`   | EPROTO - Invalid host or port                  |
| `6`   | ETIMEOUT - Connection timeout                  |
| `7`   | EINTERNAL - Internal error                     |

**Security Requirements:**
- **Capability**: `CAP_CLAWNET_CONNECT`
- **cgroup**: Must be member of tool's cgroup
- **XDP Layer**: Port must be in allowed list (default: PostgreSQL 5432 only)
- **AppArmor**: Network access verified via AppArmor profile
- **eBPF Monitoring**: All connections logged via eBPF LSM hook

**Performance Characteristics:**
- **Blocking**: Yes (synchronous connection)
- **Timeout**: 10 seconds (configurable via cgroup)
- **Latency**: ~1ms (local), ~50ms (remote)
- **Throughput**: Up to 10 Gbps (XDP-accelerated)

**Example (C):**
```c
#include "clawos_api.h"

int sock;
int ret = claw_net_connect("localhost", 5432, 1, &sock);  // TCP to PostgreSQL
if (ret != CLAW_SUCCESS) {
    claw_log_write(LOG_ERROR, "Failed to connect: error %d", ret);
    return ret;
}

// Use socket...
claw_net_close(sock);
```

**Example (Rust):**
```rust
use clawos::net;

let sock = net::claw_net_connect("localhost", 5432, 1)?;  // TCP to PostgreSQL

// Use socket...
net::claw_net_close(sock)?;
```

---

#### claw_net_send

Send data over a connected socket.

**Signature:**
```c
int claw_net_send(
    int sock,                   // Socket handle
    const void *buffer,         // Buffer containing data to send
    size_t count,               // Number of bytes to send
    size_t *bytes_sent_out      // Output: actual bytes sent
);
```

**Parameters:**
| Parameter        | Type          | Description                                  |
| -----------------| --------------| ---------------------------------------------|
| `sock`           | `int`         | Socket handle (from `claw_net_connect`)      |
| `buffer`         | `const void*` | Buffer containing data to send               |
| `count`          | `size_t`      | Number of bytes to send                      |
| `bytes_sent_out` | `size_t*`     | Output: actual bytes sent (valid on success) |

**Return Value:**
| Value | Description                              |
| ------| -----------------------------------------|
| `0`   | Success (bytes sent in `bytes_sent_out`) |
| `1`   | EAGAIN - Would block (non-blocking mode) |
| `2`   | EIO - Network error                      |
| `3`   | ENOENT - Invalid socket                  |
| `4`   | EPERM - Permission denied                |
| `5`   | EPROTO - Invalid buffer                  |
| `6`   | ETIMEOUT - Send timeout                  |
| `7`   | EINTERNAL - Internal error               |

**Security Requirements:**
- **Capability**: `CAP_CLAWNET_SEND`
- **cgroup**: Must be member of tool's cgroup
- **XDP Layer**: All packets inspected by XDP
- **eBPF Monitoring**: All sends logged via eBPF LSM hook

**Performance Characteristics:**
- **Blocking**: Yes (synchronous send)
- **Timeout**: 5 seconds (configurable via cgroup)
- **Latency**: ~10Î¼s (local), ~1ms (remote)
- **Throughput**: Up to 10 Gbps (XDP-accelerated)

**Example (C):**
```c
#include "clawos_api.h"

const char *query = "SELECT * FROM users;";
size_t bytes_sent;
int ret = claw_net_send(sock, query, strlen(query), &bytes_sent);
if (ret != CLAW_SUCCESS) {
    claw_log_write(LOG_ERROR, "Failed to send: error %d", ret);
    return ret;
}

printf("Sent %zu bytes\n", bytes_sent);
```

**Example (Rust):**
```rust
use clawos::net;

let query = b"SELECT * FROM users;";
let bytes_sent = net::claw_net_send(sock, query)?;

println!("Sent {} bytes", bytes_sent);
```

---

#### claw_net_recv

Receive data from a connected socket.

**Signature:**
```c
int claw_net_recv(
    int sock,                   // Socket handle
    void *buffer,               // Buffer to receive data into
    size_t count,               // Maximum number of bytes to receive
    size_t *bytes_recv_out      // Output: actual bytes received
);
```

**Parameters:**
| Parameter        | Type      | Description                                         |
| -----------------| ----------| ----------------------------------------------------|
| `sock`           | `int`     | Socket handle (from `claw_net_connect`)             |
| `buffer`         | `void*`   | Buffer to receive data into (must be pre-allocated) |
| `count`          | `size_t`  | Maximum number of bytes to receive                  |
| `bytes_recv_out` | `size_t*` | Output: actual bytes received (valid on success)    |

**Return Value:**
| Value | Description                                  |
| ------| ---------------------------------------------|
| `0`   | Success (bytes received in `bytes_recv_out`) |
| `1`   | EAGAIN - Would block (non-blocking mode)     |
| `2`   | EIO - Network error                          |
| `3`   | ENOENT - Invalid socket                      |
| `4`   | EPERM - Permission denied                    |
| `5`   | EPROTO - Invalid buffer                      |
| `6`   | ETIMEOUT - Receive timeout                   |
| `7`   | EINTERNAL - Internal error                   |

**Security Requirements:**
- **Capability**: `CAP_CLAWNET_RECV`
- **cgroup**: Must be member of tool's cgroup
- **XDP Layer**: All packets inspected by XDP
- **eBPF Monitoring**: All receives logged via eBPF LSM hook

**Performance Characteristics:**
- **Blocking**: Yes (synchronous receive)
- **Timeout**: 5 seconds (configurable via cgroup)
- **Latency**: ~10Î¼s (local), ~1ms (remote)
- **Throughput**: Up to 10 Gbps (XDP-accelerated)

**Example (C):**
```c
#include "clawos_api.h"

char buffer[4096];
size_t bytes_recv;
int ret = claw_net_recv(sock, buffer, sizeof(buffer), &bytes_recv);
if (ret != CLAW_SUCCESS) {
    claw_log_write(LOG_ERROR, "Failed to receive: error %d", ret);
    return ret;
}

printf("Received %zu bytes\n", bytes_recv);
```

**Example (Rust):**
```rust
use clawos::net;

let mut buffer = vec![0u8; 4096];
let bytes_recv = net::claw_net_recv(sock, &mut buffer)?;

println!("Received {} bytes", bytes_recv);
```

---

#### claw_net_close

Close a connected socket.

**Signature:**
```c
int claw_net_close(
    int sock                    // Socket handle
);
```

**Parameters:**
| Parameter | Type  | Description                             |
| ----------| ------| ----------------------------------------|
| `sock`    | `int` | Socket handle (from `claw_net_connect`) |

**Return Value:**
| Value | Description                      |
| ------| ---------------------------------|
| `0`   | Success                          |
| `2`   | EIO - Network error during close |
| `3`   | ENOENT - Invalid socket          |
| `7`   | EINTERNAL - Internal error       |

**Security Requirements:**
- **Capability**: None (any tool can close its own sockets)
- **cgroup**: Must be member of tool's cgroup
- **eBPF Monitoring**: All socket closes logged via eBPF LSM hook

**Performance Characteristics:**
- **Blocking**: No (immediate)
- **Timeout**: None
- **Latency**: ~10Î¼s

**Example (C):**
```c
#include "clawos_api.h"

int ret = claw_net_close(sock);
if (ret != CLAW_SUCCESS) {
    claw_log_write(LOG_ERROR, "Failed to close socket: error %d", ret);
    return ret;
}
```

**Example (Rust):**
```rust
use clawos::net;

net::claw_net_close(sock)?;
// Note: In Rust, sockets are typically wrapped in types that auto-close on drop
```

---

### Process Syscalls

Process syscalls provide secure process management with namespace isolation. All processes are isolated in user namespaces for security.

#### claw_proc_spawn

Spawn a new process in an isolated namespace.

**Signature:**
```c
struct claw_proc_spawn_args {
    const char *executable;     // Executable path
    char *const *argv;          // Argument vector (NULL-terminated)
    char *const *envp;          // Environment vector (NULL-terminated, optional)
    const char *working_dir;    // Working directory (optional, NULL = current)
    uint32_t flags;             // Spawn flags (bitmask)
};

int claw_proc_spawn(
    const struct claw_proc_spawn_args *args,  // Spawn arguments
    int *pid_out               // Output: process ID
);
```

**Parameters:**
| Parameter           | Type                           | Description                                                            |
| --------------------| -------------------------------| -----------------------------------------------------------------------|
| `args`              | `struct claw_proc_spawn_args*` | Spawn arguments                                                        |
| `args->executable`  | `const char*`                  | Executable path (relative to ClawFS root, max 4096 bytes)              |
| `args->argv`        | `char*const*`                  | Argument vector (NULL-terminated, max 64 args)                         |
| `args->envp`        | `char*const*`                  | Environment vector (NULL-terminated, optional, max 64 vars)            |
| `args->working_dir` | `const char*`                  | Working directory (optional, NULL = current)                           |
| `args->flags`       | `uint32_t`                     | Spawn flags (bitmask: 0x01=DETACHED, 0x02=NEW_PID_NS, 0x04=NEW_NET_NS) |
| `pid_out`           | `int*`                         | Output: process ID (valid on success)                                  |

**Return Value:**
| Value | Description                       |
| ------| ----------------------------------|
| `0`   | Success (process ID in `pid_out`) |
| `1`   | EAGAIN - Resource limit reached   |
| `2`   | EIO - I/O error                   |
| `3`   | ENOENT - Executable not found     |
| `4`   | EPERM - Permission denied         |
| `5`   | EPROTO - Invalid arguments        |
| `7`   | EINTERNAL - Internal error        |

**Security Requirements:**
- **Capability**: `CAP_CLAWPROC_SPAWN`
- **cgroup**: Must be member of tool's cgroup
- **Namespace**: Process spawned in isolated user namespace (UID 65534)
- **AppArmor**: Executable must be in allowed paths
- **eBPF Monitoring**: All process spawns logged via eBPF LSM hook

**Performance Characteristics:**
- **Blocking**: Yes (process spawn)
- **Timeout**: 30 seconds (configurable via cgroup)
- **Latency**: ~10ms (process spawn)
- **Overhead**: ~1ms (namespace setup)

**Example (C):**
```c
#include "clawos_api.h"

char *argv[] = {"/bin/ls", "-la", NULL};
char *envp[] = {"PATH=/bin:/usr/bin", NULL};

struct claw_proc_spawn_args args = {
    .executable = "/bin/ls",
    .argv = argv,
    .envp = envp,
    .working_dir = "/clawfs/tools/mytool",
    .flags = 0
};

int pid;
int ret = claw_proc_spawn(&args, &pid);
if (ret != CLAW_SUCCESS) {
    claw_log_write(LOG_ERROR, "Failed to spawn process: error %d", ret);
    return ret;
}

printf("Spawned process with PID %d\n", pid);
```

**Example (Rust):**
```rust
use clawos::proc;

let args = proc::SpawnArgs {
    executable: "/bin/ls",
    argv: &["/bin/ls", "-la"],
    envp: &["PATH=/bin:/usr/bin"],
    working_dir: Some("/clawfs/tools/mytool"),
    flags: 0,
};

let pid = proc::claw_proc_spawn(&args)?;

println!("Spawned process with PID {}", pid);
```

---

#### claw_proc_wait

Wait for a process to exit and retrieve its exit status.

**Signature:**
```c
struct claw_proc_wait_status {
    int pid;                    // Process ID
    int exit_code;              // Exit code (0-255)
    int signal;                 // Signal that caused termination (0 if normal exit)
    uint64_t runtime_ns;        // Process runtime in nanoseconds
};

int claw_proc_wait(
    int pid,                    // Process ID to wait for (0 = any child)
    uint32_t options,           // Wait options (bitmask: 0x01=WNOHANG)
    struct claw_proc_wait_status *status_out  // Output: wait status
);
```

**Parameters:**
| Parameter    | Type                            | Description                                                             |
| -------------| --------------------------------| ------------------------------------------------------------------------|
| `pid`        | `int`                           | Process ID to wait for (0 = any child, -1 = any child in process group) |
| `options`    | `uint32_t`                      | Wait options (bitmask: 0x01=WNOHANG - non-blocking)                     |
| `status_out` | `struct claw_proc_wait_status*` | Output: wait status (valid on success)                                  |

**Return Value:**
| Value | Description                           |
| ------| --------------------------------------|
| `0`   | Success (wait status in `status_out`) |
| `1`   | EAGAIN - No child exited (WNOHANG)    |
| `2`   | EIO - I/O error                       |
| `3`   | ENOENT - No such child process        |
| `4`   | EPERM - Permission denied             |
| `5`   | EPROTO - Invalid arguments            |
| `7`   | EINTERNAL - Internal error            |

**Security Requirements:**
- **Capability**: `CAP_CLAWPROC_WAIT`
- **cgroup**: Must be member of tool's cgroup
- **Namespace**: Can only wait for processes in same namespace
- **eBPF Monitoring**: All wait calls logged via eBPF LSM hook

**Performance Characteristics:**
- **Blocking**: Yes (unless WNOHANG set)
- **Timeout**: None (infinite wait)
- **Latency**: ~10Î¼s (WNOHANG), variable (blocking)

**Example (C):**
```c
#include "clawos_api.h"

struct claw_proc_wait_status status;
int ret = claw_proc_wait(pid, 0, &status);
if (ret != CLAW_SUCCESS) {
    claw_log_write(LOG_ERROR, "Failed to wait for process: error %d", ret);
    return ret;
}

printf("Process %d exited with code %d\n", status.pid, status.exit_code);
printf("Runtime: %llu ns\n", (unsigned long long)status.runtime_ns);
```

**Example (Rust):**
```rust
use clawos::proc;

let status = proc::claw_proc_wait(pid, 0)?;

println!("Process {} exited with code {}", status.pid, status.exit_code);
println!("Runtime: {} ns", status.runtime_ns);
```

---

#### claw_proc_kill

Send a signal to a process.

**Signature:**
```c
int claw_proc_kill(
    int pid,                    // Process ID
    int signal                  // Signal number (e.g., SIGTERM=15, SIGKILL=9)
);
```

**Parameters:**
| Parameter | Type  | Description                            |
| ----------| ------| ---------------------------------------|
| `pid`     | `int` | Process ID                             |
| `signal`  | `int` | Signal number (standard POSIX signals) |

**Return Value:**
| Value | Description                |
| ------| ---------------------------|
| `0`   | Success                    |
| `2`   | EIO - I/O error            |
| `3`   | ENOENT - No such process   |
| `4`   | EPERM - Permission denied  |
| `5`   | EPROTO - Invalid signal    |
| `7`   | EINTERNAL - Internal error |

**Security Requirements:**
- **Capability**: `CAP_CLAWPROC_KILL`
- **cgroup**: Must be member of tool's cgroup
- **Namespace**: Can only kill processes in same namespace
- **eBPF Monitoring**: All kill calls logged via eBPF LSM hook

**Performance Characteristics:**
- **Blocking**: No (immediate)
- **Timeout**: None
- **Latency**: ~10Î¼s

**Example (C):**
```c
#include "clawos_api.h"

int ret = claw_proc_kill(pid, SIGTERM);  // Graceful termination
if (ret != CLAW_SUCCESS) {
    claw_log_write(LOG_ERROR, "Failed to kill process: error %d", ret);
    return ret;
}

printf("Sent SIGTERM to process %d\n", pid);
```

**Example (Rust):**
```rust
use clawos::proc;

proc::claw_proc_kill(pid, libc::SIGTERM)?;  // Graceful termination

println!("Sent SIGTERM to process {}", pid);
```

---

### Memory Syscalls

Memory syscalls provide WASM-managed memory allocation and deallocation. All memory operations are sandboxed and monitored.

#### claw_mem_alloc

Allocate memory in the WASM sandbox.

**Signature:**
```c
int claw_mem_alloc(
    size_t size,                // Size in bytes to allocate
    void **ptr_out              // Output: pointer to allocated memory
);
```

**Parameters:**
| Parameter | Type     | Description                                            |
| ----------| ---------| -------------------------------------------------------|
| `size`    | `size_t` | Size in bytes to allocate (max 64MB per allocation)    |
| `ptr_out` | `void**` | Output: pointer to allocated memory (valid on success) |

**Return Value:**
| Value | Description                    |
| ------| -------------------------------|
| `0`   | Success (pointer in `ptr_out`) |
| `1`   | EAGAIN - Memory limit reached  |
| `2`   | EIO - I/O error                |
| `4`   | EPERM - Permission denied      |
| `5`   | EPROTO - Invalid size          |
| `7`   | EINTERNAL - Internal error     |

**Security Requirements:**
- **Capability**: `CAP_CLAWMEM_ALLOC`
- **cgroup**: Must be member of tool's cgroup
- **WASM Sandbox**: Memory allocated in WASM heap (isolated from kernel)
- **eBPF Monitoring**: All allocations logged via eBPF LSM hook

**Performance Characteristics:**
- **Blocking**: No (immediate)
- **Timeout**: None
- **Latency**: ~1Î¼s (small allocation), ~100Î¼s (large allocation)
- **Limit**: 64MB total per tool (configurable via cgroup)

**Example (C):**
```c
#include "clawos_api.h"

void *ptr;
int ret = claw_mem_alloc(1024, &ptr);  // Allocate 1KB
if (ret != CLAW_SUCCESS) {
    claw_log_write(LOG_ERROR, "Failed to allocate memory: error %d", ret);
    return ret;
}

// Use memory...
memset(ptr, 0, 1024);

// Free memory
claw_mem_free(ptr);
```

**Example (Rust):**
```rust
use clawos::mem;

let ptr = mem::claw_mem_alloc(1024)?;  // Allocate 1KB

// Use memory...
unsafe {
    std::ptr::write_bytes(ptr, 0, 1024);
}

// Free memory
mem::claw_mem_free(ptr)?;
```

---

#### claw_mem_free

Free previously allocated memory.

**Signature:**
```c
int claw_mem_free(
    void *ptr                    // Pointer to memory to free
);
```

**Parameters:**
| Parameter | Type    | Description                                               |
| ----------| --------| ----------------------------------------------------------|
| `ptr`     | `void*` | Pointer to memory to free (must be from `claw_mem_alloc`) |

**Return Value:**
| Value | Description                |
| ------| ---------------------------|
| `0`   | Success                    |
| `2`   | EIO - I/O error            |
| `3`   | ENOENT - Invalid pointer   |
| `4`   | EPERM - Permission denied  |
| `7`   | EINTERNAL - Internal error |

**Security Requirements:**
- **Capability**: `CAP_CLAWMEM_FREE`
- **cgroup**: Must be member of tool's cgroup
- **WASM Sandbox**: Memory freed from WASM heap
- **eBPF Monitoring**: All frees logged via eBPF LSM hook

**Performance Characteristics:**
- **Blocking**: No (immediate)
- **Timeout**: None
- **Latency**: ~1Î¼s

**Example (C):**
```c
#include "clawos_api.h"

int ret = claw_mem_free(ptr);
if (ret != CLAW_SUCCESS) {
    claw_log_write(LOG_ERROR, "Failed to free memory: error %d", ret);
    return ret;
}
```

**Example (Rust):**
```rust
use clawos::mem;

mem::claw_mem_free(ptr)?;
// Note: In Rust, memory is typically managed via RAII types
```

---

### Security Syscalls

Security syscalls provide security policy enforcement, cgroup management, and namespace operations.

#### claw_seccomp_apply

Apply a seccomp-BPF filter to the current process.

**Signature:**
```c
int claw_seccomp_apply(
    const uint8_t *filter,      // seccomp-BPF filter bytecode
    size_t filter_size          // Filter size in bytes
);
```

**Parameters:**
| Parameter     | Type             | Description                                             |
| --------------| -----------------| --------------------------------------------------------|
| `filter`      | `const uint8_t*` | seccomp-BPF filter bytecode (compiled from P1.2 schema) |
| `filter_size` | `size_t`         | Filter size in bytes (max 16KB)                         |

**Return Value:**
| Value | Description                     |
| ------| --------------------------------|
| `0`   | Success                         |
| `1`   | EAGAIN - Resource limit reached |
| `2`   | EIO - I/O error                 |
| `4`   | EPERM - Permission denied       |
| `5`   | EPROTO - Invalid filter         |
| `7`   | EINTERNAL - Internal error      |

**Security Requirements:**
- **Capability**: `CAP_CLAWSEC_SECCOMP`
- **cgroup**: Must be member of tool's cgroup
- **AppArmor**: Filter must be approved by Security Agent
- **eBPF Monitoring**: All seccomp applications logged via eBPF LSM hook

**Performance Characteristics:**
- **Blocking**: No (immediate)
- **Timeout**: None
- **Latency**: ~100Î¼s (filter load)
- **Overhead**: ~10ns per syscall (filter evaluation)

**Example (C):**
```c
#include "clawos_api.h"

// Load seccomp filter from file
uint8_t filter[16384];
size_t filter_size = load_filter_from_file("seccomp_filter.bin", filter, sizeof(filter));

int ret = claw_seccomp_apply(filter, filter_size);
if (ret != CLAW_SUCCESS) {
    claw_log_write(LOG_ERROR, "Failed to apply seccomp filter: error %d", ret);
    return ret;
}

printf("seccomp filter applied successfully\n");
```

**Example (Rust):**
```rust
use clawos::security;

let filter = load_filter_from_file("seccomp_filter.bin")?;
security::claw_seccomp_apply(&filter)?;

println!("seccomp filter applied successfully");
```

---

#### claw_cgroup_set

Set cgroup v2 resource limits for the current process.

**Signature:**
```c
struct claw_cgroup_limits {
    uint64_t memory_max;        // Memory limit in bytes (0 = unlimited)
    uint64_t cpu_max;           // CPU quota (e.g., 100000 for 10% of 1 CPU)
    uint64_t cpu_period;        // CPU period in microseconds (default: 1000000)
    uint64_t pids_max;          // Maximum number of PIDs (0 = unlimited)
    uint64_t io_max;            // I/O bandwidth limit in bytes/sec (0 = unlimited)
};

int claw_cgroup_set(
    const char *cgroup_path,    // Cgroup path (e.g., "/sys/fs/cgroup/clawos/tools/mytool")
    const struct claw_cgroup_limits *limits  // Resource limits
);
```

**Parameters:**
| Parameter            | Type                         | Description                                      |
| ---------------------| -----------------------------| -------------------------------------------------|
| `cgroup_path`        | `const char*`                | Cgroup path (max 256 bytes)                      |
| `limits`             | `struct claw_cgroup_limits*` | Resource limits                                  |
| `limits->memory_max` | `uint64_t`                   | Memory limit in bytes (0 = unlimited, max 16GB)  |
| `limits->cpu_max`    | `uint64_t`                   | CPU quota (e.g., 100000 for 10% of 1 CPU)        |
| `limits->cpu_period` | `uint64_t`                   | CPU period in microseconds (default: 1000000)    |
| `limits->pids_max`   | `uint64_t`                   | Maximum number of PIDs (0 = unlimited, max 1024) |
| `limits->io_max`     | `uint64_t`                   | I/O bandwidth limit in bytes/sec (0 = unlimited) |

**Return Value:**
| Value | Description                     |
| ------| --------------------------------|
| `0`   | Success                         |
| `1`   | EAGAIN - Resource limit reached |
| `2`   | EIO - I/O error                 |
| `3`   | ENOENT - Cgroup not found       |
| `4`   | EPERM - Permission denied       |
| `5`   | EPROTO - Invalid limits         |
| `7`   | EINTERNAL - Internal error      |

**Security Requirements:**
- **Capability**: `CAP_CLAWSEC_CGROUP`
- **cgroup**: Must be member of parent cgroup
- **AppArmor**: Limits must be within allowed ranges
- **eBPF Monitoring**: All cgroup changes logged via eBPF LSM hook

**Performance Characteristics:**
- **Blocking**: No (immediate)
- **Timeout**: None
- **Latency**: ~100Î¼s (cgroup update)

**Example (C):**
```c
#include "clawos_api.h"

struct claw_cgroup_limits limits = {
    .memory_max = 64 * 1024 * 1024,  // 64MB
    .cpu_max = 100000,                // 10% of 1 CPU
    .cpu_period = 1000000,            // 1 second period
    .pids_max = 16,                   // Max 16 processes
    .io_max = 0                       // Unlimited I/O
};

int ret = claw_cgroup_set("/sys/fs/cgroup/clawos/tools/mytool", &limits);
if (ret != CLAW_SUCCESS) {
    claw_log_write(LOG_ERROR, "Failed to set cgroup limits: error %d", ret);
    return ret;
}

printf("cgroup limits set successfully\n");
```

**Example (Rust):**
```rust
use clawos::security;

let limits = security::CgroupLimits {
    memory_max: 64 * 1024 * 1024,  // 64MB
    cpu_max: 100000,                // 10% of 1 CPU
    cpu_period: 1000000,            // 1 second period
    pids_max: 16,                   // Max 16 processes
    io_max: 0,                      // Unlimited I/O
};

security::claw_cgroup_set("/sys/fs/cgroup/clawos/tools/mytool", &limits)?;

println!("cgroup limits set successfully");
```

---

#### claw_namespace_enter

Enter a Linux namespace for isolation.

**Signature:**
```c
int claw_namespace_enter(
    const char *ns_type,           // Namespace type ("user", "pid", "net", "mnt", "ipc", "uts", "cgroup")
    int ns_fd                      // Namespace file descriptor (from /proc/<pid>/ns/<type>)
);
```

**Parameters:**
| Parameter | Type          | Description                                              |
| ----------| --------------| ---------------------------------------------------------|
| `ns_type` | `const char*` | Namespace type (max 16 bytes)                            |
| `ns_fd`   | `int`         | Namespace file descriptor (from `/proc/<pid>/ns/<type>`) |

**Return Value:**
| Value | Description                           |
| ------| --------------------------------------|
| `0`   | Success                               |
| `2`   | EIO - I/O error                       |
| `3`   | ENOENT - Namespace not found          |
| `4`   | EPERM - Permission denied             |
| `5`   | EPROTO - Invalid namespace type or fd |
| `7`   | EINTERNAL - Internal error            |

**Security Requirements:**
- **Capability**: `CAP_CLAWSEC_NAMESPACE`
- **cgroup**: Must be member of tool's cgroup
- **AppArmor**: Namespace must be in allowed list
- **eBPF Monitoring**: All namespace enters logged via eBPF LSM hook

**Performance Characteristics:**
- **Blocking**: No (immediate)
- **Timeout**: None
- **Latency**: ~10Î¼s (namespace switch)

**Example (C):**
```c
#include "clawos_api.h"
#include <fcntl.h>

// Open user namespace file descriptor
int ns_fd = open("/proc/1234/ns/user", O_RDONLY);
if (ns_fd < 0) {
    claw_log_write(LOG_ERROR, "Failed to open namespace fd");
    return -1;
}

int ret = claw_namespace_enter("user", ns_fd);
if (ret != CLAW_SUCCESS) {
    claw_log_write(LOG_ERROR, "Failed to enter namespace: error %d", ret);
    close(ns_fd);
    return ret;
}

close(ns_fd);
printf("Entered user namespace successfully\n");
```

**Example (Rust):**
```rust
use clawos::security;
use std::os::unix::io::AsRawFd;

// Open user namespace file descriptor
let ns_file = std::fs::File::open("/proc/1234/ns/user")?;
let ns_fd = ns_file.as_raw_fd();

security::claw_namespace_enter("user", ns_fd)?;

println!("Entered user namespace successfully");
```

---

### Monitoring Syscalls

Monitoring syscalls provide metrics, logging, and event subscription capabilities for observability.

#### claw_metric_query

Query system or tool metrics.

**Signature:**
```c
struct claw_metric_value {
    const char *name;             // Metric name
    const char *value;            // Metric value (as string)
    uint64_t timestamp_ns;        // Timestamp (Unix epoch, nanoseconds)
};

int claw_metric_query(
    const char *metric_name,      // Metric name (e.g., "cpu.usage", "memory.usage")
    struct claw_metric_value *value_out  // Output: metric value
);
```

**Parameters:**
| Parameter     | Type                        | Description                             |
| --------------| ----------------------------| ----------------------------------------|
| `metric_name` | `const char*`               | Metric name (max 256 bytes)             |
| `value_out`   | `struct claw_metric_value*` | Output: metric value (valid on success) |

**Return Value:**
| Value | Description                           |
| ------| --------------------------------------|
| `0`   | Success (metric value in `value_out`) |
| `2`   | EIO - I/O error                       |
| `3`   | ENOENT - Metric not found             |
| `4`   | EPERM - Permission denied             |
| `5`   | EPROTO - Invalid metric name          |
| `7`   | EINTERNAL - Internal error            |

**Security Requirements:**
- **Capability**: `CAP_CLAWMON_METRIC`
- **cgroup**: Must be member of tool's cgroup
- **AppArmor**: Metric must be in allowed list
- **eBPF Monitoring**: All metric queries logged via eBPF LSM hook

**Performance Characteristics:**
- **Blocking**: No (immediate)
- **Timeout**: None
- **Latency**: ~10Î¼s (cached), ~1ms (uncached)

**Available Metrics:**

| Metric Name        | Description                     | Type   |
| -------------------| --------------------------------| -------|
| `cpu.usage`        | CPU usage in nanoseconds        | uint64 |
| `cpu.percent`      | CPU usage percentage (0-100)    | float  |
| `memory.usage`     | Memory usage in bytes           | uint64 |
| `memory.limit`     | Memory limit in bytes           | uint64 |
| `memory.percent`   | Memory usage percentage (0-100) | float  |
| `pids.count`       | Number of PIDs in cgroup        | uint64 |
| `pids.limit`       | PID limit                       | uint64 |
| `io.read_bytes`    | Bytes read                      | uint64 |
| `io.write_bytes`   | Bytes written                   | uint64 |
| `network.rx_bytes` | Network bytes received          | uint64 |
| `network.tx_bytes` | Network bytes transmitted       | uint64 |

**Example (C):**
```c
#include "clawos_api.h"

struct claw_metric_value value;
int ret = claw_metric_query("cpu.usage", &value);
if (ret != CLAW_SUCCESS) {
    claw_log_write(LOG_ERROR, "Failed to query metric: error %d", ret);
    return ret;
}

printf("Metric: %s\n", value.name);
printf("Value: %s\n", value.value);
printf("Timestamp: %llu\n", (unsigned long long)value.timestamp_ns);
```

**Example (Rust):**
```rust
use clawos::monitoring;

let value = monitoring::claw_metric_query("cpu.usage")?;

println!("Metric: {}", value.name);
println!("Value: {}", value.value);
println!("Timestamp: {}", value.timestamp_ns);
```

---

#### claw_log_write

Write a log message to the ClawOS logging system.

**Signature:**
```c
enum claw_log_level {
    LOG_DEBUG = 0,
    LOG_INFO = 1,
    LOG_WARN = 2,
    LOG_ERROR = 3,
};

int claw_log_write(
    enum claw_log_level level,    // Log level
    const char *message,          // Log message
    ...                           // Optional format arguments (printf-style)
);
```

**Parameters:**
| Parameter | Type                  | Description                                              |
| ----------| ----------------------| ---------------------------------------------------------|
| `level`   | `enum claw_log_level` | Log level (DEBUG=0, INFO=1, WARN=2, ERROR=3)             |
| `message` | `const char*`         | Log message (max 4096 bytes, printf-style format string) |
| `...`     | `...`                 | Optional format arguments (printf-style)                 |

**Return Value:**
| Value | Description                |
| ------| ---------------------------|
| `0`   | Success                    |
| `2`   | EIO - I/O error            |
| `4`   | EPERM - Permission denied  |
| `5`   | EPROTO - Invalid message   |
| `7`   | EINTERNAL - Internal error |

**Security Requirements:**
- **Capability**: `CAP_CLAWMON_LOG`
- **cgroup**: Must be member of tool's cgroup
- **AppArmor**: Log level must be within allowed range
- **eBPF Monitoring**: All log writes logged via eBPF LSM hook

**Performance Characteristics:**
- **Blocking**: No (async logging)
- **Timeout**: None
- **Latency**: ~10Î¼s (async write)

**Example (C):**
```c
#include "clawos_api.h"

claw_log_write(LOG_DEBUG, "Starting tool execution");
claw_log_write(LOG_INFO, "Processing file: %s", filename);
claw_log_write(LOG_WARN, "Resource usage high: %d%%", usage);
claw_log_write(LOG_ERROR, "Failed to open file: %s", error);
```

**Example (Rust):**
```rust
use clawos::monitoring;

monitoring::claw_log_write(monitoring::LOG_DEBUG, "Starting tool execution");
monitoring::claw_log_write(monitoring::LOG_INFO, &format!("Processing file: {}", filename));
monitoring::claw_log_write(monitoring::LOG_WARN, &format!("Resource usage high: {}%", usage));
monitoring::claw_log_write(monitoring::LOG_ERROR, &format!("Failed to open file: {}", error));
```

---

#### claw_event_subscribe

Subscribe to eBPF events for monitoring.

**Signature:**
```c
struct claw_event_subscription {
    const char *event_type;       // Event type (e.g., "SYSCALL_ANOMALY", "THRESHOLD_EXCEEDED")
    const char *filter;           // Event filter (JSON format, optional)
    uint32_t flags;               // Subscription flags (bitmask)
};

int claw_event_subscribe(
    const struct claw_event_subscription *sub,  // Subscription details
    int *event_fd_out          // Output: event file descriptor (for reading events)
);
```

**Parameters:**
| Parameter         | Type                              | Description                                          |
| ------------------| ----------------------------------| -----------------------------------------------------|
| `sub`             | `struct claw_event_subscription*` | Subscription details                                 |
| `sub->event_type` | `const char*`                     | Event type (max 64 bytes)                            |
| `sub->filter`     | `const char*`                     | Event filter (JSON format, optional, max 1024 bytes) |
| `sub->flags`      | `uint32_t`                        | Subscription flags (bitmask: 0x01=NON_BLOCKING)      |
| `event_fd_out`    | `int*`                            | Output: event file descriptor (for reading events)   |

**Return Value:**
| Value | Description                           |
| ------| --------------------------------------|
| `0`   | Success (event fd in `event_fd_out`)  |
| `1`   | EAGAIN - Too many subscriptions       |
| `2`   | EIO - I/O error                       |
| `4`   | EPERM - Permission denied             |
| `5`   | EPROTO - Invalid event type or filter |
| `7`   | EINTERNAL - Internal error            |

**Security Requirements:**
- **Capability**: `CAP_CLAWMON_EVENT`
- **cgroup**: Must be member of tool's cgroup
- **AppArmor**: Event type must be in allowed list
- **eBPF Monitoring**: All subscriptions logged via eBPF LSM hook

**Performance Characteristics:**
- **Blocking**: No (immediate)
- **Timeout**: None
- **Latency**: ~100Î¼s (subscription setup)
- **Event Delivery**: ~10Î¼s per event

**Available Event Types:**

| Event Type           | Description                 | Filter Fields          |
| ---------------------| ----------------------------| -----------------------|
| `SYSCALL_ANOMALY`    | Syscall anomaly detected    | pid, syscall, severity |
| `THRESHOLD_EXCEEDED` | Resource threshold exceeded | metric_name, threshold |
| `POLICY_VIOLATION`   | Security policy violation   | policy_id, severity    |
| `PROCESS_EXIT`       | Process exited              | pid, exit_code         |
| `FILE_ACCESS`        | File accessed               | path, operation        |

**Example (C):**
```c
#include "clawos_api.h"

struct claw_event_subscription sub = {
    .event_type = "SYSCALL_ANOMALY",
    .filter = "{\"severity\": \"high\"}",  // Only high severity anomalies
    .flags = 0
};

int event_fd;
int ret = claw_event_subscribe(&sub, &event_fd);
if (ret != CLAW_SUCCESS) {
    claw_log_write(LOG_ERROR, "Failed to subscribe to events: error %d", ret);
    return ret;
}

printf("Subscribed to SYSCALL_ANOMALY events (event_fd=%d)\n", event_fd);

// Read events from event_fd...
```

**Example (Rust):**
```rust
use clawos::monitoring;

let sub = monitoring::EventSubscription {
    event_type: "SYSCALL_ANOMALY",
    filter: Some(r#"{"severity": "high"}"#),  // Only high severity anomalies
    flags: 0,
};

let event_fd = monitoring::claw_event_subscribe(&sub)?;

println!("Subscribed to SYSCALL_ANOMALY events (event_fd={})", event_fd);

// Read events from event_fd...
```

---

## WIT Bindings

### Overview

ClawOS public API syscalls are exposed to WASM tools via WIT (WebAssembly Interface Types) bindings. The WIT interface is defined in P1.1 and maps directly to the syscall interface defined in this specification.

### WIT Interface Mapping

| Syscall Category | WIT Interface              | Example Functions                                |
| -----------------| ---------------------------| -------------------------------------------------|
| File System      | `clawos:kernel/filesystem` | `open`, `read`, `write`, `close`, `stat`         |
| Network          | `clawos:kernel/network`    | `connect`, `send`, `recv`, `close`               |
| Process          | `clawos:kernel/process`    | `spawn`, `wait`, `kill`                          |
| Memory           | `clawos:kernel/memory`     | `allocate`, `free`                               |
| Security         | `clawos:kernel/security`   | `seccomp_apply`, `cgroup_set`, `namespace_enter` |
| Monitoring       | `clawos:kernel/monitoring` | `metric_query`, `log_write`, `event_subscribe`   |

### WIT Function Signature Example

```wit
/// ClawOS File System Interface
interface filesystem {
    /// Open a file in ClawFS
    open: func(
        path: string,
        flags: u32,
        mode: u32
    ) -> result<file-descriptor>

    /// Read data from a file
    read: func(
        fd: file-descriptor,
        buffer: list<u8>,
        max-bytes: u32
    ) -> result<u32>

    /// Write data to a file
    write: func(
        fd: file-descriptor,
        data: list<u8>
    ) -> result<u32>

    /// Close a file
    close: func(
        fd: file-descriptor
    ) -> result<_>

    /// Get file status
    stat: func(
        path: string
    ) -> result<file-stat>
}
```

### WASM Tool Integration

WASM tools import the ClawOS WIT interface and call host functions:

```rust
// WASM tool (Rust)
use clawos::kernel::filesystem;

#[export_name = "tool_main"]
pub extern "C" fn tool_main() -> i32 {
    // Open a file
    let fd = match filesystem::open(
        "/clawfs/tools/mytool/config.json",
        0x01,  // O_RDONLY
        0
    ) {
        Ok(fd) => fd,
        Err(e) => {
            eprintln!("Failed to open file: {:?}", e);
            return 1;
        }
    };

    // Read from file
    let mut buffer = vec![0u8; 4096];
    let bytes_read = match fd.read(&mut buffer, 4096) {
        Ok(n) => n,
        Err(e) => {
            eprintln!("Failed to read file: {:?}", e);
            return 1;
        }
    };

    println!("Read {} bytes", bytes_read);

    // Close file
    let _ = fd.close();

    0
}
```

### Error Code Mapping (WIT â†’ Syscall)

WIT error codes map 1:1 to syscall error codes:

| WIT Error   | Syscall Error | Description                      |
| ------------| --------------| ---------------------------------|
| `success`   | 0             | Operation completed successfully |
| `eagain`    | 1             | Operation would block            |
| `eio`       | 2             | I/O error                        |
| `enoent`    | 3             | Entity not found                 |
| `eperm`     | 4             | Permission denied                |
| `eproto`    | 5             | Protocol error                   |
| `etimeout`  | 6             | Operation timeout                |
| `einternal` | 7             | Internal error                   |
| `epanic`    | 8             | Unrecoverable error              |

---

## Usage Examples

### Complete Example: File Tool (C)

```c
#include "clawos_api.h"
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv) {
    if (argc < 2) {
        claw_log_write(LOG_ERROR, "Usage: %s <file>", argv[0]);
        return 1;
    }

    const char *filename = argv[1];

    // Open file
    int fd;
    int ret = claw_fs_open(filename, O_RDONLY, 0, &fd);
    if (ret != CLAW_SUCCESS) {
        claw_log_write(LOG_ERROR, "Failed to open file %s: error %d", filename, ret);
        return ret;
    }

    // Get file status
    struct claw_fs_stat stat;
    ret = claw_fs_stat(filename, &stat);
    if (ret != CLAW_SUCCESS) {
        claw_log_write(LOG_ERROR, "Failed to stat file %s: error %d", filename, ret);
        claw_fs_close(fd);
        return ret;
    }

    printf("File: %s\n", filename);
    printf("Size: %llu bytes\n", (unsigned long long)stat.size);

    // Read file content
    char *buffer = malloc(stat.size + 1);
    if (!buffer) {
        claw_log_write(LOG_ERROR, "Failed to allocate memory");
        claw_fs_close(fd);
        return CLAW_EINTERNAL;
    }

    size_t bytes_read;
    ret = claw_fs_read(fd, buffer, stat.size, &bytes_read);
    if (ret != CLAW_SUCCESS) {
        claw_log_write(LOG_ERROR, "Failed to read file %s: error %d", filename, ret);
        free(buffer);
        claw_fs_close(fd);
        return ret;
    }

    buffer[bytes_read] = '\0';
    printf("Content:\n%s\n", buffer);

    // Cleanup
    free(buffer);
    claw_fs_close(fd);

    return 0;
}
```

### Complete Example: Network Tool (Rust)

```rust
use clawos::{fs, net, monitoring};
use std::io::{self, Read, Write};

fn main() -> Result<(), Box<dyn std::error::Error>> {
    monitoring::claw_log_write(monitoring::LOG_INFO, "Starting network tool");

    // Read configuration
    let config = fs::claw_fs_open("/clawfs/tools/nettool/config.json", libc::O_RDONLY, 0)?;
    let mut config_data = Vec::new();
    let mut buf = [0u8; 4096];
    loop {
        let n = config.read(&mut buf, 4096)?;
        if n == 0 {
            break;
        }
        config_data.extend_from_slice(&buf[..n]);
    }
    drop(config);

    // Parse configuration
    let config: serde_json::Value = serde_json::from_slice(&config_data)?;
    let host = config["host"].as_str().unwrap_or("localhost");
    let port = config["port"].as_u64().unwrap_or(5432) as u16;

    monitoring::claw_log_write(
        monitoring::LOG_INFO,
        &format!("Connecting to {}:{}", host, port)
    );

    // Connect to PostgreSQL
    let sock = net::claw_net_connect(host, port, 1)?;

    // Send query
    let query = b"SELECT version();";
    let bytes_sent = net::claw_net_send(sock, query)?;
    monitoring::claw_log_write(
        monitoring::LOG_DEBUG,
        &format!("Sent {} bytes", bytes_sent)
    );

    // Receive response
    let mut buffer = vec![0u8; 4096];
    let bytes_recv = net::claw_net_recv(sock, &mut buffer)?;
    monitoring::claw_log_write(
        monitoring::LOG_DEBUG,
        &format!("Received {} bytes", bytes_recv)
    );

    // Print response
    let response = String::from_utf8_lossy(&buffer[..bytes_recv]);
    println!("Response: {}", response);

    // Close socket
    net::claw_net_close(sock)?;

    monitoring::claw_log_write(monitoring::LOG_INFO, "Network tool completed");

    Ok(())
}
```

### Complete Example: Process Manager (C)

```c
#include "clawos_api.h"
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(int argc, char **argv) {
    if (argc < 2) {
        claw_log_write(LOG_ERROR, "Usage: %s <command> [args...]", argv[0]);
        return 1;
    }

    // Set cgroup limits
    struct claw_cgroup_limits limits = {
        .memory_max = 128 * 1024 * 1024,  // 128MB
        .cpu_max = 200000,                // 20% of 1 CPU
        .cpu_period = 1000000,
        .pids_max = 32,
        .io_max = 0
    };

    int ret = claw_cgroup_set("/sys/fs/cgroup/clawos/tools/procman", &limits);
    if (ret != CLAW_SUCCESS) {
        claw_log_write(LOG_ERROR, "Failed to set cgroup limits: error %d", ret);
        return ret;
    }

    // Spawn process
    struct claw_proc_spawn_args args = {
        .executable = argv[1],
        .argv = &argv[1],
        .envp = NULL,
        .working_dir = NULL,
        .flags = 0
    };

    int pid;
    ret = claw_proc_spawn(&args, &pid);
    if (ret != CLAW_SUCCESS) {
        claw_log_write(LOG_ERROR, "Failed to spawn process: error %d", ret);
        return ret;
    }

    claw_log_write(LOG_INFO, "Spawned process with PID %d", pid);

    // Wait for process
    struct claw_proc_wait_status status;
    ret = claw_proc_wait(pid, 0, &status);
    if (ret != CLAW_SUCCESS) {
        claw_log_write(LOG_ERROR, "Failed to wait for process: error %d", ret);
        return ret;
    }

    printf("Process %d exited with code %d\n", status.pid, status.exit_code);
    printf("Runtime: %llu ns\n", (unsigned long long)status.runtime_ns);

    return 0;
}
```

### Complete Example: Monitoring Tool (Rust)

```rust
use clawos::monitoring;
use std::io::{self, BufRead, BufReader};

fn main() -> Result<(), Box<dyn std::error::Error>> {
    monitoring::claw_log_write(monitoring::LOG_INFO, "Starting monitoring tool");

    // Subscribe to syscall anomaly events
    let sub = monitoring::EventSubscription {
        event_type: "SYSCALL_ANOMALY",
        filter: Some(r#"{"severity": "high"}"#),
        flags: 0,
    };

    let event_fd = monitoring::claw_event_subscribe(&sub)?;
    monitoring::claw_log_write(
        monitoring::LOG_INFO,
        &format!("Subscribed to events (event_fd={})", event_fd)
    );

    // Query metrics
    let cpu_usage = monitoring::claw_metric_query("cpu.usage")?;
    let memory_usage = monitoring::claw_metric_query("memory.usage")?;

    println!("CPU Usage: {}", cpu_usage.value);
    println!("Memory Usage: {}", memory_usage.value);

    // Read events
    let event_file = unsafe { std::fs::File::from_raw_fd(event_fd) };
    let reader = BufReader::new(event_file);

    for line in reader.lines() {
        let event_json = line?;
        println!("Event: {}", event_json);

        // Parse event
        let event: serde_json::Value = serde_json::from_str(&event_json)?;

        if let Some(event_type) = event["event_type"].as_str() {
            monitoring::claw_log_write(
                monitoring::LOG_WARN,
                &format!("Received event: {}", event_type)
            );
        }
    }

    Ok(())
}
```

---

## Appendices

### Appendix A: Syscall Summary Table

| Category    | Syscall                | Capability              | Blocking | Timeout | Latency |
| ------------| -----------------------| ------------------------| ---------| --------| --------|
| File System | `claw_fs_open`         | `CAP_CLAWFS_READ/WRITE` | Yes      | 5s      | ~100Î¼s  |
| File System | `claw_fs_read`         | `CAP_CLAWFS_READ`       | Yes      | 5s      | ~50Î¼s   |
| File System | `claw_fs_write`        | `CAP_CLAWFS_WRITE`      | Yes      | 5s      | ~50Î¼s   |
| File System | `claw_fs_close`        | None                    | No       | None    | ~10Î¼s   |
| File System | `claw_fs_stat`         | `CAP_CLAWFS_READ`       | No       | None    | ~10Î¼s   |
| Network     | `claw_net_connect`     | `CAP_CLAWNET_CONNECT`   | Yes      | 10s     | ~1ms    |
| Network     | `claw_net_send`        | `CAP_CLAWNET_SEND`      | Yes      | 5s      | ~10Î¼s   |
| Network     | `claw_net_recv`        | `CAP_CLAWNET_RECV`      | Yes      | 5s      | ~10Î¼s   |
| Network     | `claw_net_close`       | None                    | No       | None    | ~10Î¼s   |
| Process     | `claw_proc_spawn`      | `CAP_CLAWPROC_SPAWN`    | Yes      | 30s     | ~10ms   |
| Process     | `claw_proc_wait`       | `CAP_CLAWPROC_WAIT`     | Yes*     | None    | ~10Î¼s   |
| Process     | `claw_proc_kill`       | `CAP_CLAWPROC_KILL`     | No       | None    | ~10Î¼s   |
| Memory      | `claw_mem_alloc`       | `CAP_CLAWMEM_ALLOC`     | No       | None    | ~1Î¼s    |
| Memory      | `claw_mem_free`        | `CAP_CLAWMEM_FREE`      | No       | None    | ~1Î¼s    |
| Security    | `claw_seccomp_apply`   | `CAP_CLAWSEC_SECCOMP`   | No       | None    | ~100Î¼s  |
| Security    | `claw_cgroup_set`      | `CAP_CLAWSEC_CGROUP`    | No       | None    | ~100Î¼s  |
| Security    | `claw_namespace_enter` | `CAP_CLAWSEC_NAMESPACE` | No       | None    | ~10Î¼s   |
| Monitoring  | `claw_metric_query`    | `CAP_CLAWMON_METRIC`    | No       | None    | ~10Î¼s   |
| Monitoring  | `claw_log_write`       | `CAP_CLAWMON_LOG`       | No       | None    | ~10Î¼s   |
| Monitoring  | `claw_event_subscribe` | `CAP_CLAWMON_EVENT`     | No       | None    | ~100Î¼s  |

* `claw_proc_wait` is blocking unless `WNOHANG` option is set.

### Appendix B: Capability Reference

| Capability              | Description               | Required By                                           |
| ------------------------| --------------------------| ------------------------------------------------------|
| `CAP_CLAWFS_READ`       | Read file system access   | `claw_fs_open` (read), `claw_fs_read`, `claw_fs_stat` |
| `CAP_CLAWFS_WRITE`      | Write file system access  | `claw_fs_open` (write), `claw_fs_write`               |
| `CAP_CLAWNET_CONNECT`   | Network connection access | `claw_net_connect`                                    |
| `CAP_CLAWNET_SEND`      | Network send access       | `claw_net_send`                                       |
| `CAP_CLAWNET_RECV`      | Network receive access    | `claw_net_recv`                                       |
| `CAP_CLAWPROC_SPAWN`    | Process spawn access      | `claw_proc_spawn`                                     |
| `CAP_CLAWPROC_WAIT`     | Process wait access       | `claw_proc_wait`                                      |
| `CAP_CLAWPROC_KILL`     | Process kill access       | `claw_proc_kill`                                      |
| `CAP_CLAWMEM_ALLOC`     | Memory allocation access  | `claw_mem_alloc`                                      |
| `CAP_CLAWMEM_FREE`      | Memory free access        | `claw_mem_free`                                       |
| `CAP_CLAWSEC_SECCOMP`   | seccomp filter access     | `claw_seccomp_apply`                                  |
| `CAP_CLAWSEC_CGROUP`    | cgroup management access  | `claw_cgroup_set`                                     |
| `CAP_CLAWSEC_NAMESPACE` | namespace access          | `claw_namespace_enter`                                |
| `CAP_CLAWMON_METRIC`    | Metric query access       | `claw_metric_query`                                   |
| `CAP_CLAWMON_LOG`       | Log write access          | `claw_log_write`                                      |
| `CAP_CLAWMON_EVENT`     | Event subscription access | `claw_event_subscribe`                                |

### Appendix C: Default cgroup Limits

| Resource | Default Limit             | Maximum Limit |
| ---------| --------------------------| --------------|
| Memory   | 64 MB                     | 16 GB         |
| CPU      | 10% (100000/1000000)      | 100%          |
| PIDs     | 16                        | 1024          |
| I/O      | Unlimited                 | Unlimited     |
| Network  | PostgreSQL port 5432 only | Configurable  |

### Appendix D: Version History

| Version | Date       | Changes                                                                                      |
| --------| -----------| ---------------------------------------------------------------------------------------------|
| 1.0.0   | 2026-02-24 | Initial release - Define all syscall categories, error code mapping, API versioning strategy |

---

## References

- **P1.1:** WIT Interface Specification Book (WASM â†” Kernel ABI)
- **P1.2:** seccomp Syscall Whitelist JSON Schema
- **P1.3:** eBPF Event Struct Format
- **P1.4:** ClawFS Filesystem Specification
- **P1.5:** cgroup v2 Resource Quota Standard Values
- **P1.6:** AppArmor Profile Rule Language Spec
- **P1.7:** Inter-Agent IPC Protocol Specification
- **Linux Kernel 6.6 LTS:** https://www.kernel.org/
- **WIT Specification:** https://github.com/WebAssembly/component-model
- **Semantic Versioning 2.0.0:** https://semver.org/

---

**END OF SPECIFICATION**
