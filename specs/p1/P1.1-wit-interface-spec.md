# WIT Interface Specification Book (WASM ↔ Kernel ABI)

**Document ID:** P1.1
**Version:** 1.0.0
**Status:** FROZEN
**Created:** 2026-02-24
**Created By:** WASM Agent
**SHA256 Signature:** PLACEHOLDER_SHA256_SIGNATURE

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Version Information](#version-information)
3. [Architecture Overview](#architecture-overview)
4. [Security Boundary](#security-boundary)
5. [WIT Interface Definitions](#wit-interface-definitions)
6. [Error Codes](#error-codes)
7. [Resource Types](#resource-types)
8. [Host Functions](#host-functions)
9. [Migration Strategy](#migration-strategy)
10. [JSON Schema Validation](#json-schema-validation)
11. [Usage Examples](#usage-examples)
12. [Appendices](#appendices)

---

## Executive Summary

This document defines the WebAssembly Interface Types (WIT) specification for ClawOS v1.0, establishing the ABI (Application Binary Interface) between WASM components and the Linux Kernel 6.6 LTS. The specification enables secure, sandboxed execution of AI agent tools while maintaining strict isolation through a multi-layer security architecture.

### Key Design Principles

1. **Zero-Trust Security**: All WASM components are untrusted by default
2. **Capability-Based Access**: Resources are accessed through handles, not direct memory
3. **Explicit Error Handling**: All operations return explicit error codes
4. **Memory Safety**: WASM sandbox prevents direct kernel memory access
5. **Auditability**: All operations are logged via eBPF monitoring

### Scope

This specification covers:
- WASM host functions for kernel ABI calls (syscall, fs, network, cgroup operations)
- WIT resource types for kernel objects (file descriptors, memory regions, device handles)
- Error code definitions with explicit numeric mappings
- Function signatures for all kernel interactions
- Security boundary documentation
- Migration strategy from IronClaw's original WIT interface

---

## Version Information

### WIT Specification Version

```
WIT Version: 2.0.0
Component Model: wasmtime 27+
ABI: wasm32-unknown-unknown
```

### Compatibility Matrix

| Component       | Version | Notes                   |
| --------------- | ------- | ----------------------- |
| WIT Spec        | 2.0.0   | Current version         |
| wasmtime        | 27+     | Minimum required        |
| cargo-component | 0.20+   | Packaging tool          |
| Linux Kernel    | 6.6 LTS | Target kernel           |
| Rust            | 1.85+   | Implementation language |

### Version History

| Version | Date       | Changes                                      |
| ------- | ---------- | -------------------------------------------- |
| 2.0.0   | 2026-02-24 | Initial ClawOS v1.0 specification            |
| 1.0.0   | 2025-XX-XX | Original IronClaw WIT interface (deprecated) |

---

## Architecture Overview

### 7-Layer Security Model

```
┌─────────────────────────────────────────────────────────────┐
│ Layer 7: ClawOS Shell (AI-native CLI)                       │
├─────────────────────────────────────────────────────────────┤
│ Layer 6: Agent Runtime (IronClaw Agent Loop)                │
├─────────────────────────────────────────────────────────────┤
│ Layer 5: WASM Kernel Bridge ← THIS SPECIFICATION            │
│         ┌─────────────────────────────────────────────┐     │
│         │ WASM Sandbox → Userspace Daemon → Kernel ABI│     │
│         └─────────────────────────────────────────────┘     │
├─────────────────────────────────────────────────────────────┤
│ Layer 4: eBPF AI Monitor (Kernel-level monitoring)          │
├─────────────────────────────────────────────────────────────┤
│ Layer 3: ClawFS (AI-aware FS: vector index + encryption)    │
├─────────────────────────────────────────────────────────────┤
│ Layer 2: Hardened Kernel (Linux 6.6 LTS + seccomp + LSM)    │
├─────────────────────────────────────────────────────────────┤
│ Layer 1: Hardware Trust (TPM 2.0 + Secure Boot)             │
└─────────────────────────────────────────────────────────────┘
```

### WASM Kernel Bridge Architecture

```
┌─────────────────────────────────────────────────────────────┐
│ WASM Component (Tool)                                       │
│ - Memory: 64MB (configurable)                               │
│ - CPU: 1 vCPU (cgroup limited)                              │
│ - Network: Proxied through host functions                   │
└────────────────────┬────────────────────────────────────────┘
                     │ WIT Interface (wasm32 ABI)
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ Userspace Daemon (clawos-wasm-bridge)                       │
│ - wasmtime runtime                                          │
│ - WIT host function implementations                         │
│ - seccomp filter applied                                    │
│ - cgroup v2 resource limits                                 │
└────────────────────┬────────────────────────────────────────┘
                     │ POSIX Syscalls
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ Linux Kernel 6.6 LTS                                        │
│ - eBPF LSM hooks (monitoring)                               │
│ - AppArmor profiles (enforcement)                           │
│ - Namespace isolation (user, pid, net, mnt)                 │
└─────────────────────────────────────────────────────────────┘
```

### Critical Design Decision: Userspace Daemon

**HIGH PRIORITY CONFLICT RESOLUTION:**

**Conflict:** WASM memory safety model in kernel space conflicts with Rust ownership semantics.

**Resolution:** Use eBPF CO-RE + userspace WASM daemon. Do NOT force wasmtime into kernel space.

**Rationale:**
1. **Memory Safety**: WASM runtime in userspace maintains memory isolation
2. **Security**: seccomp filter limits daemon's syscall access
3. **Monitoring**: eBPF LSM hooks monitor all daemon operations
4. **Stability**: Kernel space crashes are avoided
5. **Maintainability**: Userspace code is easier to debug and update

**Architecture:**
```
WASM Component → Userspace Daemon (wasmtime) → Kernel Syscalls
                      ↑
                      │ eBPF LSM Monitoring
                      │ AppArmor Enforcement
                      │ cgroup v2 Limits
```

---

## Security Boundary

### Trust Zones

```
┌─────────────────────────────────────────────────────────────┐
│ UNTRUSTED ZONE                                              │
│ - WASM Components (Tools)                                   │
│ - No direct kernel access                                   │
│ - Memory sandbox enforced                                   │
└────────────────────┬────────────────────────────────────────┘
                     │ WIT Interface (Controlled)
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ SEMI-TRUSTED ZONE                                           │
│ - Userspace Daemon (clawos-wasm-bridge)                     │
│ - seccomp filter applied                                    │
│ - cgroup v2 resource limits                                 │
│ - AppArmor profile enforced                                 │
└────────────────────┬────────────────────────────────────────┘
                     │ Monitored Syscalls
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ TRUSTED ZONE                                                │
│ - Linux Kernel 6.6 LTS                                      │
│ - eBPF LSM hooks                                            │
│ - TPM 2.0 + Secure Boot                                     │
└─────────────────────────────────────────────────────────────┘
```

### Security Controls

#### 1. WASM Sandbox (Layer 5a)
- **Memory Isolation**: 64MB heap limit (configurable per tool)
- **CPU Limit**: 1 vCPU via cgroup v2
- **No Direct Syscalls**: All kernel access via WIT host functions
- **Capability-Based Access**: Resources accessed via handles only

#### 2. seccomp-BPF Filter (Layer 5b)
Applied to userspace daemon:
```rust
// Allowed syscalls for clawos-wasm-bridge
let allowed = [
    // Memory management
    "mmap", "munmap", "mprotect", "brk", "madvise",
    // File I/O
    "read", "write", "open", "openat", "close", "stat", "fstat", "lstat",
    // Process management
    "exit", "exit_group", "getpid", "gettid", "futex", "clone", "clone3",
    // Network (proxied)
    "socket", "connect", "recv", "send", "poll", "epoll_create1",
    "epoll_ctl", "epoll_wait",
    // Time
    "clock_gettime", "clock_nanosleep",
    // Signals
    "rt_sigaction", "rt_sigprocmask", "rt_sigreturn",
    // Misc
    "prctl", "getrandom", "eventfd2", "pipe2",
    // eBPF (for monitoring)
    "bpf", "perf_event_open",
];
```

#### 3. cgroup v2 Resource Limits (Layer 5c)
```ini
# /sys/fs/cgroup/clawos/wasm-daemon/
memory.max = 256M
cpu.max = 100000 1000000  # 10% of 1 CPU
pids.max = 64
```

#### 4. AppArmor Profile (Layer 5d)
```
#include <tunables/global>

profile clawos-wasm-bridge flags=(attach_disconnected) {
  #include <abstractions/base>

  # Allow WASM runtime operations
  capability dac_override,
  capability dac_read_search,

  # Allow file access to ClawFS
  /clawfs/** rw,

  # Allow network to PostgreSQL (port 5432)
  network inet stream,
  network inet6 stream,

  # Deny everything else
  deny /root/** rw,
  deny /etc/shadow rw,
  deny /etc/passwd rw,
}
```

#### 5. eBPF LSM Monitoring (Layer 4)
- **File Operations**: All file open/read/write monitored
- **Network Operations**: All socket/connect monitored
- **Process Operations**: All execve/clone monitored
- **Anomaly Detection**: Suspicious patterns trigger alerts

### Threat Model

| Threat                         | Mitigation                        |
| ------------------------------ | --------------------------------- |
| WASM component escapes sandbox | Memory isolation + seccomp filter |
| Userspace daemon compromised   | AppArmor profile + cgroup limits  |
| Kernel syscall abuse           | eBPF LSM hooks + audit logging    |
| Resource exhaustion            | cgroup v2 hard limits             |
| Privilege escalation           | User namespace (UID 65534)        |

---

## WIT Interface Definitions

### Core Interface: `clawos:kernel@2.0.0`

```wit
/// ClawOS Kernel ABI Interface v2.0.0
/// Provides secure WASM-to-Kernel bridge for AI agent tools
///
/// # Security Model
/// - All operations are capability-based (resource handles)
/// - No direct memory access to kernel space
/// - All errors are explicit and must be handled
/// - All operations are logged via eBPF monitoring
///
/// # Version
/// - WIT Version: 2.0.0
/// - Component Model: wasmtime 27+
/// - ABI: wasm32-unknown-unknown
package clawos:kernel@2.0.0;

/// Core error codes for all kernel operations
///
/// Error codes follow POSIX conventions where applicable:
/// - 0: Success
/// - 1-99: POSIX errno values
/// - 100-199: WASM-specific errors
/// - 200-299: ClawOS-specific errors
@since(version = 2.0.0)
enum errno {
    /// Operation completed successfully
    success = 0,

    // POSIX errno values (1-99)
    /// Operation not permitted
    eperm = 1,
    /// No such file or directory
    enoent = 2,
    /// No such process
    esrch = 3,
    /// Interrupted system call
    eintr = 4,
    /// I/O error
    eio = 5,
    /// No such device or address
    enxio = 6,
    /// Argument list too long
    e2big = 7,
    /// Exec format error
    enoexec = 8,
    /// Bad file number
    ebadf = 9,
    /// No child processes
    echild = 10,
    /// Try again
    eagain = 11,
    /// Out of memory
    enomem = 12,
    /// Permission denied
    eacces = 13,
    /// Bad address
    efault = 14,
    /// Block device required
    enotblk = 15,
    /// Device or resource busy
    ebusy = 16,
    /// File exists
    eexist = 17,
    /// Cross-device link
    exdev = 18,
    /// No such device
    enodev = 19,
    /// Not a directory
    enotdir = 20,
    /// Is a directory
    eisdir = 21,
    /// Invalid argument
    einval = 22,
    /// File table overflow
    enfile = 23,
    /// Too many open files
    emfile = 24,
    /// Not a typewriter
    enotty = 25,
    /// Text file busy
    etxtbsy = 26,
    /// File too large
    efbig = 27,
    /// No space left on device
    enospc = 28,
    /// Illegal seek
    espipe = 29,
    /// Read-only file system
    erofs = 30,
    /// Too many links
    emlink = 31,
    /// Broken pipe
    epipe = 32,
    /// Math argument out of domain of func
    edom = 33,
    /// Math result not representable
    erange = 34,
    /// Resource deadlock would occur
    edeadlk = 35,
    /// File name too long
    enametoolong = 36,
    /// No record locks available
    enolck = 37,
    /// Function not implemented
    enosys = 38,
    /// Directory not empty
    enotempty = 39,
    /// Too many symbolic links
    eloop = 40,
    /// Operation would block
    ewouldblock = 41,
    /// No message of desired type
    enomsg = 42,
    /// Identifier removed
    eidrm = 43,
    /// Channel number out of range
    echrng = 44,
    /// Level 2 not synchronized
    el2nsync = 45,
    /// Level 3 halted
    el3hlt = 46,
    /// Level 3 reset
    el3rst = 47,
    /// Link number out of range
    elnrng = 48,
    /// Protocol driver not attached
    eunatch = 49,
    /// No CSI structure available
    enocsi = 50,
    /// Level 2 halted
    el2hlt = 51,
    /// Invalid exchange
    ebade = 52,
    /// Invalid request descriptor
    ebadr = 53,
    /// Exchange full
    ebadrqc = 54,
    /// Invalid request code
    ebadslt = 55,
    /// Invalid slot
    edeadlock = 56,
    /// Bad font file format
    ebfont = 57,
    /// Device not a stream
    enostR = 58,
    /// No data available
    enodata = 60,
    /// Timer expired
    etime = 62,
    /// Out of streams resources
    enosr = 63,
    /// Machine is not on the network
    enonet = 64,
    /// Package not installed
    enopkg = 65,
    /// Object is remote
    eremote = 66,
    /// Link has been severed
    enolink = 67,
    /// Advertise error
    eadv = 68,
    /// Srmount error
    esrmnt = 69,
    /// Communication error on send
    ecomm = 70,
    /// Protocol error
    eproto = 71,
    /// Multihop attempted
    emultihop = 72,
    /// RFS specific error
    edotdot = 73,
    /// Not a data message
    ebadmsg = 74,
    /// Value too large for defined data type
    eoverflow = 75,
    /// Name not unique on network
    enotuniq = 76,
    /// File descriptor in bad state
    ebadfd = 77,
    /// Remote address changed
    eremchg = 78,
    /// Can not access a needed shared library
    elibacc = 79,
    /// Accessing a corrupted shared library
    elibbad = 80,
    /// .lib section in a.out corrupted
    elibscn = 81,
    /// Attempting to link in too many shared libraries
    elibmax = 82,
    /// Cannot exec a shared library directly
    elibexec = 83,
    /// Illegal byte sequence
    eilseq = 84,
    /// Interrupted system call should be restarted
    erestart = 85,
    /// Streams pipe error
    estrpipe = 86,
    /// Too many users
    eusers = 87,
    /// Not a stream
    enotsock = 88,
    /// Destination address required
    edestaddrreq = 89,
    /// Message too long
    emsgsize = 90,
    /// Protocol wrong type for socket
    eprotonosupport = 91,
    /// Protocol not available
    enoprotoopt = 92,
    /// Protocol not supported
    eprotoopt = 93,
    /// Socket type not supported
    esocktnosupport = 94,
    /// Operation not supported on transport endpoint
    eopnotsupp = 95,
    /// Protocol family not supported
    epfnosupport = 96,
    /// Address family not supported by protocol
    eafnosupport = 97,
    /// Address already in use
    eaddrinuse = 98,
    /// Cannot assign requested address
    eaddrnotavail = 99,

    // WASM-specific errors (100-199)
    /// WASM memory allocation failed
    wasm-alloc-failed = 100,
    /// WASM stack overflow
    wasm-stack-overflow = 101,
    /// WASM trap occurred
    wasm-trap = 102,
    /// Invalid WASM module
    wasm-invalid-module = 103,
    /// WASM function not found
    wasm-function-not-found = 104,
    /// WASM resource limit exceeded
    wasm-resource-limit = 105,

    // ClawOS-specific errors (200-299)
    /// Invalid resource handle
    invalid-handle = 200,
    /// Resource already closed
    resource-closed = 201,
    /// Permission denied by security policy
    security-denied = 202,
    /// Resource quota exceeded
    quota-exceeded = 203,
    /// Operation not supported in current context
    not-supported = 204,
    /// Invalid configuration
    invalid-config = 205,
    /// Internal error (should not occur)
    internal-error = 206,
    /// Operation timed out
    timeout = 207,
    /// Canceled by user
    canceled = 208,
    /// Too many pending operations
    too-many-pending = 209,
}

/// Result type for all operations
///
/// All host functions return this type to ensure explicit error handling
type result<T> = result<T, errno>

/// File descriptor handle
///
/// Represents an open file or directory in the kernel
/// Handles are opaque and cannot be forged
resource file-descriptor {
    /// Close the file descriptor
    ///
    /// # Errors
    /// - `ebadf`: Invalid file descriptor
    /// - `eio`: I/O error
    close: func() -> result<_>

    /// Read data from the file
    ///
    /// # Parameters
    /// - `buffer`: Buffer to read data into
    /// - `max-bytes`: Maximum number of bytes to read
    ///
    /// # Returns
    /// Number of bytes actually read
    ///
    /// # Errors
    /// - `ebadf`: Invalid file descriptor
    /// - `eio`: I/O error
    /// - `einval`: Invalid argument
    read: func(buffer: list<u8>, max-bytes: u32) -> result<u32>

    /// Write data to the file
    ///
    /// # Parameters
    /// - `data`: Data to write
    ///
    /// # Returns
    /// Number of bytes actually written
    ///
    /// # Errors
    /// - `ebadf`: Invalid file descriptor
    /// - `eio`: I/O error
    /// - `enospc`: No space left on device
    write: func(data: list<u8>) -> result<u32>

    /// Seek to a position in the file
    ///
    /// # Parameters
    /// - `offset`: Offset to seek to
    /// - `whence`: Seek origin (0=SEEK_SET, 1=SEEK_CUR, 2=SEEK_END)
    ///
    /// # Returns
    /// New file position
    ///
    /// # Errors
    /// - `ebadf`: Invalid file descriptor
    /// - `einval`: Invalid argument
    /// - `espipe`: Illegal seek (not seekable)
    seek: func(offset: s64, whence: u8) -> result<u64>

    /// Get file status information
    ///
    /// # Returns
    /// File status information
    ///
    /// # Errors
    /// - `ebadf`: Invalid file descriptor
    /// - `eio`: I/O error
    stat: func() -> result<file-stat>

    /// Sync file to disk
    ///
    /// # Errors
    /// - `ebadf`: Invalid file descriptor
    /// - `eio`: I/O error
    sync: func() -> result<_>
}

/// File status information
record file-stat {
    /// File size in bytes
    size: u64,
    /// File mode (permissions + type)
    mode: u32,
    /// Last modification time (Unix timestamp)
    mtime: u64,
    /// Last access time (Unix timestamp)
    atime: u64,
    /// Last status change time (Unix timestamp)
    ctime: u64,
    /// Inode number
    ino: u64,
    /// Device ID
    dev: u64,
    /// Number of hard links
    nlink: u64,
    /// User ID
    uid: u32,
    /// Group ID
    gid: u32,
    /// Block size
    blksize: u64,
    /// Number of blocks
    blocks: u64,
}

/// Directory entry handle
///
/// Represents an open directory for iteration
resource directory-entry {
    /// Read the next directory entry
    ///
    /// # Returns
    /// Directory entry name, or empty string if end of directory
    ///
    /// # Errors
    /// - `eio`: I/O error
    read: func() -> result<string>

    /// Close the directory
    ///
    /// # Errors
    /// - `ebadf`: Invalid directory descriptor
    close: func() -> result<_>
}

/// Memory region handle
///
/// Represents a shared memory region between WASM and kernel
resource memory-region {
    /// Get the size of the memory region
    ///
    /// # Returns
    /// Size in bytes
    size: func() -> u32

    /// Read data from the memory region
    ///
    /// # Parameters
    /// - `offset`: Offset to read from
    /// - `buffer`: Buffer to read data into
    /// - `length`: Number of bytes to read
    ///
    /// # Errors
    /// - `efault`: Bad address (invalid offset)
    /// - `einval`: Invalid argument
    read: func(offset: u32, buffer: list<u8>, length: u32) -> result<_>

    /// Write data to the memory region
    ///
    /// # Parameters
    /// - `offset`: Offset to write to
    /// - `data`: Data to write
    ///
    /// # Errors
    /// - `efault`: Bad address (invalid offset)
    /// - `einval`: Invalid argument
    write: func(offset: u32, data: list<u8>) -> result<_>

    /// Sync the memory region
    ///
    /// # Errors
    /// - `eio`: I/O error
    sync: func() -> result<_>

    /// Close the memory region
    ///
    /// # Errors
    /// - `ebadf`: Invalid memory region handle
    close: func() -> result<_>
}

/// Network socket handle
///
/// Represents a network socket for communication
resource socket {
    /// Connect to a remote address
    ///
    /// # Parameters
    /// - `host`: Remote host address
    /// - `port`: Remote port
    ///
    /// # Errors
    /// - `econnrefused`: Connection refused
    /// - `etimedout`: Connection timed out
    /// - `enetunreach`: Network unreachable
    /// - `eacces`: Permission denied
    connect: func(host: string, port: u16) -> result<_>

    /// Send data
    ///
    /// # Parameters
    /// - `data`: Data to send
    ///
    /// # Returns
    /// Number of bytes sent
    ///
    /// # Errors
    /// - `eio`: I/O error
    /// - `enotconn`: Not connected
    /// - `emsgsize`: Message too long
    send: func(data: list<u8>) -> result<u32>

    /// Receive data
    ///
    /// # Parameters
    /// - `buffer`: Buffer to receive data into
    /// - `max-bytes`: Maximum number of bytes to receive
    ///
    /// # Returns
    /// Number of bytes received
    ///
    /// # Errors
    /// - `eio`: I/O error
    /// - `enotconn`: Not connected
    /// - `eagain`: Try again (non-blocking)
    recv: func(buffer: list<u8>, max-bytes: u32) -> result<u32>

    /// Close the socket
    ///
    /// # Errors
    /// - `ebadf`: Invalid socket descriptor
    close: func() -> result<_>
}

/// Cgroup handle
///
/// Represents a cgroup v2 control group for resource management
resource cgroup {
    /// Set memory limit
    ///
    /// # Parameters
    /// - `limit-bytes`: Memory limit in bytes (0 = unlimited)
    ///
    /// # Errors
    /// - `eacces`: Permission denied
    /// - `einval`: Invalid argument
    set-memory-limit: func(limit-bytes: u64) -> result<_>

    /// Set CPU limit
    ///
    /// # Parameters
    /// - `cpu-max`: CPU quota (e.g., 100000 for 10% of 1 CPU)
    /// - `period-us`: Period in microseconds (default: 1000000)
    ///
    /// # Errors
    /// - `eacces`: Permission denied
    /// - `einval`: Invalid argument
    set-cpu-limit: func(cpu-max: u64, period-us: u64) -> result<_>

    /// Set PID limit
    ///
    /// # Parameters
    /// - `max-pids`: Maximum number of PIDs (0 = unlimited)
    ///
    /// # Errors
    /// - `eacces`: Permission denied
    /// - `einval`: Invalid argument
    set-pid-limit: func(max-pids: u64) -> result<_>

    /// Get current memory usage
    ///
    /// # Returns
    /// Memory usage in bytes
    ///
    /// # Errors
    /// - `eio`: I/O error
    get-memory-usage: func() -> result<u64>

    /// Get current CPU usage
    ///
    /// # Returns
    /// CPU usage in nanoseconds
    ///
    /// # Errors
    /// - `eio`: I/O error
    get-cpu-usage: func() -> result<u64>

    /// Get current PID count
    ///
    /// # Returns
    /// Number of PIDs in the cgroup
    ///
    /// # Errors
    /// - `eio`: I/O error
    get-pid-count: func() -> result<u64>

    /// Close the cgroup handle
    ///
    /// # Errors
    /// - `ebadf`: Invalid cgroup handle
    close: func() -> result<_>
}

/// Device handle
///
/// Represents a device (block or character device)
resource device {
    /// Read from the device
    ///
    /// # Parameters
    /// - `buffer`: Buffer to read data into
    /// - `offset`: Offset to read from
    /// - `length`: Number of bytes to read
    ///
    /// # Errors
    /// - `eio`: I/O error
    /// - `einval`: Invalid argument
    read: func(buffer: list<u8>, offset: u64, length: u32) -> result<_>

    /// Write to the device
    ///
    /// # Parameters
    /// - `data`: Data to write
    /// - `offset`: Offset to write to
    ///
    /// # Errors
    /// - `eio`: I/O error
    /// - `einval`: Invalid argument
    write: func(data: list<u8>, offset: u64) -> result<_>

    /// Sync the device
    ///
    /// # Errors
    /// - `eio`: I/O error
    sync: func() -> result<_>

    /// Close the device handle
    ///
    /// # Errors
    /// - `ebadf`: Invalid device handle
    close: func() -> result<_>
}

/// File open flags
@since(version = 2.0.0)
flags open-flags {
    /// Read-only access
    read-only = 0,
    /// Write-only access
    write-only = 1,
    /// Read-write access
    read-write = 2,
    /// Create file if it doesn't exist
    create = 0o100,
    /// Exclusive create (fail if exists)
    exclusive = 0o200,
    /// Truncate file to zero length
    truncate = 0o1000,
    /// Append to file
    append = 0o2000,
    /// Non-blocking mode
    non-block = 0o4000,
    /// Synchronous writes
    sync = 0o100000,
    /// Close on exec
    close-on-exec = 0o2000000,
}

/// File permissions
@since(version = 2.0.0)
flags file-permissions {
    /// Owner read
    owner-read = 0o400,
    /// Owner write
    owner-write = 0o200,
    /// Owner execute
    owner-exec = 0o100,
    /// Group read
    group-read = 0o40,
    /// Group write
    group-write = 0o20,
    /// Group execute
    group-exec = 0o10,
    /// Other read
    other-read = 0o4,
    /// Other write
    other-write = 0o2,
    /// Other execute
    other-exec = 0o1,
    /// Set user ID on execution
    set-uid = 0o4000,
    /// Set group ID on execution
    set-gid = 0o2000,
    /// Sticky bit
    sticky = 0o1000,
}

/// Seek whence values
@since(version = 2.0.0)
enum seek-whence {
    /// Seek from beginning of file
    set = 0,
    /// Seek from current position
    cur = 1,
    /// Seek from end of file
    end = 2,
}

/// File system interface
///
/// Provides file and directory operations
interface filesystem {
    /// Open a file
    ///
    /// # Parameters
    /// - `path`: Path to the file
    /// - `flags`: Open flags (read/write/create/etc)
    /// - `mode`: File permissions (used when creating)
    ///
    /// # Returns
    /// File descriptor handle
    ///
    /// # Errors
    /// - `enoent`: No such file or directory
    /// - `eacces`: Permission denied
    /// - `emfile`: Too many open files
    /// - `enomem`: Out of memory
    open: func(path: string, flags: open-flags, mode: file-permissions) -> result<file-descriptor>

    /// Create a directory
    ///
    /// # Parameters
    /// - `path`: Path to the directory
    /// - `mode`: Directory permissions
    ///
    /// # Errors
    /// - `eacces`: Permission denied
    /// - `eexist`: File exists
    /// - `enoent`: Parent directory doesn't exist
    mkdir: func(path: string, mode: file-permissions) -> result<_>

    /// Remove a directory
    ///
    /// # Parameters
    /// - `path`: Path to the directory
    ///
    /// # Errors
    /// - `enoent`: No such file or directory
    /// - `enotempty`: Directory not empty
    /// - `eacces`: Permission denied
    rmdir: func(path: string) -> result<_>

    /// Remove a file
    ///
    /// # Parameters
    /// - `path`: Path to the file
    ///
    /// # Errors
    /// - `enoent`: No such file or directory
    /// - `eacces`: Permission denied
    /// - `eisdir`: Is a directory
    unlink: func(path: string) -> result<_>

    /// Rename a file or directory
    ///
    /// # Parameters
    /// - `old-path`: Old path
    /// - `new-path`: New path
    ///
    /// # Errors
    /// - `enoent`: No such file or directory
    /// - `eacces`: Permission denied
    /// - `eexist`: Destination exists
    rename: func(old-path: string, new-path: string) -> result<_>

    /// Get file status
    ///
    /// # Parameters
    /// - `path`: Path to the file
    ///
    /// # Returns
    /// File status information
    ///
    /// # Errors
    /// - `enoent`: No such file or directory
    /// - `eacces`: Permission denied
    stat: func(path: string) -> result<file-stat>

    /// Open a directory for iteration
    ///
    /// # Parameters
    /// - `path`: Path to the directory
    ///
    /// # Returns
    /// Directory entry handle
    ///
    /// # Errors
    /// - `enoent`: No such file or directory
    /// - `enotdir`: Not a directory
    /// - `eacces`: Permission denied
    opendir: func(path: string) -> result<directory-entry>

    /// Create a hard link
    ///
    /// # Parameters
    /// - `old-path`: Existing file path
    /// - `new-path`: New link path
    ///
    /// # Errors
    /// - `enoent`: No such file or directory
    /// - `eacces`: Permission denied
    /// - `eexist`: Destination exists
    link: func(old-path: string, new-path: string) -> result<_>

    /// Create a symbolic link
    ///
    /// # Parameters
    /// - `target`: Target path
    /// - `link-path`: Link path
    ///
    /// # Errors
    /// - `eacces`: Permission denied
    /// - `eexist`: Destination exists
    symlink: func(target: string, link-path: string) -> result<_>

    /// Read a symbolic link
    ///
    /// # Parameters
    /// - `path`: Path to the symbolic link
    ///
    /// # Returns
    /// Target path
    ///
    /// # Errors
    /// - `enoent`: No such file or directory
    /// - `einval`: Invalid argument (not a symlink)
    /// - `eacces`: Permission denied
    readlink: func(path: string) -> result<string>

    /// Change file permissions
    ///
    /// # Parameters
    /// - `path`: Path to the file
    /// - `mode`: New permissions
    ///
    /// # Errors
    /// - `enoent`: No such file or directory
    /// - `eacces`: Permission denied
    chmod: func(path: string, mode: file-permissions) -> result<_>

    /// Change file owner
    ///
    /// # Parameters
    /// - `path`: Path to the file
    /// - `uid`: User ID
    /// - `gid`: Group ID
    ///
    /// # Errors
    /// - `enoent`: No such file or directory
    /// - `eacces`: Permission denied
    /// - `eperm`: Operation not permitted
    chown: func(path: string, uid: u32, gid: u32) -> result<_>

    /// Truncate a file
    ///
    /// # Parameters
    /// - `path`: Path to the file
    /// - `length`: New length in bytes
    ///
    /// # Errors
    /// - `enoent`: No such file or directory
    /// - `eacces`: Permission denied
    /// - `eisdir`: Is a directory
    truncate: func(path: string, length: u64) -> result<_>

    /// Sync a file to disk
    ///
    /// # Parameters
    /// - `path`: Path to the file
    ///
    /// # Errors
    /// - `enoent`: No such file or directory
    /// - `eio`: I/O error
    sync: func(path: string) -> result<_>
}

/// Network interface
///
/// Provides network communication operations
interface network {
    /// Create a socket
    ///
    /// # Parameters
    /// - `domain`: Address family (2=AF_INET, 10=AF_INET6)
    /// - `type`: Socket type (1=SOCK_STREAM, 2=SOCK_DGRAM)
    /// - `protocol`: Protocol (0=auto, 6=TCP, 17=UDP)
    ///
    /// # Returns
    /// Socket handle
    ///
    /// # Errors
    /// - `emfile`: Too many open files
    /// - `enomem`: Out of memory
    /// - `eacces`: Permission denied
    socket: func(domain: u32, type: u32, protocol: u32) -> result<socket>

    /// Resolve a hostname to an IP address
    ///
    /// # Parameters
    /// - `hostname`: Hostname to resolve
    ///
    /// # Returns
    /// IP address (IPv4 or IPv6)
    ///
    /// # Errors
    /// - `eai-noname`: Name or service not known
    /// - `eai-again`: Temporary failure
    /// - `eai-fail`: Non-recoverable failure
    resolve: func(hostname: string) -> result<string>

    /// Get local hostname
    ///
    /// # Returns
    /// Local hostname
    ///
    /// # Errors
    /// - `eio`: I/O error
    gethostname: func() -> result<string>
}

/// Cgroup interface
///
/// Provides cgroup v2 resource management operations
interface cgroup {
    /// Create a new cgroup
    ///
    /// # Parameters
    /// - `name`: Cgroup name
    /// - `parent`: Parent cgroup path (empty for root)
    ///
    /// # Returns
    /// Cgroup handle
    ///
    /// # Errors
    /// - `eacces`: Permission denied
    /// - `eexist`: Cgroup already exists
    /// - `enoent`: Parent cgroup doesn't exist
    create: func(name: string, parent: string) -> result<cgroup>

    /// Open an existing cgroup
    ///
    /// # Parameters
    /// - `path`: Cgroup path
    ///
    /// # Returns
    /// Cgroup handle
    ///
    /// # Errors
    /// - `enoent`: Cgroup doesn't exist
    /// - `eacces`: Permission denied
    open: func(path: string) -> result<cgroup>

    /// Delete a cgroup
    ///
    /// # Parameters
    /// - `path`: Cgroup path
    ///
    /// # Errors
    /// - `enoent`: Cgroup doesn't exist
    /// - `eacces`: Permission denied
    /// - `enotempty`: Cgroup not empty
    delete: func(path: string) -> result<_>

    /// Add a process to a cgroup
    ///
    /// # Parameters
    /// - `cgroup-path`: Cgroup path
    /// - `pid`: Process ID
    ///
    /// # Errors
    /// - `enoent`: Cgroup doesn't exist
    /// - `eacces`: Permission denied
    /// - `esrch`: No such process
    add-process: func(cgroup-path: string, pid: u32) -> result<_>

    /// Remove a process from a cgroup
    ///
    /// # Parameters
    /// - `cgroup-path`: Cgroup path
    /// - `pid`: Process ID
    ///
    /// # Errors
    /// - `enoent`: Cgroup doesn't exist
    /// - `eacces`: Permission denied
    /// - `esrch`: No such process
    remove-process: func(cgroup-path: string, pid: u32) -> result<_>
}

/// Memory interface
///
/// Provides memory management operations
interface memory {
    /// Allocate a shared memory region
    ///
    /// # Parameters
    /// - `size`: Size in bytes
    /// - `name`: Memory region name (for debugging)
    ///
    /// # Returns
    /// Memory region handle
    ///
    /// # Errors
    /// - `enomem`: Out of memory
    /// - `einval`: Invalid argument (size too large)
    allocate: func(size: u32, name: string) -> result<memory-region>

    /// Get current memory usage
    ///
    /// # Returns
    /// Memory usage in bytes
    ///
    /// # Errors
    /// - `eio`: I/O error
    get-usage: func() -> result<u64>

    /// Get memory limit
    ///
    /// # Returns
    /// Memory limit in bytes
    ///
    /// # Errors
    /// - `eio`: I/O error
    get-limit: func() -> result<u64>
}

/// Device interface
///
/// Provides device access operations
interface device {
    /// Open a device
    ///
    /// # Parameters
    /// - `path`: Device path (e.g., /dev/sda)
    /// - `flags`: Open flags
    ///
    /// # Returns
    /// Device handle
    ///
    /// # Errors
    /// - `enoent`: No such device
    /// - `eacces`: Permission denied
    /// - `emfile`: Too many open files
    open: func(path: string, flags: open-flags) -> result<device>

    /// Get device information
    ///
    /// # Parameters
    /// - `path`: Device path
    ///
    /// # Returns
    /// Device information (major, minor numbers)
    ///
    /// # Errors
    /// - `enoent`: No such device
    /// - `eacces`: Permission denied
    get-info: func(path: string) -> result<device-info>
}

/// Device information
record device-info {
    /// Major device number
    major: u32,
    /// Minor device number
    minor: u32,
    /// Device type (0=char, 1=block)
    type: u32,
}

/// System interface
///
/// Provides system-level operations
interface system {
    /// Get system information
    ///
    /// # Returns
    /// System information
    ///
    /// # Errors
    /// - `eio`: I/O error
    get-info: func() -> result<system-info>

    /// Get current time
    ///
    /// # Returns
    /// Current time in nanoseconds since Unix epoch
    ///
    /// # Errors
    /// - `eio`: I/O error
    get-time: func() -> result<u64>

    /// Sleep for a specified duration
    ///
    /// # Parameters
    /// - `duration-ns`: Duration in nanoseconds
    ///
    /// # Errors
    /// - `eintr`: Interrupted system call
    sleep: func(duration-ns: u64) -> result<_>

    /// Get environment variable
    ///
    /// # Parameters
    /// - `name`: Environment variable name
    ///
    /// # Returns
    /// Environment variable value
    ///
    /// # Errors
    /// - `enoent`: Environment variable not found
    get-env: func(name: string) -> result<string>

    /// Set environment variable
    ///
    /// # Parameters
    /// - `name`: Environment variable name
    /// - `value`: Environment variable value
    ///
    /// # Errors
    /// - `enomem`: Out of memory
    set-env: func(name: string, value: string) -> result<_>

    /// Get process ID
    ///
    /// # Returns
    /// Current process ID
    ///
    /// # Errors
    /// - `eio`: I/O error
    get-pid: func() -> result<u32>

    /// Get parent process ID
    ///
    /// # Returns
    /// Parent process ID
    ///
    /// # Errors
    /// - `eio`: I/O error
    get-ppid: func() -> result<u32>

    /// Exit the current process
    ///
    /// # Parameters
    /// - `exit-code`: Exit code
    exit: func(exit-code: u32) -> _
}

/// System information
record system-info {
    /// System name (e.g., "Linux")
    sysname: string,
    /// Node name (hostname)
    nodename: string,
    /// Release (kernel version)
    release: string,
    /// Version
    version: string,
    /// Machine architecture
    machine: string,
    /// Number of CPUs
    cpus: u32,
    /// Total memory in bytes
    total-memory: u64,
    /// Free memory in bytes
    free-memory: u64,
}

/// Logging interface
///
/// Provides logging operations
interface logging {
    /// Log a message
    ///
    /// # Parameters
    /// - `level`: Log level (0=debug, 1=info, 2=warn, 3=error)
    /// - `message`: Log message
    log: func(level: u32, message: string) -> _

    /// Log a debug message
    ///
    /// # Parameters
    /// - `message`: Log message
    debug: func(message: string) -> _

    /// Log an info message
    ///
    /// # Parameters
    /// - `message`: Log message
    info: func(message: string) -> _

    /// Log a warning message
    ///
    /// # Parameters
    /// - `message`: Log message
    warn: func(message: string) -> _

    /// Log an error message
    ///
    /// # Parameters
    /// - `message`: Log message
    error: func(message: string) -> _
}

/// Export all interfaces
export filesystem: filesystem
export network: network
export cgroup: cgroup
export memory: memory
export device: device
export system: system
export logging: logging
```

---

## Error Codes

### Error Code Summary

| Code    | Name          | Description                      | Category |
| ------- | ------------- | -------------------------------- | -------- |
| 0       | success       | Operation completed successfully | Success  |
| 1-99    | POSIX errno   | Standard POSIX error codes       | POSIX    |
| 100-199 | WASM errors   | WASM-specific errors             | WASM     |
| 200-299 | ClawOS errors | ClawOS-specific errors           | ClawOS   |

### POSIX Error Codes (1-99)

See the `errno` enum in the WIT interface definition above for the complete list.

### WASM-Specific Error Codes (100-199)

| Code | Name                    | Description                   |
| ---- | ----------------------- | ----------------------------- |
| 100  | wasm-alloc-failed       | WASM memory allocation failed |
| 101  | wasm-stack-overflow     | WASM stack overflow           |
| 102  | wasm-trap               | WASM trap occurred            |
| 103  | wasm-invalid-module     | Invalid WASM module           |
| 104  | wasm-function-not-found | WASM function not found       |
| 105  | wasm-resource-limit     | WASM resource limit exceeded  |

### ClawOS-Specific Error Codes (200-299)

| Code | Name             | Description                                |
| ---- | ---------------- | ------------------------------------------ |
| 200  | invalid-handle   | Invalid resource handle                    |
| 201  | resource-closed  | Resource already closed                    |
| 202  | security-denied  | Permission denied by security policy       |
| 203  | quota-exceeded   | Resource quota exceeded                    |
| 204  | not-supported    | Operation not supported in current context |
| 205  | invalid-config   | Invalid configuration                      |
| 206  | internal-error   | Internal error (should not occur)          |
| 207  | timeout          | Operation timed out                        |
| 208  | canceled         | Canceled by user                           |
| 209  | too-many-pending | Too many pending operations                |

### Error Handling Best Practices

1. **Always check return values**: All host functions return `result<T>` and must be checked
2. **Handle errors explicitly**: Never ignore errors
3. **Log errors**: Use the logging interface to log errors for debugging
4. **Propagate errors**: Return errors to callers when appropriate
5. **Clean up resources**: Always close resources even on error

---

## Resource Types

### Resource Type Summary

| Resource          | Description                  | Lifecycle                                           |
| ----------------- | ---------------------------- | --------------------------------------------------- |
| `file-descriptor` | Open file or directory       | Created by `filesystem::open`, closed by `close`    |
| `directory-entry` | Open directory for iteration | Created by `filesystem::opendir`, closed by `close` |
| `memory-region`   | Shared memory region         | Created by `memory::allocate`, closed by `close`    |
| `socket`          | Network socket               | Created by `network::socket`, closed by `close`     |
| `cgroup`          | Cgroup v2 control group      | Created by `cgroup::create`, closed by `close`      |
| `device`          | Device handle                | Created by `device::open`, closed by `close`        |

### Resource Lifecycle

All resources follow the same lifecycle pattern:

```
1. Creation: resource = interface::create(...)
2. Usage: resource.method(...)
3. Cleanup: resource.close()
```

### Resource Ownership

- **Exclusive Ownership**: Each resource handle is owned by a single WASM component
- **No Sharing**: Resources cannot be shared between WASM components
- **Automatic Cleanup**: Resources are automatically closed when the WASM component terminates
- **Explicit Close**: Resources should be explicitly closed when no longer needed

### Resource Limits

| Resource         | Default Limit | Maximum Limit |
| ---------------- | ------------- | ------------- |
| File descriptors | 64            | 256           |
| Memory regions   | 16            | 64            |
| Sockets          | 8             | 32            |
| Cgroups          | 4             | 16            |
| Devices          | 2             | 8             |

---

## Host Functions

### File System Functions

#### `filesystem::open`

Open a file and return a file descriptor handle.

**Signature:**
```wit
open: func(path: string, flags: open-flags, mode: file-permissions) -> result<file-descriptor>
```

**Parameters:**
- `path`: Path to the file (relative to ClawFS root)
- `flags`: Open flags (read/write/create/etc)
- `mode`: File permissions (used when creating)

**Returns:**
- `Ok(file-descriptor)`: File descriptor handle
- `Err(errno)`: Error code

**Example:**
```rust
use clawos_kernel::filesystem;

// Open a file for reading
let fd = filesystem::open(
    "/clawfs/tools/mytool/config.json",
    open_flags::READ_ONLY,
    file_permissions::OWNER_READ | file_permissions::GROUP_READ
)?;

// Read from the file
let mut buffer = vec![0u8; 4096];
let bytes_read = fd.read(&mut buffer, 4096)?;

// Close the file
fd.close()?;
```

#### `filesystem::stat`

Get file status information.

**Signature:**
```wit
stat: func(path: string) -> result<file-stat>
```

**Parameters:**
- `path`: Path to the file

**Returns:**
- `Ok(file-stat)`: File status information
- `Err(errno)`: Error code

**Example:**
```rust
use clawos_kernel::filesystem;

// Get file status
let stat = filesystem::stat("/clawfs/tools/mytool/config.json")?;

println!("File size: {} bytes", stat.size);
println!("Last modified: {}", stat.mtime);
```

### Network Functions

#### `network::socket`

Create a network socket.

**Signature:**
```wit
socket: func(domain: u32, type: u32, protocol: u32) -> result<socket>
```

**Parameters:**
- `domain`: Address family (2=AF_INET, 10=AF_INET6)
- `type`: Socket type (1=SOCK_STREAM, 2=SOCK_DGRAM)
- `protocol`: Protocol (0=auto, 6=TCP, 17=UDP)

**Returns:**
- `Ok(socket)`: Socket handle
- `Err(errno)`: Error code

**Example:**
```rust
use clawos_kernel::network;

// Create a TCP socket
let socket = network::socket(2, 1, 6)?;

// Connect to a server
socket.connect("example.com", 80)?;

// Send data
socket.send(b"GET / HTTP/1.1\r\nHost: example.com\r\n\r\n")?;

// Receive data
let mut buffer = vec![0u8; 4096];
let bytes_received = socket.recv(&mut buffer, 4096)?;

// Close the socket
socket.close()?;
```

### Cgroup Functions

#### `cgroup::create`

Create a new cgroup v2 control group.

**Signature:**
```wit
create: func(name: string, parent: string) -> result<cgroup>
```

**Parameters:**
- `name`: Cgroup name
- `parent`: Parent cgroup path (empty for root)

**Returns:**
- `Ok(cgroup)`: Cgroup handle
- `Err(errno)`: Error code

**Example:**
```rust
use clawos_kernel::cgroup;

// Create a new cgroup
let cg = cgroup::create("mytool", "")?;

// Set resource limits
cg.set_memory_limit(64 * 1024 * 1024)?;  // 64MB
cg.set_cpu_limit(100000, 1000000)?;      // 10% of 1 CPU
cg.set_pid_limit(16)?;                    // Max 16 processes

// Add current process to cgroup
let pid = system::get_pid()?;
cgroup::add_process("/sys/fs/cgroup/clawos/mytool", pid)?;

// Close the cgroup handle
cg.close()?;
```

### Memory Functions

#### `memory::allocate`

Allocate a shared memory region.

**Signature:**
```wit
allocate: func(size: u32, name: string) -> result<memory-region>
```

**Parameters:**
- `size`: Size in bytes
- `name`: Memory region name (for debugging)

**Returns:**
- `Ok(memory-region)`: Memory region handle
- `Err(errno)`: Error code

**Example:**
```rust
use clawos_kernel::memory;

// Allocate a 1MB shared memory region
let mem = memory::allocate(1024 * 1024, "tool-buffer")?;

// Write data to the memory region
mem.write(0, b"Hello, World!")?;

// Read data from the memory region
let mut buffer = vec![0u8; 13];
mem.read(0, &mut buffer, 13)?;

// Sync the memory region
mem.sync()?;

// Close the memory region
mem.close()?;
```

### System Functions

#### `system::get-info`

Get system information.

**Signature:**
```wit
get-info: func() -> result<system-info>
```

**Returns:**
- `Ok(system-info)`: System information
- `Err(errno)`: Error code

**Example:**
```rust
use clawos_kernel::system;

// Get system information
let info = system::get-info()?;

println!("System: {}", info.sysname);
println!("Kernel: {}", info.release);
println!("CPUs: {}", info.cpus);
println!("Total memory: {} MB", info.total_memory / (1024 * 1024));
```

### Logging Functions

#### `logging::log`

Log a message at a specified level.

**Signature:**
```wit
log: func(level: u32, message: string) -> _
```

**Parameters:**
- `level`: Log level (0=debug, 1=info, 2=warn, 3=error)
- `message`: Log message

**Example:**
```rust
use clawos_kernel::logging;

// Log messages at different levels
logging::debug("Starting tool execution");
logging::info("Processing file: {}", filename);
logging::warn("Resource usage high: {}%", usage);
logging::error("Failed to open file: {}", error);
```

---

## Migration Strategy

### From IronClaw WIT v1.0 to ClawOS WIT v2.0

#### Overview

The migration from IronClaw's original WIT interface (v1.0) to ClawOS WIT v2.0 involves:

1. **Interface Restructuring**: Split monolithic interface into focused sub-interfaces
2. **Error Code Expansion**: Add WASM-specific and ClawOS-specific error codes
3. **Resource Type Refinement**: Improve resource type definitions and lifecycle management
4. **Security Enhancements**: Add capability-based access control and audit logging
5. **Performance Optimizations**: Reduce overhead for common operations

#### Breaking Changes

| Change                      | Impact                        | Migration Path                            |
| --------------------------- | ----------------------------- | ----------------------------------------- |
| Monolithic interface split  | Import paths changed          | Update imports to use sub-interfaces      |
| Error code expansion        | New error codes may appear    | Update error handling to handle new codes |
| Resource type changes       | Some resource methods renamed | Update method calls                       |
| Security policy enforcement | Some operations may be denied | Review and update security policies       |

#### Migration Steps

1. **Phase 1: Preparation (Week 1)**
   - Audit existing WASM components for WIT v1.0 usage
   - Identify breaking changes in each component
   - Create migration plan for each component

2. **Phase 2: Interface Update (Week 2)**
   - Update WIT imports in all components
   - Update error handling code
   - Update resource method calls

3. **Phase 3: Testing (Week 3)**
   - Unit test all updated components
   - Integration test with WIT v2.0 interface
   - Performance benchmarking

4. **Phase 4: Deployment (Week 4)**
   - Deploy updated components to staging
   - Monitor for errors and performance issues
   - Deploy to production after validation

#### Compatibility Layer

A compatibility layer is provided to ease migration:

```wit
/// Compatibility layer for IronClaw WIT v1.0
/// This interface will be deprecated in ClawOS v2.0
@deprecated(since = "2.0.0", note = "Use clawos:kernel@2.0.0 sub-interfaces instead")
package clawos:kernel-compat@1.0.0;

/// Re-export v2.0 interfaces for compatibility
export filesystem: filesystem
export network: network
export cgroup: cgroup
export memory: memory
export device: device
export system: system
export logging: logging
```

#### Migration Example

**Before (IronClaw WIT v1.0):**
```rust
use ironclaw_kernel;

// Open a file
let fd = ironclaw_kernel::open("/path/to/file", ironclaw_kernel::O_RDONLY)?;

// Read from file
let mut buffer = vec![0u8; 4096];
let bytes_read = ironclaw_kernel::read(fd, &mut buffer, 4096)?;

// Close file
ironclaw_kernel::close(fd)?;
```

**After (ClawOS WIT v2.0):**
```rust
use clawos_kernel::filesystem;

// Open a file
let fd = filesystem::open(
    "/clawfs/path/to/file",
    open_flags::READ_ONLY,
    file_permissions::OWNER_READ
)?;

// Read from file
let mut buffer = vec![0u8; 4096];
let bytes_read = fd.read(&mut buffer, 4096)?;

// Close file
fd.close()?;
```

---

## JSON Schema Validation

### WIT Interface JSON Schema

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://clawos.org/specs/p1/P1.1-wit-interface.schema.json",
  "title": "ClawOS WIT Interface Schema",
  "description": "JSON Schema for validating WIT interface definitions in ClawOS v1.0",
  "version": "1.0.0",
  "status": "FROZEN",
  "sha256_signature": "PLACEHOLDER_SHA256_SIGNATURE",
  "modification_authority": {
    "agent": "WASM Agent",
    "description": "Only the WASM Agent may modify this schema. Any changes require SHA256 signature update and ClawFS Vault storage.",
    "approval_required": true,
    "vault_storage_required": true
  },
  "type": "object",
  "required": [
    "schema_version",
    "interface_id",
    "wit_version",
    "package",
    "interfaces"
  ],
  "properties": {
    "schema_version": {
      "type": "string",
      "pattern": "^\\d+\\.\\d+\\.\\d+$",
      "description": "Version of the WIT interface schema"
    },
    "interface_id": {
      "type": "string",
      "pattern": "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$",
      "description": "Unique identifier for this interface instance"
    },
    "wit_version": {
      "type": "string",
      "pattern": "^\\d+\\.\\d+\\.\\d+$",
      "description": "WIT specification version"
    },
    "package": {
      "type": "string",
      "pattern": "^[a-z0-9-]+:[a-z0-9-]+@\\d+\\.\\d+\\.\\d+$",
      "description": "Package name and version (e.g., clawos:kernel@2.0.0)"
    },
    "interfaces": {
      "type": "array",
      "description": "List of WIT interfaces",
      "minItems": 1,
      "items": {
        "type": "object",
        "required": ["name", "functions"],
        "properties": {
          "name": {
            "type": "string",
            "description": "Interface name"
          },
          "description": {
            "type": "string",
            "description": "Interface description"
          },
          "functions": {
            "type": "array",
            "description": "List of functions in the interface",
            "items": {
              "type": "object",
              "required": ["name", "return_type"],
              "properties": {
                "name": {
                  "type": "string",
                  "description": "Function name"
                },
                "description": {
                  "type": "string",
                  "description": "Function description"
                },
                "parameters": {
                  "type": "array",
                  "description": "List of function parameters",
                  "items": {
                    "type": "object",
                    "required": ["name", "type"],
                    "properties": {
                      "name": {
                        "type": "string",
                        "description": "Parameter name"
                      },
                      "type": {
                        "type": "string",
                        "description": "Parameter type"
                      },
                      "description": {
                        "type": "string",
                        "description": "Parameter description"
                      }
                    }
                  }
                },
                "return_type": {
                  "type": "string",
                  "description": "Return type (e.g., 'result<T>' or 'T')"
                },
                "errors": {
                  "type": "array",
                  "description": "List of possible error codes",
                  "items": {
                    "type": "string",
                    "description": "Error code name (e.g., 'enoent', 'eacces')"
                  }
                }
              }
            }
          },
          "resources": {
            "type": "array",
            "description": "List of resource types in the interface",
            "items": {
              "type": "object",
              "required": ["name", "methods"],
              "properties": {
                "name": {
                  "type": "string",
                  "description": "Resource name"
                },
                "description": {
                  "type": "string",
                  "description": "Resource description"
                },
                "methods": {
                  "type": "array",
                  "description": "List of resource methods",
                  "items": {
                    "type": "object",
                    "required": ["name", "return_type"],
                    "properties": {
                      "name": {
                        "type": "string",
                        "description": "Method name"
                      },
                      "description": {
                        "type": "string",
                        "description": "Method description"
                      },
                      "parameters": {
                        "type": "array",
                        "description": "List of method parameters",
                        "items": {
                          "type": "object",
                          "required": ["name", "type"],
                          "properties": {
                            "name": {
                              "type": "string",
                              "description": "Parameter name"
                            },
                            "type": {
                              "type": "string",
                              "description": "Parameter type"
                            },
                            "description": {
                              "type": "string",
                              "description": "Parameter description"
                            }
                          }
                        }
                      },
                      "return_type": {
                        "type": "string",
                        "description": "Return type"
                      },
                      "errors": {
                        "type": "array",
                        "description": "List of possible error codes",
                        "items": {
                          "type": "string",
                          "description": "Error code name"
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "enums": {
      "type": "array",
      "description": "List of enum types",
      "items": {
        "type": "object",
        "required": ["name", "variants"],
        "properties": {
          "name": {
            "type": "string",
            "description": "Enum name"
          },
          "description": {
            "type": "string",
            "description": "Enum description"
          },
          "variants": {
            "type": "array",
            "description": "List of enum variants",
            "items": {
              "type": "object",
              "required": ["name", "value"],
              "properties": {
                "name": {
                  "type": "string",
                  "description": "Variant name"
                },
                "value": {
                  "type": "integer",
                  "description": "Variant value"
                },
                "description": {
                  "type": "string",
                  "description": "Variant description"
                }
              }
            }
          }
        }
      }
    },
    "flags": {
      "type": "array",
      "description": "List of flags types",
      "items": {
        "type": "object",
        "required": ["name", "flags"],
        "properties": {
          "name": {
            "type": "string",
            "description": "Flags name"
          },
          "description": {
            "type": "string",
            "description": "Flags description"
          },
          "flags": {
            "type": "array",
            "description": "List of flag values",
            "items": {
              "type": "object",
              "required": ["name", "value"],
              "properties": {
                "name": {
                  "type": "string",
                  "description": "Flag name"
                },
                "value": {
                  "type": "integer",
                  "description": "Flag value"
                },
                "description": {
                  "type": "string",
                  "description": "Flag description"
                }
              }
            }
          }
        }
      }
    },
    "records": {
      "type": "array",
      "description": "List of record types",
      "items": {
        "type": "object",
        "required": ["name", "fields"],
        "properties": {
          "name": {
            "type": "string",
            "description": "Record name"
          },
          "description": {
            "type": "string",
            "description": "Record description"
          },
          "fields": {
            "type": "array",
            "description": "List of record fields",
            "items": {
              "type": "object",
              "required": ["name", "type"],
              "properties": {
                "name": {
                  "type": "string",
                  "description": "Field name"
                },
                "type": {
                  "type": "string",
                  "description": "Field type"
                },
                "description": {
                  "type": "string",
                  "description": "Field description"
                }
              }
            }
          }
        }
      }
    },
    "metadata": {
      "type": "object",
      "description": "Additional metadata about the interface",
      "properties": {
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "ISO 8601 timestamp when interface was created"
        },
        "created_by": {
          "type": "string",
          "enum": ["WASM Agent"],
          "description": "Agent that created this interface"
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "ISO 8601 timestamp of last update"
        },
        "updated_by": {
          "type": "string",
          "enum": ["WASM Agent"],
          "description": "Agent that last updated this interface"
        },
        "signature": {
          "type": "string",
          "pattern": "^[a-f0-9]{64}$",
          "description": "SHA256 signature of the interface content"
        }
      }
    }
  },
  "examples": [
    {
      "schema_version": "1.0.0",
      "interface_id": "550e8400-e29b-41d4-a716-446655440000",
      "wit_version": "2.0.0",
      "package": "clawos:kernel@2.0.0",
      "interfaces": [
        {
          "name": "filesystem",
          "description": "File system interface",
          "functions": [
            {
              "name": "open",
              "description": "Open a file",
              "parameters": [
                {
                  "name": "path",
                  "type": "string",
                  "description": "Path to the file"
                },
                {
                  "name": "flags",
                  "type": "open-flags",
                  "description": "Open flags"
                },
                {
                  "name": "mode",
                  "type": "file-permissions",
                  "description": "File permissions"
                }
              ],
              "return_type": "result<file-descriptor>",
              "errors": ["enoent", "eacces", "emfile", "enomem"]
            }
          ],
          "resources": [
            {
              "name": "file-descriptor",
              "description": "File descriptor handle",
              "methods": [
                {
                  "name": "read",
                  "description": "Read data from the file",
                  "parameters": [
                    {
                      "name": "buffer",
                      "type": "list<u8>",
                      "description": "Buffer to read data into"
                    },
                    {
                      "name": "max-bytes",
                      "type": "u32",
                      "description": "Maximum number of bytes to read"
                    }
                  ],
                  "return_type": "result<u32>",
                  "errors": ["ebadf", "eio", "einval"]
                }
              ]
            }
          ]
        }
      ],
      "enums": [
        {
          "name": "errno",
          "description": "Error codes",
          "variants": [
            {
              "name": "success",
              "value": 0,
              "description": "Operation completed successfully"
            },
            {
              "name": "enoent",
              "value": 2,
              "description": "No such file or directory"
            }
          ]
        }
      ],
      "flags": [
        {
          "name": "open-flags",
          "description": "File open flags",
          "flags": [
            {
              "name": "read-only",
              "value": 0,
              "description": "Read-only access"
            },
            {
              "name": "write-only",
              "value": 1,
              "description": "Write-only access"
            }
          ]
        }
      ],
      "records": [
        {
          "name": "file-stat",
          "description": "File status information",
          "fields": [
            {
              "name": "size",
              "type": "u64",
              "description": "File size in bytes"
            },
            {
              "name": "mode",
              "type": "u32",
              "description": "File mode"
            }
          ]
        }
      ],
      "metadata": {
        "created_at": "2026-02-24T00:00:00Z",
        "created_by": "WASM Agent"
      }
    }
  ]
}
```

---

## Usage Examples

### Example 1: File Operations

```rust
use clawos_kernel::filesystem;
use clawos_kernel::logging;

fn process_config_file() -> Result<(), Box<dyn std::error::Error>> {
    logging::info("Processing configuration file");

    // Open configuration file
    let fd = filesystem::open(
        "/clawfs/tools/mytool/config.json",
        open_flags::READ_ONLY,
        file_permissions::OWNER_READ
    )?;

    // Get file status
    let stat = fd.stat()?;
    logging::info(&format!("File size: {} bytes", stat.size));

    // Read file content
    let mut buffer = vec![0u8; stat.size as usize];
    let bytes_read = fd.read(&mut buffer, stat.size as u32)?;
    logging::info(&format!("Read {} bytes", bytes_read));

    // Close file
    fd.close()?;

    Ok(())
}
```

### Example 2: Network Operations

```rust
use clawos_kernel::network;
use clawos_kernel::logging;

fn fetch_url(url: &str) -> Result<String, Box<dyn std::error::Error>> {
    logging::info(&format!("Fetching URL: {}", url));

    // Parse URL
    let (host, port) = parse_url(url)?;

    // Create TCP socket
    let socket = network::socket(2, 1, 6)?;

    // Connect to server
    socket.connect(&host, port)?;

    // Send HTTP request
    let request = format!("GET / HTTP/1.1\r\nHost: {}\r\n\r\n", host);
    socket.send(request.as_bytes())?;

    // Receive response
    let mut buffer = vec![0u8; 4096];
    let bytes_received = socket.recv(&mut buffer, 4096)?;
    let response = String::from_utf8_lossy(&buffer[..bytes_received]).to_string();

    // Close socket
    socket.close()?;

    Ok(response)
}
```

### Example 3: Cgroup Resource Management

```rust
use clawos_kernel::cgroup;
use clawos_kernel::system;
use clawos_kernel::logging;

fn setup_cgroup_limits() -> Result<(), Box<dyn std::error::Error>> {
    logging::info("Setting up cgroup resource limits");

    // Create cgroup
    let cg = cgroup::create("mytool", "")?;

    // Set memory limit (64MB)
    cg.set_memory_limit(64 * 1024 * 1024)?;
    logging::info("Memory limit set to 64MB");

    // Set CPU limit (10% of 1 CPU)
    cg.set_cpu_limit(100000, 1000000)?;
    logging::info("CPU limit set to 10%");

    // Set PID limit (16 processes)
    cg.set_pid_limit(16)?;
    logging::info("PID limit set to 16");

    // Add current process to cgroup
    let pid = system::get_pid()?;
    cgroup::add_process("/sys/fs/cgroup/clawos/mytool", pid)?;
    logging::info(&format!("Added process {} to cgroup", pid));

    // Close cgroup handle
    cg.close()?;

    Ok(())
}
```

### Example 4: Shared Memory

```rust
use clawos_kernel::memory;
use clawos_kernel::logging;

fn shared_memory_example() -> Result<(), Box<dyn std::error::Error>> {
    logging::info("Shared memory example");

    // Allocate shared memory region (1MB)
    let mem = memory::allocate(1024 * 1024, "example-buffer")?;
    logging::info("Allocated 1MB shared memory region");

    // Write data to shared memory
    let data = b"Hello, Shared Memory!";
    mem.write(0, data)?;
    logging::info(&format!("Wrote {} bytes to shared memory", data.len()));

    // Read data from shared memory
    let mut buffer = vec![0u8; data.len()];
    mem.read(0, &mut buffer, data.len() as u32)?;
    let read_data = String::from_utf8_lossy(&buffer);
    logging::info(&format!("Read from shared memory: {}", read_data));

    // Sync shared memory
    mem.sync()?;
    logging::info("Synced shared memory to disk");

    // Close shared memory
    mem.close()?;
    logging::info("Closed shared memory region");

    Ok(())
}
```

### Example 5: Error Handling

```rust
use clawos_kernel::filesystem;
use clawos_kernel::logging;
use clawos_kernel::errno;

fn robust_file_operation() -> Result<(), Box<dyn std::error::Error>> {
    logging::info("Starting robust file operation");

    // Attempt to open file
    let fd = match filesystem::open(
        "/clawfs/tools/mytool/data.txt",
        open_flags::READ_ONLY,
        file_permissions::OWNER_READ
    ) {
        Ok(fd) => {
            logging::info("File opened successfully");
            fd
        }
        Err(errno::enoent) => {
            logging::error("File not found");
            return Err("File not found".into());
        }
        Err(errno::eacces) => {
            logging::error("Permission denied");
            return Err("Permission denied".into());
        }
        Err(e) => {
            logging::error(&format!("Unexpected error: {:?}", e));
            return Err("Unexpected error".into());
        }
    };

    // Read file with error handling
    let mut buffer = vec![0u8; 4096];
    match fd.read(&mut buffer, 4096) {
        Ok(bytes_read) => {
            logging::info(&format!("Read {} bytes", bytes_read));
        }
        Err(errno::eio) => {
            logging::error("I/O error while reading");
            fd.close()?;
            return Err("I/O error".into());
        }
        Err(e) => {
            logging::error(&format!("Read error: {:?}", e));
            fd.close()?;
            return Err("Read error".into());
        }
    }

    // Ensure file is closed even on error
    fd.close()?;
    logging::info("File closed successfully");

    Ok(())
}
```

---

## Appendices

### Appendix A: Complete Error Code Reference

See the `errno` enum in the WIT interface definition for the complete list of error codes.

### Appendix B: Resource Type Reference

See the "Resource Types" section for a complete reference of all resource types.

### Appendix C: Host Function Reference

See the "Host Functions" section for a complete reference of all host functions.

### Appendix D: Security Considerations

#### Threat Model

See the "Security Boundary" section for a detailed threat model and mitigation strategies.

#### Audit Logging

All WIT host function calls are logged via eBPF LSM hooks for audit purposes:

```
timestamp: 2026-02-24T12:34:56.789Z
component: mytool
function: filesystem::open
path: /clawfs/tools/mytool/config.json
result: success
duration: 1.234ms
```

#### Resource Limits

Default resource limits per WASM component:

| Resource         | Limit | Description                   |
| ---------------- | ----- | ----------------------------- |
| Memory           | 64MB  | Maximum heap size             |
| CPU              | 10%   | Maximum CPU usage             |
| File descriptors | 64    | Maximum open files            |
| Sockets          | 8     | Maximum open sockets          |
| Cgroups          | 4     | Maximum cgroups               |
| Memory regions   | 16    | Maximum shared memory regions |

### Appendix E: Performance Considerations

#### Overhead Analysis

| Operation       | Overhead | Notes                       |
| --------------- | -------- | --------------------------- |
| File open       | ~10μs    | Includes permission check   |
| File read       | ~1μs/KB  | Linear scaling              |
| Socket connect  | ~100μs   | Includes DNS resolution     |
| Memory allocate | ~5μs     | Includes zeroing            |
| Cgroup create   | ~50μs    | Includes directory creation |

#### Optimization Tips

1. **Reuse resources**: Keep file descriptors and sockets open when possible
2. **Batch operations**: Combine multiple small reads/writes into larger ones
3. **Use shared memory**: For large data transfers between components
4. **Cache results**: Cache frequently accessed data
5. **Avoid syscalls**: Minimize the number of host function calls

### Appendix F: Troubleshooting

#### Common Issues

| Issue                 | Cause                   | Solution                                   |
| --------------------- | ----------------------- | ------------------------------------------ |
| `enoent`              | File not found          | Check file path and permissions            |
| `eacces`              | Permission denied       | Check security policy and AppArmor profile |
| `emfile`              | Too many open files     | Close unused file descriptors              |
| `enomem`              | Out of memory           | Reduce memory usage or increase limit      |
| `wasm-resource-limit` | Resource limit exceeded | Check cgroup limits                        |

#### Debug Mode

Enable debug logging for detailed information:

```rust
use clawos_kernel::logging;

logging::debug("Debug message");
```

### Appendix G: Version Compatibility

| WIT Version | wasmtime | Rust  | Status     |
| ----------- | -------- | ----- | ---------- |
| 2.0.0       | 27+      | 1.85+ | Current    |
| 1.0.0       | 20+      | 1.70+ | Deprecated |

### Appendix H: References

1. [WebAssembly Component Model](https://github.com/WebAssembly/component-model)
2. [WIT Interface Types](https://github.com/WebAssembly/wit-bindgen)
3. [wasmtime Documentation](https://docs.wasmtime.dev/)
4. [Linux Kernel 6.6 Documentation](https://www.kernel.org/doc/html/latest/)
5. [eBPF Documentation](https://ebpf.io/)
6. [cgroup v2 Documentation](https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v2.html)
7. [seccomp Documentation](https://www.kernel.org/doc/html/latest/userspace-api/seccomp.html)
8. [AppArmor Documentation](https://gitlab.com/apparmor/apparmor/-/wikis/home)

---

## Document Status

**Status:** FROZEN
**SHA256 Signature:** PLACEHOLDER_SHA256_SIGNATURE
**Modification Authority:** WASM Agent
**Approval Required:** Yes
**Vault Storage Required:** Yes

### Change History

| Version | Date       | Author     | Changes                           |
| ------- | ---------- | ---------- | --------------------------------- |
| 1.0.0   | 2026-02-24 | WASM Agent | Initial ClawOS v1.0 specification |

### Sign-Off

This document has been reviewed and approved by:

- **WASM Agent**: [Signature]
- **Security Agent**: [Signature]
- **Core Dev Agent**: [Signature]

---

**End of Document**
