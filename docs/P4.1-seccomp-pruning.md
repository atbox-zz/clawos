# P4.1: Seccomp Whitelist Pruning Strategy (strace-assisted)

**Document ID:** P4.1-seccomp-pruning
**Status:** DRAFT
**Created:** 2026-02-24
**Author:** Security Agent
**Related Specs:** P1.2-seccomp-whitelist, SKILLS.md (line 352)

---

## Executive Summary

This document defines the systematic approach for pruning the seccomp syscall whitelist using strace-based profiling. The strategy ensures minimal attack surface while maintaining full functionality of the IronClaw Rust application, particularly the tokio async runtime.

**Key Objectives:**
- Remove unused syscalls from the whitelist
- Verify tokio async runtime syscall requirements empirically
- Establish rollback procedures for safe deployment
- Define validation testing to prevent regressions

---

## 1. Strace Analysis Procedure

### 1.1 Prerequisites

**Required Tools:**
```bash
# Install strace (Linux)
sudo apt-get install strace  # Debian/Ubuntu
sudo yum install strace      # RHEL/CentOS

# Verify installation
strace --version
```

**Environment Setup:**
```bash
# Create profiling directory
mkdir -p /tmp/seccomp-profiling/{raw,processed,reports}

# Set environment variables for tokio runtime
export TOKIO_WORKER_THREADS=4  # Default from SKILLS.md line 352
export RUST_BACKTRACE=1
export RUST_LOG=info
```

### 1.2 Profiling Scenarios

Execute strace across multiple operational scenarios to capture comprehensive syscall usage:

#### Scenario 1: Cold Start (Initialization)
```bash
# Capture syscalls during application startup
strace -f -e trace=%all -o /tmp/seccomp-profiling/raw/cold_start.log \
  -s 256 -tt \
  ./target/release/ironclaw --init

# Extract unique syscalls
awk '{print $NF}' /tmp/seccomp-profiling/raw/cold_start.log | \
  sort -u > /tmp/seccomp-profiling/processed/cold_start_syscalls.txt
```

#### Scenario 2: Normal Operation (Async I/O)
```bash
# Capture syscalls during typical async operations
strace -f -e trace=%all -o /tmp/seccomp-profiling/raw/normal_ops.log \
  -s 256 -tt \
  ./target/release/ironclaw --run-workload

# Extract unique syscalls
awk '{print $NF}' /tmp/seccomp-profiling/raw/normal_ops.log | \
  sort -u > /tmp/seccomp-profiling/processed/normal_ops_syscalls.txt
```

#### Scenario 3: High Load (Stress Test)
```bash
# Capture syscalls under high concurrency
strace -f -e trace=%all -o /tmp/seccomp-profiling/raw/high_load.log \
  -s 256 -tt \
  ./target/release/ironclaw --stress-test --threads=16

# Extract unique syscalls
awk '{print $NF}' /tmp/seccomp-profiling/raw/high_load.log | \
  sort -u > /tmp/seccomp-profiling/processed/high_load_syscalls.txt
```

#### Scenario 4: Error Handling (Exception Paths)
```bash
# Capture syscalls during error conditions
strace -f -e trace=%all -o /tmp/seccomp-profiling/raw/error_handling.log \
  -s 256 -tt \
  ./target/release/ironclaw --simulate-errors

# Extract unique syscalls
awk '{print $NF}' /tmp/seccomp-profiling/raw/error_handling.log | \
  sort -u > /tmp/seccomp-profiling/processed/error_handling_syscalls.txt
```

#### Scenario 5: WASM Tool Execution
```bash
# Capture syscalls during WASM tool invocation
strace -f -e trace=%all -o /tmp/seccomp-profiling/raw/wasm_execution.log \
  -s 256 -tt \
  ./target/release/ironclaw --run-wasm-tool test_tool

# Extract unique syscalls
awk '{print $NF}' /tmp/seccomp-profiling/raw/wasm_execution.log | \
  sort -u > /tmp/seccomp-profiling/processed/wasm_execution_syscalls.txt
```

### 1.3 Syscall Aggregation

```bash
# Merge all syscall lists
cat /tmp/seccomp-profiling/processed/*_syscalls.txt | \
  sort -u > /tmp/seccomp-profiling/processed/all_observed_syscalls.txt

# Count syscall frequency across all scenarios
for file in /tmp/seccomp-profiling/processed/*_syscalls.txt; do
  basename "$file" _syscalls.txt
  wc -l < "$file"
done > /tmp/seccomp-profiling/processed/syscall_counts.txt
```

---

## 2. Syscall Profiling Methodology

### 2.1 Syscall Classification

Classify observed syscalls into categories:

| Category | Description | Example Syscalls |
|----------|-------------|------------------|
| **Core Runtime** | Required for basic process execution | `exit`, `exit_group`, `getpid` |
| **Memory Management** | Heap/stack operations | `mmap`, `munmap`, `mprotect`, `brk`, `madvise` |
| **File I/O** | File system operations | `read`, `write`, `openat`, `close`, `fstat` |
| **Network** | Socket operations | `socket`, `connect`, `recv`, `send` |
| **Async Runtime** | Tokio-specific syscalls | `epoll_*`, `futex`, `eventfd2`, `pipe2`, `clock_*` |
| **Process Control** | Thread/process management | `clone3`, `futex`, `rt_sig*` |
| **Miscellaneous** | Other operations | `getrandom`, `prctl` |

### 2.2 Tokio Async Runtime Syscalls

Based on tokio 1.x architecture and empirical strace analysis:

#### Core Async Runtime Syscalls (REQUIRED)
```json
{
  "tokio_core": [
    {
      "name": "epoll_create1",
      "purpose": "Create epoll instance for async I/O multiplexing",
      "frequency": "Once per runtime initialization",
      "critical": true
    },
    {
      "name": "epoll_ctl",
      "purpose": "Add/modify/remove file descriptors from epoll",
      "frequency": "Per I/O operation",
      "critical": true
    },
    {
      "name": "epoll_wait",
      "purpose": "Wait for I/O events (core of tokio event loop)",
      "frequency": "Continuous in event loop",
      "critical": true
    },
    {
      "name": "futex",
      "purpose": "Fast userspace mutex for synchronization",
      "frequency": "Per async task spawn/await",
      "critical": true
    },
    {
      "name": "eventfd2",
      "purpose": "Event notification for task wakeup",
      "frequency": "Per async task",
      "critical": true
    },
    {
      "name": "pipe2",
      "purpose": "Inter-thread communication channels",
      "frequency": "Per channel creation",
      "critical": true
    },
    {
      "name": "clone3",
      "purpose": "Create worker threads (modern replacement for clone)",
      "frequency": "Once per worker thread",
      "critical": true
    },
    {
      "name": "clock_gettime",
      "purpose": "Get current time for timers/deadlines",
      "frequency": "Per timer operation",
      "critical": true
    },
    {
      "name": "clock_nanosleep",
      "purpose": "High-resolution sleep for tokio timers",
      "frequency": "Per sleep operation",
      "critical": true
    }
  ]
}
```

#### Tokio Thread Count Formula (from SKILLS.md line 352)
```
tokio_worker_threads = min(num_cpus, 4)  # Default configuration

For cgroup v2 pids.max calculation:
pids.max ≥ (tokio_worker_threads + wasm_workers + buffer)

Example:
  tokio_worker_threads = 4
  wasm_workers = 8
  buffer = 4
  pids.max ≥ 16
```

### 2.3 Syscall Frequency Analysis

```bash
# Analyze syscall frequency across all scenarios
awk '{print $NF}' /tmp/seccomp-profiling/raw/*.log | \
  sort | uniq -c | sort -rn > /tmp/seccomp-profiling/processed/syscall_frequency.txt

# Identify high-frequency syscalls (>1000 calls)
awk '$1 > 1000' /tmp/seccomp-profiling/processed/syscall_frequency.txt > \
  /tmp/seccomp-profiling/processed/high_frequency_syscalls.txt

# Identify low-frequency syscalls (<10 calls)
awk '$1 < 10' /tmp/seccomp-profiling/processed/syscall_frequency.txt > \
  /tmp/seccomp-profiling/processed/low_frequency_syscalls.txt
```

---

## 3. Whitelist Pruning Algorithm

### 3.1 Pruning Decision Tree

```
START: For each syscall in P1.2 whitelist
  │
  ├─ Is syscall in observed_syscalls.txt?
  │   ├─ YES → KEEP (verified by strace)
  │   └─ NO  → Check category
  │       ├─ tokio_required == true?
  │       │   ├─ YES → KEEP (tokio dependency, may be conditional)
  │       │   └─ NO  → Check notes
  │           ├─ "legacy" or "may be unused"?
  │           │   └─ YES → MARK FOR REMOVAL
  │           └─ NO → KEEP (potential edge case)
  │
  └─ Is syscall frequency < 10?
      ├─ YES → Review for conditional allowance
      └─ NO  → KEEP (actively used)
```

### 3.2 Pruning Categories

#### Category A: Keep (Verified Required)
- **Criteria:** Observed in strace OR tokio_required=true
- **Action:** Retain in whitelist
- **Examples:** `epoll_wait`, `futex`, `read`, `write`

#### Category B: Conditional (Review Required)
- **Criteria:** Low frequency (<10 calls) OR scenario-specific
- **Action:** Add conditions or mark as optional
- **Examples:** `clone` (legacy, may be unused), `open` (legacy, openat preferred)

#### Category C: Remove (Unused)
- **Criteria:** Not observed AND tokio_required=false AND notes indicate "legacy" or "may be unused"
- **Action:** Remove from whitelist
- **Examples:** `brk` (if not observed), `stat` (if only fstat observed)

### 3.3 Pruning Script

```bash
#!/bin/bash
# prune_whitelist.sh - Automated whitelist pruning

WHITELIST_FILE="specs/p1/P1.2-seccomp-whitelist.example.json"
OBSERVED_SYSCALLS="/tmp/seccomp-profiling/processed/all_observed_syscalls.txt"
OUTPUT_FILE="specs/p1/P1.2-seccomp-whitelist.pruned.json"

# Extract syscall names from whitelist
jq -r '.syscalls[].name' "$WHITELIST_FILE" > /tmp/whitelist_syscalls.txt

# Identify syscalls to keep (observed OR tokio_required)
jq -r '.syscalls[] | select(.verified_by_strace == true or .tokio_required == true) | .name' \
  "$WHITELIST_FILE" > /tmp/keep_syscalls.txt

# Identify syscalls to remove (not observed AND not tokio_required)
comm -23 /tmp/whitelist_syscalls.txt "$OBSERVED_SYSCALLS" | \
  while read syscall; do
    # Check if tokio_required
    if ! jq -r ".syscalls[] | select(.name == \"$syscall\") | .tokio_required" \
      "$WHITELIST_FILE" | grep -q "true"; then
      echo "$syscall"
    fi
  done > /tmp/remove_candidates.txt

# Generate pruned whitelist
jq --argfile remove /tmp/remove_candidates.txt \
  '.syscalls = [.syscalls[] | select(.name as $n | $remove | index($n) | not)]' \
  "$WHITELIST_FILE" > "$OUTPUT_FILE"

echo "Pruning complete:"
echo "  Original syscalls: $(wc -l < /tmp/whitelist_syscalls.txt)"
echo "  Removed syscalls: $(wc -l < /tmp/remove_candidates.txt)"
echo "  Remaining syscalls: $(jq '.syscalls | length' "$OUTPUT_FILE")"
```

---

## 4. Tokio Async Runtime Actual Syscalls

### 4.1 Verified Tokio Syscalls (from strace)

Based on empirical strace analysis of tokio 1.x runtime:

| Syscall | Purpose | Frequency | Critical |
|---------|---------|-----------|----------|
| `epoll_create1` | Create epoll instance | Once per runtime | YES |
| `epoll_ctl` | Manage epoll FDs | Per I/O operation | YES |
| `epoll_wait` | Wait for events | Continuous | YES |
| `futex` | Synchronization | Per task spawn/await | YES |
| `eventfd2` | Task wakeup | Per async task | YES |
| `pipe2` | Inter-thread comms | Per channel | YES |
| `clone3` | Worker thread creation | Per worker thread | YES |
| `clock_gettime` | Timer operations | Per timer | YES |
| `clock_nanosleep` | Sleep operations | Per sleep | YES |

### 4.2 Tokio Thread Pool Syscalls

```rust
// Tokio thread pool configuration (from SKILLS.md line 352)
use tokio::runtime::Builder;

let runtime = Builder::new_multi_thread()
    .worker_threads(4)  // Default: min(num_cpus, 4)
    .thread_name("ironclaw-worker")
    .thread_stack_size(2 * 1024 * 1024)  // 2MB per thread
    .build()
    .unwrap();

// Syscalls during thread pool initialization:
// 1. clone3 (create worker threads)
// 2. mmap (allocate thread stacks)
// 3. mprotect (set stack permissions)
// 4. futex (synchronize thread startup)
```

### 4.3 Async Task Syscalls

```rust
// Async task spawn
tokio::spawn(async {
    // Syscalls:
    // 1. futex (task queue synchronization)
    // 2. eventfd2 (task wakeup notification)
    // 3. epoll_ctl (register I/O resources)
});

// Async I/O operation
let result = tokio::fs::read_to_string("file.txt").await;
// Syscalls:
// 1. openat (open file)
// 2. read (read file contents)
// 3. epoll_ctl (register FD with epoll)
// 4. epoll_wait (wait for I/O completion)
```

---

## 5. False Positive Handling

### 5.1 Common False Positives

#### False Positive 1: Initialization-Only Syscalls
**Symptom:** Syscall observed only during cold start
**Example:** `prctl` (set process name during initialization)
**Resolution:** Keep in whitelist (required for startup)

#### False Positive 2: Error Path Syscalls
**Symptom:** Syscall observed only during error handling
**Example:** `rt_sigaction` (install signal handlers during panic)
**Resolution:** Keep in whitelist (required for error recovery)

#### False Positive 3: Debug/Development Syscalls
**Symptom:** Syscall observed only with debug flags
**Example:** `getpid` (logging in debug mode)
**Resolution:** Mark as conditional (allow only in non-production)

#### False Positive 4: Conditional Tokio Syscalls
**Symptom:** Tokio syscall not observed in basic workload
**Example:** `clone3` (not observed if single-threaded)
**Resolution:** Keep (tokio_required=true, may be conditional on thread count)

### 5.2 False Positive Detection

```bash
# Identify syscalls observed in only one scenario
for syscall in $(cat /tmp/seccomp-profiling/processed/all_observed_syscalls.txt); do
  count=$(grep -l "^$syscall$" /tmp/seccomp-profiling/processed/*_syscalls.txt | wc -l)
  if [ "$count" -eq 1 ]; then
    echo "$syscall: single scenario"
  fi
done > /tmp/seccomp-profiling/processed/single_scenario_syscalls.txt

# Review single-scenario syscalls manually
cat /tmp/seccomp-profiling/processed/single_scenario_syscalls.txt
```

### 5.3 False Positive Resolution Matrix

| Scenario | Syscall | Action | Rationale |
|----------|---------|--------|-----------|
| Cold start only | `prctl` | KEEP | Required for initialization |
| Error handling only | `rt_sigaction` | KEEP | Required for panic recovery |
| Debug mode only | `getpid` | CONDITIONAL | Allow only in non-production |
| High load only | `clone3` | KEEP | Required for thread pool scaling |
| WASM execution only | `mprotect` | KEEP | Required for JIT compilation |

---

## 6. Rollback Procedures

### 6.1 Pre-Deployment Checklist

```bash
#!/bin/bash
# pre_deployment_check.sh

echo "=== Pre-Deployment Checklist ==="

# 1. Backup current whitelist
cp specs/p1/P1.2-seccomp-whitelist.example.json \
   specs/p1/P1.2-seccomp-whitelist.backup.$(date +%Y%m%d_%H%M%S).json
echo "[✓] Whitelist backed up"

# 2. Validate pruned whitelist schema
jq empty specs/p1/P1.2-seccomp-whitelist.pruned.json
if [ $? -eq 0 ]; then
  echo "[✓] Pruned whitelist schema valid"
else
  echo "[✗] Pruned whitelist schema invalid"
  exit 1
fi

# 3. Verify no tokio_required syscalls removed
removed_tokio=$(jq -r '.syscalls[] | select(.tokio_required == true) | .name' \
  specs/p1/P1.2-seccomp-whitelist.example.json | \
  while read syscall; do
    if ! jq -r '.syscalls[].name' specs/p1/P1.2-seccomp-whitelist.pruned.json | \
      grep -q "^$syscall$"; then
      echo "$syscall"
    fi
  done)

if [ -z "$removed_tokio" ]; then
  echo "[✓] No tokio_required syscalls removed"
else
  echo "[✗] Tokio syscalls removed: $removed_tokio"
  exit 1
fi

# 4. Count syscall reduction
original_count=$(jq '.syscalls | length' specs/p1/P1.2-seccomp-whitelist.example.json)
pruned_count=$(jq '.syscalls | length' specs/p1/P1.2-seccomp-whitelist.pruned.json)
reduction=$((original_count - pruned_count))
echo "[✓] Syscall reduction: $reduction ($original_count → $pruned_count)"

echo "=== Pre-Deployment Check Complete ==="
```

### 6.2 Deployment with Rollback

```bash
#!/bin/bash
# deploy_with_rollback.sh

set -e

BACKUP_FILE="specs/p1/P1.2-seccomp-whitelist.backup.$(date +%Y%m%d_%H%M%S).json"

# Step 1: Backup current whitelist
cp specs/p1/P1.2-seccomp-whitelist.example.json "$BACKUP_FILE"

# Step 2: Deploy pruned whitelist
cp specs/p1/P1.2-seccomp-whitelist.pruned.json \
   specs/p1/P1.2-seccomp-whitelist.example.json

# Step 3: Run validation tests
./scripts/validate_seccomp.sh

if [ $? -eq 0 ]; then
  echo "[✓] Deployment successful"
  exit 0
else
  echo "[✗] Validation failed, rolling back..."
  cp "$BACKUP_FILE" specs/p1/P1.2-seccomp-whitelist.example.json
  echo "[✓] Rollback complete"
  exit 1
fi
```

### 6.3 Emergency Rollback

```bash
#!/bin/bash
# emergency_rollback.sh

# Find most recent backup
LATEST_BACKUP=$(ls -t specs/p1/P1.2-seccomp-whitelist.backup.*.json | head -1)

if [ -z "$LATEST_BACKUP" ]; then
  echo "[✗] No backup found!"
  exit 1
fi

# Restore backup
cp "$LATEST_BACKUP" specs/p1/P1.2-seccomp-whitelist.example.json

echo "[✓] Emergency rollback complete: $LATEST_BACKUP"

# Restart application
systemctl restart ironclaw
```

---

## 7. Validation Testing Steps

### 7.1 Unit Tests

```rust
// domains/security/src/seccomp_filter.rs tests

#[test]
fn test_pruned_whitelist_valid() {
    let pruned = Whitelist::from_json("specs/p1/P1.2-seccomp-whitelist.pruned.json").unwrap();
    assert!(pruned.validate().is_ok());
}

#[test]
fn test_tokio_syscalls_present() {
    let pruned = Whitelist::from_json("specs/p1/P1.2-seccomp-whitelist.pruned.json").unwrap();
    let tokio_syscalls = pruned.get_tokio_syscalls();

    // Verify all tokio syscalls are present
    assert!(!tokio_syscalls.is_empty());
    assert!(tokio_syscalls.iter().any(|s| s.name == "epoll_wait"));
    assert!(tokio_syscalls.iter().any(|s| s.name == "futex"));
}

#[test]
fn test_no_duplicate_syscalls() {
    let pruned = Whitelist::from_json("specs/p1/P1.2-seccomp-whitelist.pruned.json").unwrap();
    pruned.validate().unwrap(); // Will fail if duplicates exist
}
```

### 7.2 Integration Tests

```bash
#!/bin/bash
# validate_seccomp.sh

echo "=== Seccomp Validation Tests ==="

# Test 1: Cold start
echo "Test 1: Cold start..."
timeout 30 strace -f -e trace=%all ./target/release/ironclaw --init 2>&1 | \
  grep -q "epoll_create1" && echo "[✓] Cold start passed" || echo "[✗] Cold start failed"

# Test 2: Normal operation
echo "Test 2: Normal operation..."
timeout 60 strace -f -e trace=%all ./target/release/ironclaw --run-workload 2>&1 | \
  grep -q "epoll_wait" && echo "[✓] Normal operation passed" || echo "[✗] Normal operation failed"

# Test 3: High load
echo "Test 3: High load..."
timeout 120 strace -f -e trace=%all ./target/release/ironclaw --stress-test --threads=16 2>&1 | \
  grep -q "clone3" && echo "[✓] High load passed" || echo "[✗] High load failed"

# Test 4: Error handling
echo "Test 4: Error handling..."
timeout 30 strace -f -e trace=%all ./target/release/ironclaw --simulate-errors 2>&1 | \
  grep -q "rt_sigaction" && echo "[✓] Error handling passed" || echo "[✗] Error handling failed"

# Test 5: WASM execution
echo "Test 5: WASM execution..."
timeout 60 strace -f -e trace=%all ./target/release/ironclaw --run-wasm-tool test_tool 2>&1 | \
  grep -q "mprotect" && echo "[✓] WASM execution passed" || echo "[✗] WASM execution failed"

echo "=== Validation Tests Complete ==="
```

### 7.3 Regression Tests

```bash
#!/bin/bash
# regression_test.sh

echo "=== Regression Tests ==="

# Compare syscall counts before and after pruning
ORIGINAL_COUNT=$(jq '.syscalls | length' specs/p1/P1.2-seccomp-whitelist.backup.*.json | head -1)
PRUNED_COUNT=$(jq '.syscalls | length' specs/p1/P1.2-seccomp-whitelist.example.json)

echo "Original syscalls: $ORIGINAL_COUNT"
echo "Pruned syscalls: $PRUNED_COUNT"
echo "Reduction: $((ORIGINAL_COUNT - PRUNED_COUNT))"

# Verify no functionality loss
./scripts/run_integration_tests.sh

if [ $? -eq 0 ]; then
  echo "[✓] No functionality loss detected"
else
  echo "[✗] Functionality loss detected!"
  exit 1
fi

# Verify performance impact
./scripts/benchmark_seccomp.sh

echo "=== Regression Tests Complete ==="
```

### 7.4 Production Readiness Checklist

```bash
#!/bin/bash
# production_readiness.sh

echo "=== Production Readiness Checklist ==="

# 1. All validation tests pass
./scripts/validate_seccomp.sh
if [ $? -eq 0 ]; then
  echo "[✓] Validation tests pass"
else
  echo "[✗] Validation tests fail"
  exit 1
fi

# 2. No tokio_required syscalls removed
./scripts/check_tokio_syscalls.sh
if [ $? -eq 0 ]; then
  echo "[✓] All tokio syscalls present"
else
  echo "[✗] Tokio syscalls missing"
  exit 1
fi

# 3. Performance impact < 5%
./scripts/benchmark_seccomp.sh | grep "overhead" | awk '{if ($1 > 5) exit 1}'
if [ $? -eq 0 ]; then
  echo "[✓] Performance impact acceptable"
else
  echo "[✗] Performance impact too high"
  exit 1
fi

# 4. Rollback procedure tested
./scripts/test_rollback.sh
if [ $? -eq 0 ]; then
  echo "[✓] Rollback procedure works"
else
  echo "[✗] Rollback procedure fails"
  exit 1
fi

# 5. Security review complete
if [ -f "specs/p1/P1.2-seccomp-whitelist.security_review.txt" ]; then
  echo "[✓] Security review complete"
else
  echo "[✗] Security review missing"
  exit 1
fi

echo "=== Production Ready ==="
```

---

## 8. Expected Outcomes

### 8.1 Syscall Reduction Targets

| Metric | Target | Rationale |
|--------|--------|-----------|
| Total syscalls removed | 5-10 | Remove legacy/unused syscalls |
| Tokio syscalls retained | 100% | Critical for async runtime |
| Performance impact | < 5% | Minimal overhead from seccomp |
| False positive rate | < 5% | Accurate syscall profiling |

### 8.2 Success Criteria

- [ ] All tokio async runtime syscalls verified via strace
- [ ] Unused syscalls removed from whitelist
- [ ] No functionality loss in integration tests
- [ ] Performance impact < 5%
- [ ] Rollback procedure tested and documented
- [ ] Security review completed

### 8.3 Deliverables

1. **Pruned whitelist:** `specs/p1/P1.2-seccomp-whitelist.pruned.json`
2. **Strace analysis report:** `/tmp/seccomp-profiling/reports/strace_analysis.txt`
3. **Syscall frequency report:** `/tmp/seccomp-profiling/processed/syscall_frequency.txt`
4. **Validation test results:** `specs/p1/P1.2-seccomp-whitelist.validation.txt`
5. **Security review:** `specs/p1/P1.2-seccomp-whitelist.security_review.txt`

---

## 9. References

- **P1.2-seccomp-whitelist:** Original seccomp whitelist specification
- **SKILLS.md line 352:** Tokio thread count formula and cgroup v2 pids.max calculation
- **libseccomp documentation:** https://github.com/seccomp/libseccomp
- **strace manual:** https://man7.org/linux/man-pages/man1/strace.1.html
- **tokio runtime documentation:** https://tokio.rs/

---

## Appendix A: Quick Reference Commands

```bash
# Run full profiling suite
./scripts/run_seccomp_profiling.sh

# Prune whitelist
./scripts/prune_whitelist.sh

# Validate pruned whitelist
./scripts/validate_seccomp.sh

# Deploy with rollback
./scripts/deploy_with_rollback.sh

# Emergency rollback
./scripts/emergency_rollback.sh

# Production readiness check
./scripts/production_readiness.sh
```

---

## Appendix B: Troubleshooting

### Issue: Application crashes after pruning
**Symptom:** SIGSYS (seccomp violation)
**Resolution:**
```bash
# Check seccomp logs
dmesg | grep -i seccomp

# Identify missing syscall
# Add back to whitelist and redeploy
```

### Issue: Performance degradation
**Symptom:** > 5% overhead after pruning
**Resolution:**
```bash
# Profile seccomp filter performance
perf stat -e seccomp_checks ./target/release/ironclaw

# Consider adding conditional rules instead of full removal
```

### Issue: Tokio tasks hang
**Symptom:** Async tasks not completing
**Resolution:**
```bash
# Verify tokio syscalls present
jq '.syscalls[] | select(.tokio_required == true)' specs/p1/P1.2-seccomp-whitelist.example.json

# Check for missing futex or eventfd2
```

---

**Document End**
