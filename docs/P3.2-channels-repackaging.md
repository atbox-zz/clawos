# P3.2: Channels Repackaging Specification

**Document ID:** P3.2
**Version:** 1.0.0
**Status:** DRAFT
**Created:** 2026-02-24
**Created By:** WASM Agent
**SHA256 Signature:** PLACEHOLDER_SHA256_SIGNATURE

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Architecture Overview](#architecture-overview)
3. [Telegram Channel WASM Component](#telegram-channel-wasm-component)
4. [Slack Channel WASM Component](#slack-channel-wasm-component)
5. [WIT Interface Definitions](#wit-interface-definitions)
6. [cargo-component Build Configuration](#cargo-component-build-configuration)
7. [API Key and Secrets Handling](#api-key-and-secrets-handling)
8. [Authentication Strategies](#authentication-strategies)
9. [WASM Bridge Integration](#wasm-bridge-integration)
10. [Security Considerations](#security-considerations)
11. [Testing and Validation](#testing-and-validation)
12. [Migration Strategy](#migration-strategy)
13. [Appendices](#appendices)

---

## Executive Summary

This document defines the repackaging specification for IronClaw's `channels-src` (Telegram and Slack) into ClawOS WASM components. The specification ensures secure, sandboxed execution of channel communication tools while maintaining strict isolation through the ClawOS multi-layer security architecture.

### Key Design Principles

1. **Zero-Trust Security**: All channel components are untrusted by default
2. **Capability-Based Access**: Network resources accessed through WIT interfaces only
3. **Explicit Error Handling**: All operations return explicit error codes
4. **Memory Safety**: WASM sandbox prevents direct kernel/network access
5. **Auditability**: All channel operations logged via eBPF monitoring

### Scope

This specification covers:
- Telegram channel WASM component structure and implementation
- Slack channel WASM component structure and implementation
- WIT interfaces for SSE (Server-Sent Events), WebSocket, and message handling
- cargo-component build configuration for channel WASM binaries
- API key and secrets handling via ClawFS Vault
- Authentication strategies for Telegram Bot API and Slack Web API
- Integration with WASM Kernel Bridge (P1.1)
- Security considerations and threat mitigation

---

## Architecture Overview

### Channel Component Architecture

```
┌─────────────────────────────────────────────────────────────┐
│ WASM Component (Channel Tool)                               │
│ - Memory: 32MB (configurable)                               │
│ - CPU: 0.5 vCPU (cgroup limited)                            │
│ - Network: Proxied through WIT host functions               │
│ - Secrets: Read from ClawFS Vault via WIT                   │
└────────────────────┬────────────────────────────────────────┘
                     │ WIT Interface (wasm32 ABI)
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ WASM Kernel Bridge (clawos-wasm-bridge)                     │
│ - wasmtime runtime                                          │
│ - WIT host function implementations                         │
│ - Network proxy (SSE/WebSocket)                             │
│ - Secrets access (ClawFS Vault)                             │
└────────────────────┬────────────────────────────────────────┘
                     │ POSIX Syscalls
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ Linux Kernel 6.6 LTS                                        │
│ - eBPF LSM hooks (monitoring)                               │
│ - AppArmor profiles (enforcement)                           │
│ - Network namespace isolation                               │
└─────────────────────────────────────────────────────────────┘
```

### Channel Communication Flow

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│  Agent Loop     │───> │  Channel WASM   │────>│  External API   │
│  (Orchestrator) │     │  (Telegram/     │     │  (Telegram/     │
│                 │     │   Slack)        │     │   Slack)        │
└─────────────────┘     └─────────────────┘     └─────────────────┘
         │                       │                       │
         │ IPC (P1.7)            │ WIT (P1.1)            │ HTTPS/WSS
         │                       │                       │
         ▼                       ▼                       ▼
   ┌─────────┐            ┌──────────┐            ┌──────────┐
   │ Router  │            │ WASM     │            │ Internet │
   │         │            │ Bridge   │            │          │
   └─────────┘            └──────────┘            └──────────┘
```

### Component Placement in ClawFS

```
/clawfs/
├── tools/
│   ├── binaries/
│   │   ├── telegram-channel-v1.0.0.wasm
│   │   └── slack-channel-v1.0.0.wasm
│   ├── configs/
│   │   ├── tool-telegram-channel.json
│   │   └── tool-slack-channel.json
│   └── manifests/
│       ├── telegram-channel-manifest.json
│       └── slack-channel-manifest.json
└── vault/
    ├── secrets/
    │   ├── telegram-bot-token.enc
    │   └── slack-bot-token.enc
    └── keys/
        └── vault-master-key.enc
```

---

## Telegram Channel WASM Component

### Component Structure

```
channels-src/telegram/
├── Cargo.toml
├── wit/
│   └── telegram-channel.wit
├── src/
│   ├── lib.rs
│   ├── api.rs
│   ├── bot.rs
│   ├── handlers.rs
│   └── error.rs
└── tests/
    └── integration_test.rs
```

### Cargo.toml Configuration

```toml
[package]
name = "telegram-channel"
version = "1.0.0"
edition = "2021"

[package.metadata.component]
package = "clawos:telegram-channel"

[dependencies]
wit-bindgen = "0.30"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
tokio = { version = "1.0", features = ["rt", "macros"] }
reqwest = { version = "0.11", features = ["json"] }
anyhow = "1.0"

[dev-dependencies]
wasmtime = "27.0"
wasmtime-wasi = "27.0"
```

### WIT Interface Definition

```wit
/// Telegram Channel WIT Interface v1.0.0
/// Provides secure Telegram Bot API access via WASM
///
/// # Security Model
/// - All network access proxied through WIT host functions
/// - Bot tokens stored in ClawFS Vault, not in WASM memory
/// - All operations logged via eBPF monitoring
///
/// # Version
/// - WIT Version: 1.0.0
/// - Component Model: wasmtime 27+
/// - ABI: wasm32-unknown-unknown
package clawos:telegram-channel@1.0.0;

/// Telegram Bot API error codes
enum telegram-error {
    /// Operation completed successfully
    success = 0,
    /// Invalid bot token
    invalid-token = 1,
    /// Network error
    network-error = 2,
    /// API rate limit exceeded
    rate-limit = 3,
    /// Invalid request parameters
    invalid-params = 4,
    /// Chat not found
    chat-not-found = 5,
    /// Message too long
    message-too-long = 6,
    /// Permission denied
    permission-denied = 7,
    /// Internal error
    internal-error = 8,
}

/// Telegram message type
enum message-type {
    /// Text message
    text,
    /// Photo message
    photo,
    /// Document message
    document,
    /// Sticker message
    sticker,
}

/// Telegram chat type
enum chat-type {
    /// Private chat
    private,
    /// Group chat
    group,
    /// Supergroup
    supergroup,
    /// Channel
    channel,
}

/// Telegram message
record telegram-message {
    /// Message ID
    message-id: u64,
    /// Chat ID
    chat-id: i64,
    /// Message type
    message-type: message-type,
    /// Text content (for text messages)
    text: string,
    /// File ID (for photo/document/sticker)
    file-id: string,
    /// Sender user ID
    from-user-id: u64,
    /// Timestamp
    timestamp: u64,
}

/// Telegram update
record telegram-update {
    /// Update ID
    update-id: u64,
    /// Message (optional)
    message: option<telegram-message>,
    /// Callback query (optional)
    callback-query: option<callback-query>,
}

/// Callback query (inline buttons)
record callback-query {
    /// Query ID
    query-id: string,
    /// From user ID
    from-user-id: u64,
    /// Chat ID
    chat-id: i64,
    /// Data
    data: string,
}

/// Send message result
record send-message-result {
    /// Message ID
    message-id: u64,
    /// Chat ID
    chat-id: i64,
    /// Timestamp
    timestamp: u64,
}

/// Telegram Bot API interface
interface telegram-bot {
    /// Initialize the bot with token from ClawFS Vault
    ///
    /// # Parameters
    /// - `token-path`: Path to encrypted token in ClawFS Vault
    ///
    /// # Returns
    /// Success or error
    ///
    /// # Errors
    /// - `invalid-token`: Token decryption failed or invalid
    /// - `internal-error`: Initialization failed
    init: func(token-path: string) -> result<_, telegram-error>

    /// Send a text message
    ///
    /// # Parameters
    /// - `chat-id`: Target chat ID
    /// - `text`: Message text
    /// - `parse-mode`: Parse mode (HTML/Markdown/None)
    ///
    /// # Returns
    /// Send message result
    ///
    /// # Errors
    /// - `invalid-params`: Invalid chat ID or text
    /// - `message-too-long`: Text exceeds 4096 characters
    /// - `rate-limit`: API rate limit exceeded
    /// - `network-error`: Network request failed
    send-message: func(chat-id: i64, text: string, parse-mode: string) -> result<send-message-result, telegram-error>

    /// Send a photo
    ///
    /// # Parameters
    /// - `chat-id`: Target chat ID
    /// - `photo`: Photo file ID or URL
    /// - `caption`: Photo caption (optional)
    ///
    /// # Returns
    /// Send message result
    ///
    /// # Errors
    /// - `invalid-params`: Invalid chat ID or photo
    /// - `rate-limit`: API rate limit exceeded
    /// - `network-error`: Network request failed
    send-photo: func(chat-id: i64, photo: string, caption: string) -> result<send-message-result, telegram-error>

    /// Get updates (long polling)
    ///
    /// # Parameters
    /// - `offset`: Update offset (0 for all)
    /// - `timeout`: Long polling timeout in seconds
    /// - `limit`: Maximum number of updates
    ///
    /// # Returns
    /// List of updates
    ///
    /// # Errors
    /// - `network-error`: Network request failed
    /// - `rate-limit`: API rate limit exceeded
    get-updates: func(offset: u64, timeout: u32, limit: u32) -> result<list<telegram-update>, telegram-error>

    /// Answer callback query (inline button response)
    ///
    /// # Parameters
    /// - `query-id`: Callback query ID
    /// - `text`: Response text
    /// - `show-alert`: Show alert instead of notification
    ///
    /// # Returns
    /// Success or error
    ///
    /// # Errors
    /// - `invalid-params`: Invalid query ID
    /// - `network-error`: Network request failed
    answer-callback-query: func(query-id: string, text: string, show-alert: bool) -> result<_, telegram-error>

    /// Get bot information
    ///
    /// # Returns
    /// Bot information (JSON string)
    ///
    /// # Errors
    /// - `network-error`: Network request failed
    get-me: func() -> result<string, telegram-error>
}

/// Export Telegram Bot API interface
export telegram-bot: telegram-bot
```

### Implementation Structure (src/lib.rs)

```rust
use wit_bindgen::generate::generate;

// Generate WIT bindings
generate!();

pub mod api;
pub mod bot;
pub mod handlers;
pub mod error;

use error::TelegramError;

/// Telegram Channel WASM Component
///
/// This component provides secure Telegram Bot API access
/// through the ClawOS WASM sandbox.
pub struct TelegramChannel {
    bot_token: String,
    api_base: String,
}

impl TelegramChannel {
    /// Create a new Telegram channel instance
    pub fn new(bot_token: String) -> Self {
        Self {
            bot_token,
            api_base: "https://api.telegram.org/bot".to_string(),
        }
    }
}

// Implement WIT interface traits
impl clawos_telegram_channel::telegram_bot::TelegramBot for TelegramChannel {
    fn init(token_path: String) -> Result<(), clawos_telegram_channel::telegram_bot::TelegramError> {
        // Read encrypted token from ClawFS Vault via WIT
        // Decrypt token using kernel keyring
        // Store in memory (never write to disk)
        todo!()
    }

    fn send_message(
        chat_id: i64,
        text: String,
        parse_mode: String,
    ) -> Result<clawos_telegram_channel::telegram_bot::SendMessageResult, clawos_telegram_channel::telegram_bot::TelegramError> {
        // Validate parameters
        // Send HTTP request via WIT network interface
        // Parse response
        // Return result
        todo!()
    }

    // ... other methods
}
```

---

## Slack Channel WASM Component

### Component Structure

```
channels-src/slack/
├── Cargo.toml
├── wit/
│   └── slack-channel.wit
├── src/
│   ├── lib.rs
│   ├── api.rs
│   ├── bot.rs
│   ├── handlers.rs
│   ├── rtm.rs
│   └── error.rs
└── tests/
    └── integration_test.rs
```

### Cargo.toml Configuration

```toml
[package]
name = "slack-channel"
version = "1.0.0"
edition = "2021"

[package.metadata.component]
package = "clawos:slack-channel"

[dependencies]
wit-bindgen = "0.30"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
tokio = { version = "1.0", features = ["rt", "macros", "net"] }
tokio-tungstenite = "0.21"
reqwest = { version = "0.11", features = ["json"] }
anyhow = "1.0"

[dev-dependencies]
wasmtime = "27.0"
wasmtime-wasi = "27.0"
```

### WIT Interface Definition

```wit
/// Slack Channel WIT Interface v1.0.0
/// Provides secure Slack Web API and RTM access via WASM
///
/// # Security Model
/// - All network access proxied through WIT host functions
/// - Bot tokens stored in ClawFS Vault, not in WASM memory
/// - WebSocket connections managed by WASM bridge
/// - All operations logged via eBPF monitoring
///
/// # Version
/// - WIT Version: 1.0.0
/// - Component Model: wasmtime 27+
/// - ABI: wasm32-unknown-unknown
package clawos:slack-channel@1.0.0;

/// Slack API error codes
enum slack-error {
    /// Operation completed successfully
    success = 0,
    /// Invalid bot token
    invalid-token = 1,
    /// Network error
    network-error = 2,
    /// API rate limit exceeded
    rate-limit = 3,
    /// Invalid request parameters
    invalid-params = 4,
    /// Channel not found
    channel-not-found = 5,
    /// Message too long
    message-too-long = 6,
    /// Permission denied
    permission-denied = 7,
    /// WebSocket error
    websocket-error = 8,
    /// Internal error
    internal-error = 9,
}

/// Slack message type
enum message-type {
    /// Standard message
    message,
    /// Bot message
    bot-message,
    /// Me message (italicized)
    me-message,
    /// File share
    file-share,
}

/// Slack channel type
enum channel-type {
    /// Public channel
    public,
    /// Private channel
    private,
    /// Direct message
    dm,
    /// Group direct message
    mpdm,
}

/// Slack message
record slack-message {
    /// Message timestamp
    ts: string,
    /// Channel ID
    channel: string,
    /// User ID
    user: string,
    /// Message type
    message-type: message-type,
    /// Text content
    text: string,
    /// Bot ID (for bot messages)
    bot-id: option<string>,
    /// Attachments
    attachments: list<attachment>,
}

/// Attachment
record attachment {
    /// Fallback text
    fallback: string,
    /// Title
    title: option<string>,
    /// Text
    text: option<string>,
    /// Color
    color: option<string>,
}

/// Slack event (RTM or Events API)
record slack-event {
    /// Event type
    event-type: string,
    /// Event data (JSON string)
    data: string,
    /// Timestamp
    ts: string,
}

/// Send message result
record send-message-result {
    /// Message timestamp
    ts: string,
    /// Channel ID
    channel: string,
    /// Message text
    text: string,
}

/// Slack Web API interface
interface slack-web-api {
    /// Initialize the bot with token from ClawFS Vault
    ///
    /// # Parameters
    /// - `token-path`: Path to encrypted token in ClawFS Vault
    ///
    /// # Returns
    /// Success or error
    ///
    /// # Errors
    /// - `invalid-token`: Token decryption failed or invalid
    /// - `internal-error`: Initialization failed
    init: func(token-path: string) -> result<_, slack-error>

    /// Send a message to a channel
    ///
    /// # Parameters
    /// - `channel`: Channel ID or name
    /// - `text`: Message text
    /// - `attachments`: Attachments (JSON string)
    ///
    /// # Returns
    /// Send message result
    ///
    /// # Errors
    /// - `invalid-params`: Invalid channel or text
    /// - `message-too-long`: Text exceeds 40000 characters
    /// - `rate-limit`: API rate limit exceeded
    /// - `network-error`: Network request failed
    send-message: func(channel: string, text: string, attachments: string) -> result<send-message-result, slack-error>

    /// Update a message
    ///
    /// # Parameters
    /// - `channel`: Channel ID
    /// - `ts`: Message timestamp
    /// - `text`: New text
    ///
    /// # Returns
    /// Updated message timestamp
    ///
    /// # Errors
    /// - `invalid-params`: Invalid parameters
    /// - `rate-limit`: API rate limit exceeded
    /// - `network-error`: Network request failed
    update-message: func(channel: string, ts: string, text: string) -> result<string, slack-error>

    /// Delete a message
    ///
    /// # Parameters
    /// - `channel`: Channel ID
    /// - `ts`: Message timestamp
    ///
    /// # Returns
    /// Success or error
    ///
    /// # Errors
    /// - `invalid-params`: Invalid parameters
    /// - `permission-denied`: No permission to delete
    /// - `network-error`: Network request failed
    delete-message: func(channel: string, ts: string) -> result<_, slack-error>

    /// Get channel information
    ///
    /// # Parameters
    /// - `channel`: Channel ID
    ///
    /// # Returns
    /// Channel information (JSON string)
    ///
    /// # Errors
    /// - `channel-not-found`: Channel not found
    /// - `network-error`: Network request failed
    get-channel-info: func(channel: string) -> result<string, slack-error>

    /// Get bot information
    ///
    /// # Returns
    /// Bot information (JSON string)
    ///
    /// # Errors
    /// - `network-error`: Network request failed
    get-bot-info: func() -> result<string, slack-error>
}

/// Slack RTM (Real-Time Messaging) interface
interface slack-rtm {
    /// Connect to RTM WebSocket
    ///
    /// # Parameters
    /// - `token-path`: Path to encrypted token in ClawFS Vault
    ///
    /// # Returns
    /// WebSocket URL
    ///
    /// # Errors
    /// - `invalid-token`: Token decryption failed or invalid
    /// - `network-error`: Network request failed
    connect: func(token-path: string) -> result<string, slack-error>

    /// Receive event from RTM
    ///
    /// # Returns
    /// Slack event
    ///
    /// # Errors
    /// - `websocket-error`: WebSocket error
    /// - `network-error`: Network error
    receive-event: func() -> result<slack-event, slack-error>

    /// Send event to RTM
    ///
    /// # Parameters
    /// - `event-type`: Event type
    /// - `data`: Event data (JSON string)
    ///
    /// # Returns
    /// Success or error
    ///
    /// # Errors
    /// - `websocket-error`: WebSocket error
    /// - `network-error`: Network error
    send-event: func(event-type: string, data: string) -> result<_, slack-error>

    /// Disconnect from RTM
    ///
    /// # Returns
    /// Success or error
    ///
    /// # Errors
    /// - `websocket-error`: WebSocket error
    disconnect: func() -> result<_, slack-error>
}

/// Export Slack Web API interface
export slack-web-api: slack-web-api

/// Export Slack RTM interface
export slack-rtm: slack-rtm
```

---

## WIT Interface Definitions

### SSE (Server-Sent Events) Interface

```wit
/// SSE (Server-Sent Events) WIT Interface v1.0.0
/// Provides SSE client functionality for WASM components
///
/// # Security Model
/// - All network access proxied through WIT host functions
/// - Connections managed by WASM bridge
/// - All operations logged via eBPF monitoring
///
/// # Version
/// - WIT Version: 1.0.0
/// - Component Model: wasmtime 27+
/// - ABI: wasm32-unknown-unknown
package clawos:sse@1.0.0;

/// SSE error codes
enum sse-error {
    /// Operation completed successfully
    success = 0,
    /// Connection failed
    connection-failed = 1,
    /// Invalid URL
    invalid-url = 2,
    /// Network error
    network-error = 3,
    /// Connection closed
    connection-closed = 4,
    /// Parse error
    parse-error = 5,
    /// Timeout
    timeout = 6,
    /// Internal error
    internal-error = 7,
}

/// SSE event
record sse-event {
    /// Event ID
    id: option<string>,
    /// Event type
    event-type: option<string>,
    /// Event data
    data: string,
    /// Retry interval (milliseconds)
    retry: option<u32>,
}

/// SSE client interface
interface sse-client {
    /// Connect to SSE endpoint
    ///
    /// # Parameters
    /// - `url`: SSE endpoint URL
    /// - `headers`: Request headers (JSON string)
    ///
    /// # Returns
    /// Connection handle ID
    ///
    /// # Errors
    /// - `invalid-url`: Invalid URL format
    /// - `connection-failed`: Connection failed
    connect: func(url: string, headers: string) -> result<u32, sse-error>

    /// Receive next event
    ///
    /// # Parameters
    /// - `connection-id`: Connection handle ID
    /// - `timeout-ms`: Timeout in milliseconds (0 = no timeout)
    ///
    /// # Returns
    /// SSE event
    ///
    /// # Errors
    /// - `connection-closed`: Connection closed
    /// - `timeout`: Timeout exceeded
    /// - `parse-error`: Event parse error
    receive-event: func(connection-id: u32, timeout-ms: u32) -> result<sse-event, sse-error>

    /// Close connection
    ///
    /// # Parameters
    /// - `connection-id`: Connection handle ID
    ///
    /// # Returns
    /// Success or error
    ///
    /// # Errors
    /// - `internal-error`: Failed to close connection
    close: func(connection-id: u32) -> result<_, sse-error>

    /// Check if connection is open
    ///
    /// # Parameters
    /// - `connection-id`: Connection handle ID
    ///
    /// # Returns
    /// True if open, false otherwise
    is-open: func(connection-id: u32) -> bool
}

/// Export SSE client interface
export sse-client: sse-client
```

### WebSocket Interface

```wit
/// WebSocket WIT Interface v1.0.0
/// Provides WebSocket client functionality for WASM components
///
/// # Security Model
/// - All network access proxied through WIT host functions
/// - Connections managed by WASM bridge
/// - All operations logged via eBPF monitoring
///
/// # Version
/// - WIT Version: 1.0.0
/// - Component Model: wasmtime 27+
/// - ABI: wasm32-unknown-unknown
package clawos:websocket@1.0.0;

/// WebSocket error codes
enum websocket-error {
    /// Operation completed successfully
    success = 0,
    /// Connection failed
    connection-failed = 1,
    /// Invalid URL
    invalid-url = 2,
    /// Network error
    network-error = 3,
    /// Connection closed
    connection-closed = 4,
    /// Send error
    send-error = 5,
    /// Receive error
    receive-error = 6,
    /// Timeout
    timeout = 7,
    /// Internal error
    internal-error = 8,
}

/// WebSocket message type
enum message-type {
    /// Text message
    text,
    /// Binary message
    binary,
}

/// WebSocket message
record websocket-message {
    /// Message type
    message-type: message-type,
    /// Text content (for text messages)
    text: string,
    /// Binary data (for binary messages)
    data: list<u8>,
}

/// WebSocket client interface
interface websocket-client {
    /// Connect to WebSocket endpoint
    ///
    /// # Parameters
    /// - `url`: WebSocket endpoint URL
    /// - `headers`: Request headers (JSON string)
    ///
    /// # Returns
    /// Connection handle ID
    ///
    /// # Errors
    /// - `invalid-url`: Invalid URL format
    /// - `connection-failed`: Connection failed
    connect: func(url: string, headers: string) -> result<u32, websocket-error>

    /// Send message
    ///
    /// # Parameters
    /// - `connection-id`: Connection handle ID
    /// - `message`: Message to send
    ///
    /// # Returns
    /// Success or error
    ///
    /// # Errors
    /// - `connection-closed`: Connection closed
    /// - `send-error`: Send failed
    send: func(connection-id: u32, message: websocket-message) -> result<_, websocket-error>

    /// Receive message
    ///
    /// # Parameters
    /// - `connection-id`: Connection handle ID
    /// - `timeout-ms`: Timeout in milliseconds (0 = no timeout)
    ///
    /// # Returns
    /// WebSocket message
    ///
    /// # Errors
    /// - `connection-closed`: Connection closed
    /// - `timeout`: Timeout exceeded
    /// - `receive-error`: Receive failed
    receive: func(connection-id: u32, timeout-ms: u32) -> result<websocket-message, websocket-error>

    /// Close connection
    ///
    /// # Parameters
    /// - `connection-id`: Connection handle ID
    /// - `code`: Close code
    /// - `reason`: Close reason
    ///
    /// # Returns
    /// Success or error
    ///
    /// # Errors
    /// - `internal-error`: Failed to close connection
    close: func(connection-id: u32, code: u16, reason: string) -> result<_, websocket-error>

    /// Check if connection is open
    ///
    /// # Parameters
    /// - `connection-id`: Connection handle ID
    ///
    /// # Returns
    /// True if open, false otherwise
    is-open: func(connection-id: u32) -> bool

    /// Get connection state
    ///
    /// # Parameters
    /// - `connection-id`: Connection handle ID
    ///
    /// # Returns
    /// Connection state (JSON string)
    get-state: func(connection-id: u32) -> string
}

/// Export WebSocket client interface
export websocket-client: websocket-client
```

### Message Handling Interface

```wit
/// Message Handling WIT Interface v1.0.0
/// Provides message queue and handling for WASM components
///
/// # Security Model
/// - All message operations logged via eBPF monitoring
/// - Message queues isolated per component
/// - All operations return explicit error codes
///
/// # Version
/// - WIT Version: 1.0.0
/// - Component Model: wasmtime 27+
/// - ABI: wasm32-unknown-unknown
package clawos:message-handler@1.0.0;

/// Message handler error codes
enum message-error {
    /// Operation completed successfully
    success = 0,
    /// Queue not found
    queue-not-found = 1,
    /// Queue full
    queue-full = 2,
    /// Invalid message
    invalid-message = 3,
    /// Timeout
    timeout = 4,
    /// Internal error
    internal-error = 5,
}

/// Message priority
enum message-priority {
    /// Low priority
    low = 0,
    /// Normal priority
    normal = 1,
    /// High priority
    high = 2,
    /// Critical priority
    critical = 3,
}

/// Message
record message {
    /// Message ID
    message-id: string,
    /// Message type
    message-type: string,
    /// Message payload (JSON string)
    payload: string,
    /// Message priority
    priority: message-priority,
    /// Timestamp
    timestamp: u64,
    /// Retry count
    retry-count: u32,
}

/// Message queue interface
interface message-queue {
    /// Create a new message queue
    ///
    /// # Parameters
    /// - `queue-name`: Queue name
    /// - `max-size`: Maximum queue size (0 = unlimited)
    ///
    /// # Returns
    /// Success or error
    ///
    /// # Errors
    /// - `internal-error`: Failed to create queue
    create-queue: func(queue-name: string, max-size: u32) -> result<_, message-error>

    /// Delete a message queue
    ///
    /// # Parameters
    /// - `queue-name`: Queue name
    ///
    /// # Returns
    /// Success or error
    ///
    /// # Errors
    /// - `queue-not-found`: Queue not found
    delete-queue: func(queue-name: string) -> result<_, message-error>

    /// Send a message to a queue
    ///
    /// # Parameters
    /// - `queue-name`: Queue name
    /// - `message`: Message to send
    ///
    /// # Returns
    /// Success or error
    ///
    /// # Errors
    /// - `queue-not-found`: Queue not found
    /// - `queue-full`: Queue is full
    /// - `invalid-message`: Invalid message
    send: func(queue-name: string, message: message) -> result<_, message-error>

    /// Receive a message from a queue
    ///
    /// # Parameters
    /// - `queue-name`: Queue name
    /// - `timeout-ms`: Timeout in milliseconds (0 = no timeout)
    ///
    /// # Returns
    /// Message
    ///
    /// # Errors
    /// - `queue-not-found`: Queue not found
    /// - `timeout`: Timeout exceeded
    receive: func(queue-name: string, timeout-ms: u32) -> result<message, message-error>

    /// Get queue size
    ///
    /// # Parameters
    /// - `queue-name`: Queue name
    ///
    /// # Returns
    /// Queue size
    ///
    /// # Errors
    /// - `queue-not-found`: Queue not found
    get-size: func(queue-name: string) -> result<u32, message-error>

    /// Clear a queue
    ///
    /// # Parameters
    /// - `queue-name`: Queue name
    ///
    /// # Returns
    /// Success or error
    ///
    /// # Errors
    /// - `queue-not-found`: Queue not found
    clear: func(queue-name: string) -> result<_, message-error>
}

/// Export message queue interface
export message-queue: message-queue
```

---

## cargo-component Build Configuration

### Build Process

```bash
# 1. Install cargo-component
cargo install cargo-component

# 2. Build Telegram channel WASM component
cd channels-src/telegram
cargo component build --release

# 3. Build Slack channel WASM component
cd channels-src/slack
cargo component build --release

# 4. Verify WASM binaries
ls -lh target/wasm32-unknown-unknown/release/*.wasm
```

### Build Configuration (component-metadata.json)

```json
{
  "package": {
    "name": "telegram-channel",
    "version": "1.0.0",
    "description": "Telegram Bot API WASM component for ClawOS"
  },
  "component": {
    "world": "telegram-bot",
    "wit": "wit/telegram-channel.wit",
    "dependencies": [
      {
        "name": "clawos:kernel",
        "version": "2.0.0"
      },
      {
        "name": "clawos:sse",
        "version": "1.0.0"
      },
      {
        "name": "clawos:websocket",
        "version": "1.0.0"
      },
      {
        "name": "clawos:message-handler",
        "version": "1.0.0"
      }
    ]
  },
  "build": {
    "target": "wasm32-unknown-unknown",
    "profile": "release",
    "optimization-level": "s",
    "lto": true
  }
}
```

### Optimization Settings

```toml
[profile.release]
opt-level = "s"        # Optimize for size
lto = true             # Link-time optimization
codegen-units = 1      # Single codegen unit for better optimization
panic = "abort"        # Abort on panic (smaller binary)
strip = true           # Strip symbols
```

### WASM Binary Verification

```bash
# Verify WASM binary
wasm-objdump -h target/wasm32-unknown-unknown/release/telegram_channel.wasm

# Check binary size
du -h target/wasm32-unknown-unknown/release/telegram_channel.wasm

# Validate WIT interface
wasm-tools component wit target/wasm32-unknown-unknown/release/telegram_channel.wasm
```

---

## API Key and Secrets Handling

### ClawFS Vault Structure

```
/clawfs/vault/
├── secrets/
│   ├── telegram-bot-token.enc
│   ├── slack-bot-token.enc
│   └── slack-signing-secret.enc
├── keys/
│   ├── vault-master-key.enc
│   └── vault-public-key.pem
└── policies/
    ├── telegram-access-policy.json
    └── slack-access-policy.json
```

### Secret Encryption Format

```json
{
  "version": "1.0",
  "algorithm": "AES-256-GCM",
  "key_id": "vault-master-key-v1",
  "nonce": "base64-encoded-nonce",
  "ciphertext": "base64-encoded-ciphertext",
  "tag": "base64-encoded-auth-tag",
  "timestamp": 1234567890,
  "metadata": {
    "service": "telegram",
    "purpose": "bot-token",
    "created_by": "admin",
    "expires_at": null
  }
}
```

### WIT Interface for Secret Access

```wit
/// Secret Access WIT Interface v1.0.0
/// Provides secure secret access from ClawFS Vault
///
/// # Security Model
/// - Secrets encrypted at rest (AES-256-GCM)
/// - Secrets decrypted in kernel keyring only
/// - WASM components receive decrypted secrets via WIT
/// - All secret access logged via eBPF monitoring
///
/// # Version
/// - WIT Version: 1.0.0
/// - Component Model: wasmtime 27+
/// - ABI: wasm32-unknown-unknown
package clawos:secret-access@1.0.0;

/// Secret access error codes
enum secret-error {
    /// Operation completed successfully
    success = 0,
    /// Secret not found
    secret-not-found = 1,
    /// Decryption failed
    decryption-failed = 2,
    /// Access denied
    access-denied = 3,
    /// Invalid secret format
    invalid-format = 4,
    /// Secret expired
    secret-expired = 5,
    /// Internal error
    internal-error = 6,
}

/// Secret access interface
interface secret-access {
    /// Read a secret from ClawFS Vault
    ///
    /// # Parameters
    /// - `secret-path`: Path to encrypted secret in ClawFS Vault
    ///
    /// # Returns
    /// Decrypted secret value
    ///
    /// # Errors
    /// - `secret-not-found`: Secret not found
    /// - `decryption-failed`: Decryption failed
    /// - `access-denied`: Access denied by policy
    /// - `secret-expired`: Secret has expired
    read-secret: func(secret-path: string) -> result<string, secret-error>

    /// Check if a secret exists
    ///
    /// # Parameters
    /// - `secret-path`: Path to secret in ClawFS Vault
    ///
    /// # Returns
    /// True if exists, false otherwise
    secret-exists: func(secret-path: string) -> bool

    /// Get secret metadata
    ///
    /// # Parameters
    /// - `secret-path`: Path to secret in ClawFS Vault
    ///
    /// # Returns
    /// Secret metadata (JSON string)
    ///
    /// # Errors
    /// - `secret-not-found`: Secret not found
    get-secret-metadata: func(secret-path: string) -> result<string, secret-error>
}

/// Export secret access interface
export secret-access: secret-access
```

### Secret Access Example

```rust
use clawos_secret_access::secret_access::SecretAccess;

// Initialize Telegram channel
fn init_telegram_channel() -> Result<TelegramChannel, TelegramError> {
    // Read bot token from ClawFS Vault
    let token_path = "/clawfs/vault/secrets/telegram-bot-token.enc";
    let bot_token = SecretAccess::read_secret(token_path)
| e |

    // Create Telegram channel instance
    Ok(TelegramChannel::new(bot_token))
}
```

---

## Authentication Strategies

### Telegram Bot Authentication

#### Bot Token Authentication

```rust
/// Telegram Bot Token Authentication
///
/// Strategy: Bot Token (HTTP Bearer-like)
/// - Token format: `<bot_id>:<token>`
/// - Token stored in ClawFS Vault (encrypted)
/// - Token sent in URL: `https://api.telegram.org/bot<token>/...`
/// - No additional headers required
pub struct TelegramBotAuth {
    bot_token: String,
}

impl TelegramBotAuth {
    /// Create new authentication instance
    pub fn new(bot_token: String) -> Self {
        Self { bot_token }
    }

    /// Get API base URL with token
    pub fn api_base(&self) -> String {
        format!("https://api.telegram.org/bot{}", self.bot_token)
    }

    /// Get file URL with token
    pub fn file_url(&self, file_path: &str) -> String {
        format!(
            "https://api.telegram.org/file/bot{}/{}",
            self.bot_token, file_path
        )
    }
}
```

#### Webhook Authentication

```rust
/// Telegram Webhook Authentication
///
/// Strategy: Secret Token (HMAC-SHA256)
/// - Secret token configured in Telegram Bot API
/// - Token stored in ClawFS Vault
/// - Webhook requests signed with HMAC-SHA256
/// - Signature verified in WASM component
pub struct TelegramWebhookAuth {
    secret_token: String,
}

impl TelegramWebhookAuth {
    /// Verify webhook signature
    pub fn verify_signature(
        &self,
        signature: &str,
        body: &[u8],
    ) -> Result<bool, TelegramError> {
        use hmac::{Hmac, Mac};
        use sha2::Sha256;

        // Parse signature (format: "sha256=<hex>")
        let sig_hex = signature
            .strip_prefix("sha256=")
            .ok_or(TelegramError::InvalidSignature)?;

        // Compute HMAC-SHA256
        let mut mac = Hmac::<Sha256>::new_from_slice(self.secret_token.as_bytes())
| _ |
        mac.update(body);
        let expected = mac.finalize().into_bytes();

        // Compare signatures
        let decoded = hex::decode(sig_hex)
| _ |

        Ok(expected.as_slice() == decoded.as_slice())
    }
}
```

### Slack Bot Authentication

#### Bot Token Authentication

```rust
/// Slack Bot Token Authentication
///
/// Strategy: Bot Token (HTTP Bearer)
/// - Token format: `xoxb-<workspace-id>-<bot-id>-<token>`
/// - Token stored in ClawFS Vault (encrypted)
/// - Token sent in Authorization header: `Bearer <token>`
pub struct SlackBotAuth {
    bot_token: String,
}

impl SlackBotAuth {
    /// Create new authentication instance
    pub fn new(bot_token: String) -> Self {
        Self { bot_token }
    }

    /// Get authorization header
    pub fn auth_header(&self) -> String {
        format!("Bearer {}", self.bot_token)
    }

    /// Get API base URL
    pub fn api_base(&self) -> String {
        "https://slack.com/api".to_string()
    }
}
```

#### Signing Secret Authentication (Webhooks)

```rust
/// Slack Signing Secret Authentication
///
/// Strategy: Signing Secret (HMAC-SHA256)
/// - Signing secret configured in Slack App
/// - Secret stored in ClawFS Vault
/// - Webhook requests signed with HMAC-SHA256
/// - Signature verified in WASM component
pub struct SlackSigningSecretAuth {
    signing_secret: String,
}

impl SlackSigningSecretAuth {
    /// Verify webhook signature
    ///
    /// Signature format: "v0=<timestamp>=<hex>"
    pub fn verify_signature(
        &self,
        signature: &str,
        timestamp: &str,
        body: &[u8],
    ) -> Result<bool, SlackError> {
        use hmac::{Hmac, Mac};
        use sha2::Sha256;

        // Parse signature
        let sig_hex = signature
            .strip_prefix("v0=")
            .ok_or(SlackError::InvalidSignature)?;

        // Compute HMAC-SHA256
        let base = format!("v0:{}:", timestamp);
        let mut mac = Hmac::<Sha256>::new_from_slice(self.signing_secret.as_bytes())
| _ |
        mac.update(base.as_bytes());
        mac.update(body);
        let expected = mac.finalize().into_bytes();

        // Compare signatures
        let decoded = hex::decode(sig_hex)
| _ |

        Ok(expected.as_slice() == decoded.as_slice())
    }

    /// Verify timestamp (prevent replay attacks)
    pub fn verify_timestamp(&self, timestamp: &str) -> Result<bool, SlackError> {
        let ts = timestamp
            .parse::<u64>()
| _ |

        let now = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
| _ |
            .as_secs();

        // Reject timestamps older than 5 minutes
        const MAX_AGE: u64 = 300;
        Ok(now.saturating_sub(ts) <= MAX_AGE)
    }
}
```

---

## WASM Bridge Integration

### Integration with P1.1 WIT Interface

```rust
/// Channel WASM Component Integration
///
/// This module integrates channel components with the ClawOS WASM Kernel Bridge
/// defined in P1.1 WIT Interface Specification.
use clawos_kernel::network;
use clawos_kernel::logging;
use clawos_secret_access::secret_access;

/// Channel component base
pub struct ChannelComponent {
    /// Component name
    name: String,
    /// Component version
    version: String,
}

impl ChannelComponent {
    /// Initialize channel component
    pub fn init(name: String, version: String) -> Result<Self, ChannelError> {
        logging::info(&format!("Initializing {} v{}", name, version));

        Ok(Self { name, version })
    }

    /// Make HTTP request via WIT network interface
    pub async fn http_request(
        &self,
        url: &str,
        method: &str,
        headers: Vec<(String, String)>,
        body: Option<Vec<u8>>,
    ) -> Result<Vec<u8>, ChannelError> {
        // Create socket via WIT
        let socket = network::socket(2, 1, 6) // AF_INET, SOCK_STREAM, TCP
| e |

        // Resolve hostname
        let host = url
            .split("://")
            .nth(1)
| s |
            .ok_or(ChannelError::InvalidUrl)?;

        let ip = network::resolve(host)
| e |

        // Connect to server
        let port = if url.starts_with("https://") { 443 } else { 80 };
        socket.connect(&ip, port)
| e |

        // Send HTTP request
        let request = self.build_http_request(url, method, headers, body);
        socket.send(request.as_bytes())
| e |

        // Receive response
        let mut buffer = vec![0u8; 65536];
        let bytes_received = socket.recv(&mut buffer, 65536)
| e |

        buffer.truncate(bytes_received as usize);

        // Close socket
        socket.close()
| e |

        Ok(buffer)
    }

    /// Build HTTP request
    fn build_http_request(
        &self,
        url: &str,
        method: &str,
        headers: Vec<(String, String)>,
        body: Option<Vec<u8>>,
    ) -> String {
        let mut request = format!("{} {} HTTP/1.1\r\n", method, url);

        for (key, value) in headers {
            request.push_str(&format!("{}: {}\r\n", key, value));
        }

        if let Some(body) = body {
            request.push_str(&format!("Content-Length: {}\r\n", body.len()));
        }

        request.push_str("\r\n");

        if let Some(body) = body {
            request.push_str(&String::from_utf8_lossy(&body));
        }

        request
    }
}
```

### IPC Integration (P1.7)

```rust
/// IPC Integration for Channel Components
///
/// Channel components communicate with Agent Loop via IPC protocol
/// defined in P1.7 Inter-Agent IPC Protocol Specification.
use serde_json::{json, Value};

/// IPC message types
enum IpcMessageType {
    Request,
    Response,
    Event,
    Error,
}

/// IPC client for channel components
pub struct IpcClient {
    socket_path: String,
}

impl IpcClient {
    /// Create new IPC client
    pub fn new(component_name: &str) -> Self {
        let socket_path = format!("@clawos-ipc-{}", component_name);
        Self { socket_path }
    }

    /// Send IPC message
    pub fn send_message(
        &self,
        recipient: &str,
        message_type: IpcMessageType,
        payload: Value,
    ) -> Result<Value, IpcError> {
        use uuid::Uuid;

        // Build message envelope
        let message = json!({
            "version": "1.0",
            "timestamp_ns": std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_nanos(),
            "sender": "telegram-channel",
            "recipient": recipient,
            "message_id": Uuid::new_v4().to_string(),
            "correlation_id": Uuid::new_v4().to_string(),
            "message_type": match message_type {
                IpcMessageType::Request => "request",
                IpcMessageType::Response => "response",
                IpcMessageType::Event => "event",
                IpcMessageType::Error => "error",
            },
            "payload": payload,
        });

        // Serialize and send via Unix Domain Socket
        let message_json = serde_json::to_string(&message)
| e |

        // TODO: Send via Unix Domain Socket
        // This requires async runtime and UDS support

        Ok(json!({"status": "success"}))
    }

    /// Send event message
    pub fn send_event(&self, event_name: &str, event_data: Value) -> Result<(), IpcError> {
        let payload = json!({
            "event_name": event_name,
            "event_data": event_data,
        });

        self.send_message("agent-loop", IpcMessageType::Event, payload)?;
        Ok(())
    }

    /// Send error message
    pub fn send_error(&self, error_code: u32, error_message: &str) -> Result<(), IpcError> {
        let payload = json!({
            "error_code": error_code,
            "error_message": error_message,
            "component": "telegram-channel",
            "severity": "error",
        });

        self.send_message("agent-loop", IpcMessageType::Error, payload)?;
        Ok(())
    }
}
```

---

## Security Considerations

### Threat Model

| Threat                    | Mitigation                                                                |
| ------------------------- | ------------------------------------------------------------------------- |
| Bot token leakage         | Tokens encrypted in ClawFS Vault, decrypted in kernel keyring only        |
| Unauthorized API access   | WIT network interface proxies all requests, eBPF monitors all connections |
| Replay attacks (webhooks) | Timestamp verification, HMAC signature validation                         |
| Message injection         | Input validation, rate limiting, message size limits                      |
| DoS via large messages    | Message size limits (Telegram: 4096 chars, Slack: 40000 chars)            |
| Privilege escalation      | WASM sandbox, seccomp filter, AppArmor profile                            |
| Secret extraction         | Secrets never written to disk, only in kernel keyring memory              |

### Security Controls

#### 1. WASM Sandbox (Layer 5a)
- **Memory Isolation**: 32MB heap limit per channel component
- **CPU Limit**: 0.5 vCPU via cgroup v2
- **No Direct Network Access**: All network via WIT host functions
- **No Direct File Access**: All file access via WIT filesystem interface

#### 2. seccomp-BPF Filter (Layer 5b)
Applied to channel WASM components:
```rust
// Allowed syscalls for channel components
let allowed = [
    // Memory management
    "mmap", "munmap", "mprotect", "brk", "madvise",
    // Process management
    "exit", "exit_group", "getpid", "gettid", "futex",
    // Time
    "clock_gettime", "clock_nanosleep",
    // Signals
    "rt_sigaction", "rt_sigprocmask", "rt_sigreturn",
    // Misc
    "prctl", "getrandom",
];
```

#### 3. cgroup v2 Resource Limits (Layer 5c)
```ini
# /sys/fs/cgroup/clawos/channels/telegram/
memory.max = 32M
cpu.max = 50000 1000000  # 5% of 1 CPU
pids.max = 8
```

#### 4. AppArmor Profile (Layer 5d)
```
#include <tunables/global>

profile clawos-telegram-channel flags=(attach_disconnected) {
  #include <abstractions/base>

  # Allow network to Telegram API
  network inet stream,
  network inet6 stream,

  # Deny everything else
  deny /root/** rw,
  deny /etc/shadow rw,
  deny /etc/passwd rw,
}
```

#### 5. eBPF LSM Monitoring (Layer 4)
- **Network Operations**: All socket/connect to Telegram/Slack monitored
- **File Operations**: All file access to ClawFS Vault monitored
- **Process Operations**: All execve/clone monitored
- **Anomaly Detection**: Suspicious API call patterns trigger alerts

### Rate Limiting

| API               | Rate Limit          | Enforcement             |
| ----------------- | ------------------- | ----------------------- |
| Telegram Bot API  | 30 messages/second  | WASM component enforces |
| Slack Web API     | 1 message/second    | WASM component enforces |
| Slack RTM         | 1 message/second    | WASM component enforces |
| Webhook endpoints | 100 requests/second | WASM bridge enforces    |

---

## Testing and Validation

### Unit Tests

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_telegram_bot_auth() {
        let auth = TelegramBotAuth::new("123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11".to_string());
        assert_eq!(
            auth.api_base(),
            "https://api.telegram.org/bot123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11"
        );
    }

    #[test]
    fn test_slack_bot_auth() {
        let auth = SlackBotAuth::new("xoxb-EXAMPLE-TOKEN-PLACEHOLDER".to_string());
        assert_eq!(
            auth.auth_header(),
            "Bearer xoxb-EXAMPLE-TOKEN-PLACEHOLDER"
        );
    }

    #[test]
    fn test_webhook_signature_verification() {
        let auth = TelegramWebhookAuth::new("secret_token".to_string());
        let body = b"test body";
        let signature = "sha256=invalid_signature";
        assert!(!auth.verify_signature(signature, body).unwrap());
    }
}
```

### Integration Tests

```rust
#[cfg(test)]
mod integration_tests {
    use super::*;
    use wasmtime::*;

    #[tokio::test]
    async fn test_telegram_send_message() {
        // Initialize WASM runtime
        let engine = Engine::default();
        let module = Module::from_file(&engine, "target/wasm32-unknown-unknown/release/telegram_channel.wasm")
            .expect("Failed to load WASM module");

        // Create linker with WIT host functions
        let mut linker = Linker::new(&engine);
        // TODO: Add WIT host function implementations

        // Create store
        let mut store = Store::new(&engine, ());

        // Instantiate module
        let instance = linker.instantiate(&mut store, &module)
            .expect("Failed to instantiate module");

        // Call send_message function
        // TODO: Test send_message function
    }

    #[tokio::test]
    async fn test_slack_rtm_connect() {
        // Initialize WASM runtime
        let engine = Engine::default();
        let module = Module::from_file(&engine, "target/wasm32-unknown-unknown/release/slack_channel.wasm")
            .expect("Failed to load WASM module");

        // Create linker with WIT host functions
        let mut linker = Linker::new(&engine);
        // TODO: Add WIT host function implementations

        // Create store
        let mut store = Store::new(&engine, ());

        // Instantiate module
        let instance = linker.instantiate(&mut store, &module)
            .expect("Failed to instantiate module");

        // Call connect function
        // TODO: Test connect function
    }
}
```

### Security Tests

```rust
#[cfg(test)]
mod security_tests {
    use super::*;

    #[test]
    fn test_secret_not_leaked_in_memory() {
        // Ensure secrets are not leaked in WASM memory
        let secret = "bot_token_123456";
        let auth = TelegramBotAuth::new(secret.to_string());

        // Verify secret is not accessible via memory inspection
        // This requires memory inspection tools
    }

    #[test]
    fn test_rate_limiting() {
        // Test rate limiting enforcement
        let mut message_count = 0;
        for _ in 0..35 {
            // Try to send 35 messages (exceeds 30/second limit)
            // TODO: Implement rate limiting test
        }
        assert!(message_count <= 30);
    }

    #[test]
    fn test_webhook_replay_attack_prevention() {
        let auth = SlackSigningSecretAuth::new("signing_secret".to_string());

        // Old timestamp (more than 5 minutes ago)
        let old_timestamp = (std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_secs() - 600).to_string();

        assert!(!auth.verify_timestamp(&old_timestamp).unwrap());
    }
}
```

---

## Migration Strategy

### From IronClaw Channels to ClawOS WASM

#### Phase 1: Analysis (Week 1)
1. Audit existing IronClaw channel implementations
2. Identify breaking changes in WIT interface
3. Create migration plan for each channel

#### Phase 2: WIT Interface Adaptation (Week 2)
1. Adapt Telegram channel to new WIT interface
2. Adapt Slack channel to new WIT interface
3. Implement SSE/WebSocket interfaces
4. Implement message handling interface

#### Phase 3: Build and Test (Week 3)
1. Build WASM components with cargo-component
2. Run unit tests
3. Run integration tests
4. Run security tests

#### Phase 4: Deployment (Week 4)
1. Deploy WASM binaries to ClawFS
2. Configure tool manifests
3. Update Agent Loop to use new WASM components
4. Monitor for issues

### Breaking Changes

| Change                        | Impact                               | Migration Path                  |
| ----------------------------- | ------------------------------------ | ------------------------------- |
| Direct network access removed | Network calls must use WIT interface | Update all HTTP/WebSocket calls |
| Direct file access removed    | Secrets must use ClawFS Vault        | Update secret access code       |
| New error codes               | New error codes may appear           | Update error handling           |
| IPC protocol changed          | Message format changed               | Update IPC message handling     |

### Rollback Plan

1. If new WASM components cause issues:
   - Rollback to IronClaw channel implementations
   - All components must support rollback within 5 minutes
   - Use `EPANIC` (8) to trigger system-wide rollback if needed

---

## Appendices

### Appendix A: Tool Manifest Format

```json
{
  "tool_id": "telegram-channel",
  "tool_name": "Telegram Channel",
  "version": "1.0.0",
  "wasm_path": "/clawfs/tools/binaries/telegram-channel-v1.0.0.wasm",
  "wit_interface": "clawos:telegram-channel@1.0.0",
  "description": "Telegram Bot API WASM component for ClawOS",
  "capabilities": [
    "network:outbound:telegram",
    "secret:read:telegram-bot-token"
  ],
  "resource_limits": {
    "memory_mb": 32,
    "cpu_percent": 5,
    "max_pids": 8
  },
  "dependencies": [
    {
      "name": "clawos:kernel",
      "version": "2.0.0"
    },
    {
      "name": "clawos:sse",
      "version": "1.0.0"
    },
    {
      "name": "clawos:websocket",
      "version": "1.0.0"
    },
    {
      "name": "clawos:message-handler",
      "version": "1.0.0"
    },
    {
      "name": "clawos:secret-access",
      "version": "1.0.0"
    }
  ],
  "configuration": {
    "telegram_bot_token_path": "/clawfs/vault/secrets/telegram-bot-token.enc",
    "webhook_secret_path": "/clawfs/vault/secrets/telegram-webhook-secret.enc",
    "api_timeout_ms": 10000,
    "rate_limit_per_second": 30
  }
}
```

### Appendix B: Error Code Reference

#### Telegram Error Codes

| Code | Name              | Description                      | Retry? |
| ---- | ----------------- | -------------------------------- | ------ |
| 0    | success           | Operation completed successfully | N/A    |
| 1    | invalid-token     | Invalid bot token                | No     |
| 2    | network-error     | Network error                    | Yes    |
| 3    | rate-limit        | API rate limit exceeded          | Yes    |
| 4    | invalid-params    | Invalid request parameters       | No     |
| 5    | chat-not-found    | Chat not found                   | No     |
| 6    | message-too-long  | Message too long                 | No     |
| 7    | permission-denied | Permission denied                | No     |
| 8    | internal-error    | Internal error                   | No     |

#### Slack Error Codes

| Code | Name              | Description                      | Retry? |
| ---- | ----------------- | -------------------------------- | ------ |
| 0    | success           | Operation completed successfully | N/A    |
| 1    | invalid-token     | Invalid bot token                | No     |
| 2    | network-error     | Network error                    | Yes    |
| 3    | rate-limit        | API rate limit exceeded          | Yes    |
| 4    | invalid-params    | Invalid request parameters       | No     |
| 5    | channel-not-found | Channel not found                | No     |
| 6    | message-too-long  | Message too long                 | No     |
| 7    | permission-denied | Permission denied                | No     |
| 8    | websocket-error   | WebSocket error                  | Yes    |
| 9    | internal-error    | Internal error                   | No     |

### Appendix C: API Reference

#### Telegram Bot API Endpoints

| Endpoint             | Method | Description                |
| -------------------- | ------ | -------------------------- |
| /getMe               | GET    | Get bot information        |
| /sendMessage         | POST   | Send a message             |
| /sendPhoto           | POST   | Send a photo               |
| /getUpdates          | GET    | Get updates (long polling) |
| /answerCallbackQuery | POST   | Answer callback query      |

#### Slack Web API Endpoints

| Endpoint            | Method | Description             |
| ------------------- | ------ | ----------------------- |
| /auth.test          | GET    | Test authentication     |
| /chat.postMessage   | POST   | Send a message          |
| /chat.update        | POST   | Update a message        |
| /chat.delete        | POST   | Delete a message        |
| /conversations.info | GET    | Get channel information |
| /rtm.connect        | GET    | Connect to RTM          |

### Appendix D: Version History

#### v1.0.0 (2026-02-24)
- Initial release
- Define Telegram channel WASM component structure
- Define Slack channel WASM component structure
- Define WIT interfaces for SSE, WebSocket, message handling
- Define cargo-component build configuration
- Define API key/secrets handling
- Define authentication strategies
- Define WASM bridge integration
- Define security considerations
- Define testing and validation
- Define migration strategy

---

## References

- **P1.1:** WIT Interface Specification (WASM ↔ Kernel ABI)
- **P1.4:** ClawFS Path Convention + Secrets Encryption Format
- **P1.7:** Inter-Agent IPC Protocol
- **P3.1:** IronClaw Tool Library Migration to ClawOS WASM Format
- **Telegram Bot API:** https://core.telegram.org/bots/api
- **Slack Web API:** https://api.slack.com/web-api
- **Slack RTM API:** https://api.slack.com/rtm

---

**END OF SPECIFICATION**
