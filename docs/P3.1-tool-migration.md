# P3.1: IronClaw Tool Library Migration to ClawOS WASM Format

**Document ID:** P3.1
**Version:** 1.0.0
**Status:** DRAFT
**Created:** 2026-02-24
**Created By:** WASM Agent
**Dependencies:**
- P1.1: WIT Interface Specification (v2.0.0)
- P1.5: cgroup v2 Resource Quotas
- P1.7: IPC Protocol
- P2.6: WASM Runtime Bridge
- SKILLS.md D-05, D-06: WIT interface and Tool Registry integration

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Migration Overview](#migration-overview)
3. [IronClaw Tool Library Structure](#ironclaw-tool-library-structure)
4. [WIT Component Packaging Requirements](#wit-component-packaging-requirements)
5. [cargo-component Build Process](#cargo-component-build-process)
6. [Tool Metadata Format](#tool-metadata-format)
7. [Integration with P2.6 WASM Bridge](#integration-with-p26-wasm-bridge)
8. [Migration Script Specification](#migration-script-specification)
9. [Test Procedures](#test-procedures)
10. [Migration Checklist](#migration-checklist)
11. [Appendices](#appendices)

---

## Executive Summary

This document specifies the migration of IronClaw's tool library from its original format to ClawOS WASM component format. The migration enables secure, sandboxed execution of AI agent tools through the WASM Runtime Bridge (P2.6), leveraging the WIT interface specification (P1.1) for kernel ABI access.

### Key Objectives

1. **Security**: All tools execute in WASM sandboxes with strict resource limits
2. **Compatibility**: Maintain tool functionality while adapting to WIT v2.0 interface
3. **Performance**: Minimize overhead through efficient WASM compilation
4. **Auditability**: All tool operations logged via eBPF monitoring
5. **Maintainability**: Standardized tool metadata and build process

### Migration Scope

- **Source**: IronClaw tool library (tools-src/ reference)
- **Target**: ClawOS WASM components (*.wasm binaries)
- **Interface**: WIT v2.0 (clawos:kernel@2.0.0)
- **Runtime**: wasmtime 27+ via P2.6 WASM bridge
- **Storage**: ClawFS (tool-as-file model per D-06)

---

## Migration Overview

### Architecture Diagram

```
┌─────────────────────────────────────────────────────────────┐
│ IronClaw Tool Library (Original)                            │
│ - Python/JavaScript tools                                   │
│ - Direct system calls                                       │
│ - No sandboxing                                             │
└────────────────────┬────────────────────────────────────────┘
                     │ MIGRATION
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ ClawOS WASM Components (Target)                             │
│ - Rust/AssemblyScript tools                                 │
│ - WIT interface for kernel access                           │
│ - WASM sandbox + resource limits                            │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ P2.6 WASM Runtime Bridge                                    │
│ - wasmtime 27+ runtime                                      │
│ - WIT host function implementations                          │
│ - seccomp + cgroup + AppArmor                               │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ Linux Kernel 6.6 LTS + eBPF Monitoring                      │
└─────────────────────────────────────────────────────────────┘
```

### Migration Phases

| Phase | Description | Duration | Dependencies |
|-------|-------------|----------|--------------|
| **Phase 1** | Tool inventory and categorization | 2 days | P1.1, P1.5 |
| **Phase 2** | WIT interface adaptation | 5 days | Phase 1 |
| **Phase 3** | cargo-component build setup | 3 days | Phase 2 |
| **Phase 4** | Tool metadata generation | 2 days | Phase 3 |
| **Phase 5** | Integration testing | 4 days | Phase 4 |
| **Phase 6** | ClawFS deployment | 2 days | Phase 5 |

**Total Duration**: ~18 days (3 weeks)

---

## IronClaw Tool Library Structure

### Current Structure (tools-src/)

The IronClaw tool library is organized by functional categories:

```
tools-src/
├── filesystem/          # File system operations
│   ├── read_file.py
│   ├── write_file.py
│   ├── list_dir.py
│   └── file_info.py
├── network/             # Network operations
│   ├── http_request.py
│   ├── dns_resolve.py
│   └── tcp_connect.py
├── process/             # Process management
│   ├── execute.py
│   ├── spawn.py
│   └── monitor.py
├── data/                # Data processing
│   ├── parse_json.py
│   ├── transform.py
│   └── validate.py
├── security/            # Security operations
│   ├── encrypt.py
│   ├── decrypt.py
│   └── hash.py
└── system/              # System operations
    ├── get_env.py
    ├── set_env.py
    └── system_info.py
```

### Tool Inventory

| Category | Tool Count | Primary Language | Complexity |
|----------|------------|------------------|------------|
| Filesystem | 4 | Python | Low |
| Network | 3 | Python | Medium |
| Process | 3 | Python | High |
| Data | 3 | Python | Medium |
| Security | 3 | Python | Medium |
| System | 3 | Python | Low |
| **Total** | **19** | **Python** | **Mixed** |

### Tool Dependencies

| Tool | External Dependencies | Migration Impact |
|------|----------------------|------------------|
| `http_request.py` | `requests`, `urllib3` | Replace with WIT network interface |
| `dns_resolve.py` | `dnspython` | Replace with WIT network::resolve |
| `encrypt.py` | `cryptography` | Implement in Rust with ring crate |
| `parse_json.py` | `json` (std) | Use Rust serde_json |
| `execute.py` | `subprocess` | Replace with WIT system interface |

---

## WIT Component Packaging Requirements

### Component Structure

Each WASM component must follow this structure:

```
tool-name/
├── Cargo.toml              # Component manifest
├── wit/                    # WIT interface definitions
│   └── tool.wit           # Tool-specific WIT (if any)
├── src/
│   ├── lib.rs             # Main component implementation
│   └── exports.rs         # WIT exports
├── metadata.json          # Tool metadata (see Section 6)
└── tests/
    └── integration_test.rs # Integration tests
```

### Cargo.toml Template

```toml
[package]
name = "tool-name"
version = "1.0.0"
edition = "2021"

[package.metadata.component]
package = "clawos:tools"

[package.metadata.component.target]
dependencies = [
    "clawos:kernel@2.0.0",
]

[dependencies]
# WIT bindings generated by cargo-component
wit-bindgen = "0.30"

[dev-dependencies]
wasmtime = "27"
```

### WIT Interface Usage

All tools must import the ClawOS kernel WIT interface:

```wit
// src/wit/deps.wit
package clawos:kernel@2.0.0;

// Import required interfaces
import filesystem: filesystem;
import network: network;
import system: system;
import logging: logging;
```

### Component Export Interface

Each tool must export a standardized interface:

```wit
// src/wit/tool.wit
package clawos:tools@1.0.0;

interface tool {
    /// Execute the tool with given parameters
    ///
    /// # Parameters
    /// - `params`: JSON-encoded tool parameters
    ///
    /// # Returns
    /// - JSON-encoded result or error
    execute: func(params: string) -> result<string>
}
```

### Resource Limits (P1.5)

Each component must declare its resource requirements:

```toml
[package.metadata.component.resources]
memory = "64MiB"           # Maximum memory allocation
cpu = "5%"                 # CPU quota (50000/1000000)
pids = 16                  # Maximum process count
timeout = "30s"            # Maximum execution time
```

---

## cargo-component Build Process

### Prerequisites

```bash
# Install Rust toolchain
rustup install stable
rustup default stable

# Install cargo-component
cargo install cargo-component --version 0.20+

# Install wasmtime (for testing)
cargo install wasmtime-cli --version 27+
```

### Build Workflow

#### Step 1: Initialize Component

```bash
# Create new component
cargo component new --lib tool-name

# Or add component to existing project
cd tool-name
cargo component add --wit ./wit
```

#### Step 2: Generate WIT Bindings

```bash
# Generate Rust bindings from WIT
cargo component build --bindings

# Output: target/wasm32-unknown-unknown/release/tool_name.wasm
```

#### Step 3: Build WASM Binary

```bash
# Build optimized WASM component
cargo component build --release

# Optimize for size (optional)
wasm-opt -Oz target/wasm32-unknown-unknown/release/tool_name.wasm \
  -o tool_name_optimized.wasm
```

#### Step 4: Validate Component

```bash
# Validate WIT interface
wasm-tools component wit tool_name.wasm

# Check component metadata
wasm-tools metadata tool_name.wasm
```

### Build Script (build.sh)

```bash
#!/bin/bash
set -e

TOOL_NAME="${1:?Usage: $0 <tool-name>}"
WIT_PATH="./wit"
OUTPUT_DIR="./target/wasm32-unknown-unknown/release"

echo "Building WASM component: $TOOL_NAME"

# Generate WIT bindings
cargo component build --bindings

# Build release binary
cargo component build --release

# Optimize WASM
wasm-opt -Oz \
  "${OUTPUT_DIR}/${TOOL_NAME}.wasm" \
  -o "${TOOL_NAME}.wasm"

# Validate component
wasm-tools component wit "${TOOL_NAME}.wasm"

# Generate SHA256 checksum
sha256sum "${TOOL_NAME}.wasm" > "${TOOL_NAME}.wasm.sha256"

echo "Build complete: ${TOOL_NAME}.wasm"
echo "SHA256: $(cat ${TOOL_NAME}.wasm.sha256)"
```

### CI/CD Integration

```yaml
# .github/workflows/build-wasm.yml
name: Build WASM Components

on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable

      - name: Install cargo-component
        run: cargo install cargo-component

      - name: Build components
        run: |
          for tool in tools/*/; do
            cd "$tool"
            cargo component build --release
            cd -
          done

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: wasm-components
          path: tools/*/*.wasm
```

---

## Tool Metadata Format

### metadata.json Schema

```json
{
  "$schema": "https://clawos.org/schemas/tool-metadata-v1.json",
  "name": "tool-name",
  "version": "1.0.0",
  "description": "Tool description",
  "category": "filesystem|network|process|data|security|system",
  "author": "ClawOS Project",
  "license": "Apache-2.0",
  "wasm": {
    "path": "tool-name.wasm",
    "sha256": "abc123...",
    "size": 12345,
    "abi": "wasm32-unknown-unknown"
  },
  "wit": {
    "package": "clawos:tools@1.0.0",
    "imports": ["clawos:kernel@2.0.0"],
    "exports": ["tool"]
  },
  "capabilities": {
    "filesystem": {
      "read": ["/clawfs/**"],
      "write": ["/clawfs/tools/tool-name/**"]
    },
    "network": {
      "allowed_hosts": ["api.example.com"],
      "allowed_ports": [443]
    },
    "system": {
      "env_vars": ["PATH", "HOME"],
      "max_processes": 1
    }
  },
  "permissions": {
    "required": ["filesystem.read", "network.outbound"],
    "optional": ["filesystem.write"]
  },
  "resources": {
    "memory": "64MiB",
    "cpu": "5%",
    "pids": 16,
    "timeout": "30s"
  },
  "parameters": {
    "type": "object",
    "properties": {
      "param1": {
        "type": "string",
        "description": "Parameter description"
      }
    },
    "required": ["param1"]
  },
  "returns": {
    "type": "object",
    "properties": {
      "result": {
        "type": "string",
        "description": "Result description"
      }
    }
  },
  "examples": [
    {
      "description": "Example usage",
      "input": {"param1": "value"},
      "output": {"result": "success"}
    }
  ],
  "tests": {
    "unit": ["tests/unit_test.rs"],
    "integration": ["tests/integration_test.rs"]
  },
  "dependencies": {
    "runtime": ["clawos:kernel@2.0.0"],
    "tools": []
  }
}
```

### Metadata Fields

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `name` | string | Yes | Tool identifier (kebab-case) |
| `version` | string | Yes | Semantic version (SemVer) |
| `description` | string | Yes | Human-readable description |
| `category` | enum | Yes | Tool category |
| `author` | string | Yes | Tool author/maintainer |
| `license` | string | Yes | SPDX license identifier |
| `wasm.path` | string | Yes | Path to WASM binary |
| `wasm.sha256` | string | Yes | SHA256 checksum |
| `capabilities` | object | Yes | Declared capabilities |
| `permissions` | object | Yes | Required/optional permissions |
| `resources` | object | Yes | Resource requirements |
| `parameters` | object | Yes | JSON Schema for input |
| `returns` | object | Yes | JSON Schema for output |
| `examples` | array | No | Usage examples |
| `tests` | object | No | Test file references |

### Capability Declarations

#### Filesystem Capabilities

```json
{
  "filesystem": {
    "read": [
      "/clawfs/**",
      "/etc/hosts"
    ],
    "write": [
      "/clawfs/tools/tool-name/**",
      "/tmp/tool-name/**"
    ],
    "execute": false
  }
}
```

#### Network Capabilities

```json
{
  "network": {
    "allowed_hosts": [
      "api.example.com",
      "*.github.com"
    ],
    "allowed_ports": [443, 80],
    "allowed_protocols": ["tcp", "udp"],
    "max_connections": 10
  }
}
```

#### System Capabilities

```json
{
  "system": {
    "env_vars": ["PATH", "HOME", "LANG"],
    "max_processes": 1,
    "allow_spawn": false,
    "allow_signals": false
  }
}
```

### Permission Levels

| Level | Description | Example |
|-------|-------------|---------|
| `none` | No access required | `system.allow_spawn: false` |
| `read` | Read-only access | `filesystem.read: ["/clawfs/**"]` |
| `write` | Write access | `filesystem.write: ["/tmp/**"]` |
| `execute` | Execute permissions | `filesystem.execute: true` |
| `admin` | Administrative access | `system.allow_spawn: true` |

---

## Integration with P2.6 WASM Bridge

### Bridge Architecture

```
┌─────────────────────────────────────────────────────────────┐
│ Tool Registry (D-06)                                         │
│ - Tool metadata stored in ClawFS                             │
│ - SHA256 verification                                        │
│ - Capability validation                                      │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ P2.6 WASM Runtime Bridge                                    │
│ - wasmtime 27+ runtime                                      │
│ - Component loader                                          │
│ - Resource enforcement                                       │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ WASM Component (Tool)                                        │
│ - WIT interface imports                                      │
│ - Tool implementation                                        │
│ - WIT interface exports                                      │
└─────────────────────────────────────────────────────────────┘
```

### Tool Loading Process

#### Step 1: Metadata Validation

```rust
// P2.6 bridge: tool_loader.rs
use clawos_registry::ToolMetadata;

pub async fn load_tool(name: &str) -> Result<LoadedTool, Error> {
    // 1. Read metadata from ClawFS
    let metadata_path = format!("/clawfs/tools/{}/metadata.json", name);
    let metadata: ToolMetadata = clawfs::read_json(&metadata_path).await?;

    // 2. Verify SHA256 checksum
    let wasm_path = format!("/clawfs/tools/{}/{}", name, metadata.wasm.path);
    let wasm_bytes = clawfs::read_bytes(&wasm_path).await?;
    let actual_sha256 = sha256::digest(&wasm_bytes);
    if actual_sha256 != metadata.wasm.sha256 {
        return Err(Error::ChecksumMismatch);
    }

    // 3. Validate capabilities
    validate_capabilities(&metadata.capabilities)?;

    // 4. Load WASM component
    let component = load_wasm_component(&wasm_bytes).await?;

    Ok(LoadedTool { metadata, component })
}
```

#### Step 2: Capability Enforcement

```rust
// P2.6 bridge: capability_enforcer.rs
use clawos_kernel::filesystem;
use clawos_kernel::network;

pub fn enforce_capabilities(
    tool: &ToolMetadata,
    operation: &Operation,
) -> Result<(), Error> {
    match operation {
        Operation::FileRead(path) => {
            if !tool.capabilities.filesystem.read.iter()
                .any(|pattern| glob_match(pattern, path)) {
                return Err(Error::PermissionDenied);
            }
        }
        Operation::NetworkConnect(host, port) => {
            if !tool.capabilities.network.allowed_hosts.iter()
                .any(|pattern| glob_match(pattern, host)) {
                return Err(Error::PermissionDenied);
            }
            if !tool.capabilities.network.allowed_ports.contains(&port) {
                return Err(Error::PermissionDenied);
            }
        }
        _ => {}
    }
    Ok(())
}
```

#### Step 3: Resource Limit Application

```rust
// P2.6 bridge: resource_manager.rs
use clawos_kernel::cgroup;

pub async fn apply_resource_limits(
    tool: &ToolMetadata,
    pid: u32,
) -> Result<(), Error> {
    let cg = cgroup::create(&format!("tool-{}", tool.name), "/clawos")?;

    // Apply memory limit
    let memory_limit = parse_memory(&tool.resources.memory)?;
    cg.set_memory_limit(memory_limit)?;

    // Apply CPU limit
    let cpu_quota = parse_cpu_quota(&tool.resources.cpu)?;
    cg.set_cpu_limit(cpu_quota.0, cpu_quota.1)?;

    // Apply PID limit
    cg.set_pid_limit(tool.resources.pids)?;

    // Add process to cgroup
    cgroup::add_process(&format!("/sys/fs/cgroup/clawos/tool-{}", tool.name), pid)?;

    Ok(())
}
```

### Tool Execution Flow

```
1. Agent requests tool execution
   ↓
2. Bridge validates tool metadata (SHA256, capabilities)
   ↓
3. Bridge creates isolated cgroup for tool
   ↓
4. Bridge loads WASM component into wasmtime
   ↓
5. Bridge applies resource limits (memory, CPU, PIDs)
   ↓
6. Tool executes via WIT interface
   ↓
7. eBPF LSM monitors all operations
   ↓
8. Bridge enforces capability checks
   ↓
9. Tool returns result or error
   ↓
10. Bridge cleans up resources
```

### Error Handling

All errors map to P1.7 IPC protocol error codes:

| Error | Code | Description |
|-------|------|-------------|
| `ToolNotFound` | 3 (ENOENT) | Tool metadata not found |
| `ChecksumMismatch` | 200 (invalid-handle) | WASM binary corrupted |
| `PermissionDenied` | 13 (EACCES) | Capability violation |
| `ResourceLimitExceeded` | 203 (quota-exceeded) | Resource limit hit |
| `Timeout` | 207 (timeout) | Execution timeout |
| `WasmTrap` | 102 (wasm-trap) | WASM runtime error |

---

## Migration Script Specification

### Migration Script (migrate_tool.sh)

```bash
#!/bin/bash
set -e

# Migration Script: IronClaw Tool → ClawOS WASM Component
# Usage: ./migrate_tool.sh <tool-name> <source-path>

TOOL_NAME="${1:?Usage: $0 <tool-name> <source-path>}"
SOURCE_PATH="${2:?Usage: $0 <tool-name> <source-path>}"
OUTPUT_DIR="./tools/${TOOL_NAME}"
WIT_DIR="./wit"

echo "=========================================="
echo "Migrating tool: ${TOOL_NAME}"
echo "Source: ${SOURCE_PATH}"
echo "Output: ${OUTPUT_DIR}"
echo "=========================================="

# Step 1: Analyze source tool
echo "[1/8] Analyzing source tool..."
python3 scripts/analyze_tool.py "${SOURCE_PATH}" > "${OUTPUT_DIR}/analysis.json"

# Step 2: Generate Rust component skeleton
echo "[2/8] Generating Rust component skeleton..."
cargo component new --lib "${OUTPUT_DIR}"

# Step 3: Generate WIT bindings
echo "[3/8] Generating WIT bindings..."
mkdir -p "${OUTPUT_DIR}/wit"
cp "${WIT_DIR}/deps.wit" "${OUTPUT_DIR}/wit/"
python3 scripts/generate_wit.py "${OUTPUT_DIR}/analysis.json" > "${OUTPUT_DIR}/wit/tool.wit"

# Step 4: Generate Rust implementation
echo "[4/8] Generating Rust implementation..."
python3 scripts/generate_rust.py "${OUTPUT_DIR}/analysis.json" > "${OUTPUT_DIR}/src/lib.rs"

# Step 5: Generate metadata.json
echo "[5/8] Generating metadata.json..."
python3 scripts/generate_metadata.py "${OUTPUT_DIR}/analysis.json" > "${OUTPUT_DIR}/metadata.json"

# Step 6: Build WASM component
echo "[6/8] Building WASM component..."
cd "${OUTPUT_DIR}"
cargo component build --release
cd -

# Step 7: Optimize WASM binary
echo "[7/8] Optimizing WASM binary..."
wasm-opt -Oz \
  "${OUTPUT_DIR}/target/wasm32-unknown-unknown/release/${TOOL_NAME}.wasm" \
  -o "${OUTPUT_DIR}/${TOOL_NAME}.wasm"

# Step 8: Generate SHA256 checksum
echo "[8/8] Generating SHA256 checksum..."
sha256sum "${OUTPUT_DIR}/${TOOL_NAME}.wasm" > "${OUTPUT_DIR}/${TOOL_NAME}.wasm.sha256"

echo "=========================================="
echo "Migration complete!"
echo "Output: ${OUTPUT_DIR}/${TOOL_NAME}.wasm"
echo "SHA256: $(cat ${OUTPUT_DIR}/${TOOL_NAME}.wasm.sha256)"
echo "=========================================="
```

### Analysis Script (analyze_tool.py)

```python
#!/usr/bin/env python3
"""
Analyze IronClaw tool source code and extract metadata.
"""

import ast
import json
import sys
from pathlib import Path

def analyze_tool(source_path: str) -> dict:
    """Analyze tool source code and extract metadata."""
    source = Path(source_path).read_text()

    # Parse Python AST
    tree = ast.parse(source)

    # Extract metadata
    metadata = {
        "name": Path(source_path).stem,
        "language": "python",
        "functions": [],
        "imports": [],
        "dependencies": [],
        "capabilities": {
            "filesystem": {"read": [], "write": []},
            "network": {"allowed_hosts": [], "allowed_ports": []},
            "system": {"env_vars": [], "max_processes": 1}
        }
    }

    # Extract imports
    for node in ast.walk(tree):
        if isinstance(node, ast.Import):
            for alias in node.names:
                metadata["imports"].append(alias.name)
        elif isinstance(node, ast.ImportFrom):
            metadata["imports"].append(node.module)

    # Extract function definitions
    for node in ast.walk(tree):
        if isinstance(node, ast.FunctionDef):
            func_info = {
                "name": node.name,
                "args": [arg.arg for arg in node.args.args],
                "returns": ast.unparse(node.returns) if node.returns else None
            }
            metadata["functions"].append(func_info)

    # Detect capabilities from code patterns
    if "open(" in source or "Path(" in source:
        metadata["capabilities"]["filesystem"]["read"].append("/clawfs/**")
    if "requests." in source or "urllib." in source:
        metadata["capabilities"]["network"]["allowed_ports"] = [443, 80]
    if "os.environ" in source:
        metadata["capabilities"]["system"]["env_vars"] = ["PATH", "HOME"]

    return metadata

if __name__ == "__main__":
    source_path = sys.argv[1]
    metadata = analyze_tool(source_path)
    print(json.dumps(metadata, indent=2))
```

### WIT Generation Script (generate_wit.py)

```python
#!/usr/bin/env python3
"""
Generate WIT interface from tool analysis.
"""

import json
import sys

def generate_wit(analysis: dict) -> str:
    """Generate WIT interface from analysis."""
    functions = analysis.get("functions", [])

    wit = f"""package clawos:tools@1.0.0;

import filesystem: filesystem;
import network: network;
import system: system;
import logging: logging;

interface tool {{
    /// Execute the {analysis['name']} tool
    ///
    /// # Parameters
    /// - `params`: JSON-encoded tool parameters
    ///
    /// # Returns
    /// - JSON-encoded result or error
    execute: func(params: string) -> result<string>
}}
"""
    return wit

if __name__ == "__main__":
    analysis = json.load(sys.stdin)
    print(generate_wit(analysis))
```

### Rust Generation Script (generate_rust.py)

```python
#!/usr/bin/env python3
"""
Generate Rust implementation from tool analysis.
"""

import json
import sys

def generate_rust(analysis: dict) -> str:
    """Generate Rust implementation from analysis."""
    name = analysis["name"]

    rust = f"""//! {name} - ClawOS WASM Tool
//!
//! Migrated from IronClaw Python tool.

use clawos_kernel::filesystem;
use clawos_kernel::network;
use clawos_kernel::system;
use clawos_kernel::logging;

/// Execute the tool with given parameters
///
/// # Parameters
/// - `params`: JSON-encoded tool parameters
///
/// # Returns
/// - JSON-encoded result or error
#[export_name = "execute"]
pub extern "C" fn execute(params: String) -> Result<String, String> {{
    logging::info(&format!("Executing tool: {{}}", "{name}"));

    // Parse parameters
    let _params: serde_json::Value = serde_json::from_str(&params)
        .map_err(|e| format!("Invalid parameters: {{}}", e))?;

    // TODO: Implement tool logic here
    // This is a placeholder - replace with actual implementation

    let result = serde_json::json!({{
        "status": "success",
        "message": "Tool executed successfully"
    }});

    Ok(result.to_string())
}}
"""
    return rust

if __name__ == "__main__":
    analysis = json.load(sys.stdin)
    print(generate_rust(analysis))
```

### Metadata Generation Script (generate_metadata.py)

```python
#!/usr/bin/env python3
"""
Generate tool metadata from analysis.
"""

import json
import sys
from datetime import datetime

def generate_metadata(analysis: dict) -> str:
    """Generate metadata from analysis."""
    name = analysis["name"]

    metadata = {
        "$schema": "https://clawos.org/schemas/tool-metadata-v1.json",
        "name": name,
        "version": "1.0.0",
        "description": f"Migrated from IronClaw {name} tool",
        "category": "filesystem",  # TODO: Detect from analysis
        "author": "ClawOS Project",
        "license": "Apache-2.0",
        "wasm": {
            "path": f"{name}.wasm",
            "sha256": "",  # Filled by build script
            "size": 0,     # Filled by build script
            "abi": "wasm32-unknown-unknown"
        },
        "wit": {
            "package": "clawos:tools@1.0.0",
            "imports": ["clawos:kernel@2.0.0"],
            "exports": ["tool"]
        },
        "capabilities": analysis["capabilities"],
        "permissions": {
            "required": ["filesystem.read"],
            "optional": []
        },
        "resources": {
            "memory": "64MiB",
            "cpu": "5%",
            "pids": 16,
            "timeout": "30s"
        },
        "parameters": {
            "type": "object",
            "properties": {},
            "required": []
        },
        "returns": {
            "type": "object",
            "properties": {
                "status": {"type": "string"},
                "message": {"type": "string"}
            }
        },
        "examples": [],
        "tests": {
            "unit": ["tests/unit_test.rs"],
            "integration": ["tests/integration_test.rs"]
        },
        "dependencies": {
            "runtime": ["clawos:kernel@2.0.0"],
            "tools": []
        },
        "migrated_at": datetime.utcnow().isoformat(),
        "original_language": analysis["language"],
        "original_functions": analysis["functions"]
    }

    return json.dumps(metadata, indent=2)

if __name__ == "__main__":
    analysis = json.load(sys.stdin)
    print(generate_metadata(analysis))
```

---

## Test Procedures

### Unit Tests

#### Test Template (tests/unit_test.rs)

```rust
//! Unit tests for tool-name

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_execute_with_valid_params() {
        let params = r#"{"param1": "value"}"#;
        let result = execute(params.to_string());
        assert!(result.is_ok());
    }

    #[test]
    fn test_execute_with_invalid_params() {
        let params = r#"invalid json"#;
        let result = execute(params.to_string());
        assert!(result.is_err());
    }

    #[test]
    fn test_execute_returns_valid_json() {
        let params = r#"{}"#;
        let result = execute(params.to_string()).unwrap();
        let json: serde_json::Value = serde_json::from_str(&result).unwrap();
        assert!(json.is_object());
    }
}
```

### Integration Tests

#### Test Template (tests/integration_test.rs)

```rust
//! Integration tests for tool-name

use wasmtime::{Engine, Module, Store};
use wasmtime_wasi::{WasiCtx, WasiCtxBuilder};

#[tokio::test]
async fn test_tool_execution() {
    // Initialize wasmtime
    let engine = Engine::default();
    let module = Module::from_file(&engine, "tool-name.wasm").unwrap();

    // Create WASI context
    let wasi = WasiCtxBuilder::new()
        .inherit_stdio()
        .build();

    let mut store = Store::new(&engine, wasi);

    // Instantiate module
    let instance = Instance::new(&mut store, &module, &[]).unwrap();

    // Call execute function
    let execute = instance.get_typed_func::<(String,), (String,)>(&mut store, "execute").unwrap();
    let result = execute.call(&mut store, (r#"{}"#.to_string())).unwrap();

    // Verify result
    let json: serde_json::Value = serde_json::from_str(&result).unwrap();
    assert_eq!(json["status"], "success");
}

#[tokio::test]
async fn test_resource_limits() {
    // Test that tool respects resource limits
    // This test requires cgroup setup
}

#[tokio::test]
async fn test_capability_enforcement() {
    // Test that tool cannot access unauthorized resources
    // This test requires P2.6 bridge
}
```

### Test Script (test_tool.sh)

```bash
#!/bin/bash
set -e

TOOL_NAME="${1:?Usage: $0 <tool-name>}"

echo "Testing tool: ${TOOL_NAME}"

# Run unit tests
echo "[1/3] Running unit tests..."
cd "tools/${TOOL_NAME}"
cargo test --lib

# Run integration tests
echo "[2/3] Running integration tests..."
cargo test --test integration_test

# Validate WASM component
echo "[3/3] Validating WASM component..."
wasm-tools component wit "${TOOL_NAME}.wasm"
wasm-tools validate "${TOOL_NAME}.wasm"

echo "All tests passed!"
```

### Performance Benchmarks

#### Benchmark Script (benchmark_tool.sh)

```bash
#!/bin/bash
set -e

TOOL_NAME="${1:?Usage: $0 <tool-name>}"
ITERATIONS="${2:-100}"

echo "Benchmarking tool: ${TOOL_NAME}"
echo "Iterations: ${ITERATIONS}"

# Warm-up
echo "Warm-up..."
for i in {1..10}; do
    wasmtime tools/${TOOL_NAME}/${TOOL_NAME}.wasm --invoke execute '{}'
done

# Benchmark
echo "Benchmarking..."
START=$(date +%s%N)
for i in $(seq 1 $ITERATIONS); do
    wasmtime tools/${TOOL_NAME}/${TOOL_NAME}.wasm --invoke execute '{}'
done
END=$(date +%s%N)

# Calculate statistics
DURATION=$((($END - $START) / 1000000))
AVG=$(($DURATION / $ITERATIONS))

echo "Total duration: ${DURATION}ms"
echo "Average per iteration: ${AVG}ms"
echo "Throughput: $(echo "scale=2; 1000 / $AVG" | bc) ops/sec"
```

### Security Tests

#### Security Test Script (security_test.sh)

```bash
#!/bin/bash
set -e

TOOL_NAME="${1:?Usage: $0 <tool-name>}"

echo "Running security tests for: ${TOOL_NAME}"

# Test 1: Verify no direct syscalls
echo "[1/5] Checking for direct syscalls..."
if wasm-objdump -d "tools/${TOOL_NAME}/${TOOL_NAME}.wasm" | grep -q "call.*syscall"; then
    echo "FAIL: Direct syscalls detected!"
    exit 1
fi
echo "PASS: No direct syscalls"

# Test 2: Verify WIT interface usage
echo "[2/5] Checking WIT interface usage..."
if ! wasm-tools component wit "tools/${TOOL_NAME}/${TOOL_NAME}.wasm" | grep -q "clawos:kernel"; then
    echo "FAIL: WIT interface not imported!"
    exit 1
fi
echo "PASS: WIT interface imported"

# Test 3: Verify memory isolation
echo "[3/5] Checking memory isolation..."
# This requires runtime testing with P2.6 bridge
echo "SKIP: Requires P2.6 bridge"

# Test 4: Verify capability enforcement
echo "[4/5] Checking capability enforcement..."
# This requires runtime testing with P2.6 bridge
echo "SKIP: Requires P2.6 bridge"

# Test 5: Verify resource limits
echo "[5/5] Checking resource limits..."
# This requires runtime testing with P2.6 bridge
echo "SKIP: Requires P2.6 bridge"

echo "Security tests complete!"
```

---

## Migration Checklist

### Pre-Migration Checklist

- [ ] P1.1 WIT Interface Specification reviewed
- [ ] P1.5 cgroup Resource Quotas reviewed
- [ ] P1.7 IPC Protocol reviewed
- [ ] P2.6 WASM Bridge architecture understood
- [ ] D-05, D-06 dependencies confirmed
- [ ] Rust toolchain installed (1.85+)
- [ ] cargo-component installed (0.20+)
- [ ] wasmtime installed (27+)
- [ ] wasm-opt installed (for optimization)

### Tool-Specific Checklist

For each tool to migrate:

- [ ] Source code analyzed (analyze_tool.py)
- [ ] WIT interface generated (generate_wit.py)
- [ ] Rust implementation generated (generate_rust.py)
- [ ] Metadata generated (generate_metadata.py)
- [ ] WASM component built (cargo component build)
- [ ] WASM binary optimized (wasm-opt)
- [ ] SHA256 checksum generated
- [ ] Unit tests written and passing
- [ ] Integration tests written and passing
- [ ] Security tests passing
- [ ] Performance benchmarks acceptable
- [ ] Metadata validated against schema
- [ ] WIT interface validated
- [ ] Resource limits tested

### Post-Migration Checklist

- [ ] All tools migrated (19 total)
- [ ] Tool registry updated (D-06)
- [ ] ClawFS deployment complete
- [ ] P2.6 bridge integration tested
- [ ] End-to-end workflow tested
- [ ] Documentation updated
- [ ] Migration report generated

---

## Appendices

### Appendix A: Tool Migration Matrix

| Original Tool | Category | Target WASM Tool | Status | Notes |
|---------------|----------|------------------|--------|-------|
| `read_file.py` | Filesystem | `read-file` | Pending | Simple migration |
| `write_file.py` | Filesystem | `write-file` | Pending | Simple migration |
| `list_dir.py` | Filesystem | `list-dir` | Pending | Simple migration |
| `file_info.py` | Filesystem | `file-info` | Pending | Simple migration |
| `http_request.py` | Network | `http-request` | Pending | Replace requests crate |
| `dns_resolve.py` | Network | `dns-resolve` | Pending | Use WIT network::resolve |
| `tcp_connect.py` | Network | `tcp-connect` | Pending | Use WIT network interface |
| `execute.py` | Process | `execute` | Pending | High complexity |
| `spawn.py` | Process | `spawn` | Pending | High complexity |
| `monitor.py` | Process | `monitor` | Pending | High complexity |
| `parse_json.py` | Data | `parse-json` | Pending | Use serde_json |
| `transform.py` | Data | `transform` | Pending | Medium complexity |
| `validate.py` | Data | `validate` | Pending | Medium complexity |
| `encrypt.py` | Security | `encrypt` | Pending | Use ring crate |
| `decrypt.py` | Security | `decrypt` | Pending | Use ring crate |
| `hash.py` | Security | `hash` | Pending | Use ring crate |
| `get_env.py` | System | `get-env` | Pending | Use WIT system::get_env |
| `set_env.py` | System | `set-env` | Pending | Use WIT system::set_env |
| `system_info.py` | System | `system-info` | Pending | Use WIT system::get_info |

### Appendix B: Error Code Reference

| Code | Name | Description | Handling |
|------|------|-------------|----------|
| 0 | SUCCESS | Operation completed successfully | Return result |
| 1 | EAGAIN | Operation would block | Retry with backoff |
| 2 | EIO | I/O error | Log and return error |
| 3 | ENOENT | Entity not found | Return 404 equivalent |
| 13 | EACCES | Permission denied | Log security violation |
| 100 | wasm-alloc-failed | WASM memory allocation failed | Reduce memory usage |
| 101 | wasm-stack-overflow | WASM stack overflow | Reduce recursion depth |
| 102 | wasm-trap | WASM trap occurred | Log trap details |
| 200 | invalid-handle | Invalid resource handle | Verify handle validity |
| 201 | resource-closed | Resource already closed | Check resource state |
| 202 | security-denied | Permission denied by security policy | Review capabilities |
| 203 | quota-exceeded | Resource quota exceeded | Adjust resource limits |
| 207 | timeout | Operation timed out | Increase timeout or optimize |

### Appendix C: Resource Limit Reference

| Resource | Default | Maximum | Unit |
|----------|---------|---------|------|
| Memory | 64MiB | 256MiB | Bytes |
| CPU | 5% | 50% | Percentage |
| PIDs | 16 | 64 | Count |
| Timeout | 30s | 300s | Seconds |
| File Descriptors | 64 | 256 | Count |
| Sockets | 8 | 32 | Count |

### Appendix D: WIT Interface Quick Reference

#### Filesystem Interface

```wit
open: func(path: string, flags: open-flags, mode: file-permissions) -> result<file-descriptor>
read: func(fd: file-descriptor, buffer: list<u8>, max-bytes: u32) -> result<u32>
write: func(fd: file-descriptor, data: list<u8>) -> result<u32>
close: func(fd: file-descriptor) -> result<_>
stat: func(path: string) -> result<file-stat>
```

#### Network Interface

```wit
socket: func(domain: u32, type: u32, protocol: u32) -> result<socket>
connect: func(socket: socket, host: string, port: u16) -> result<_>
send: func(socket: socket, data: list<u8>) -> result<u32>
recv: func(socket: socket, buffer: list<u8>, max-bytes: u32) -> result<u32>
resolve: func(hostname: string) -> result<string>
```

#### System Interface

```wit
get-info: func() -> result<system-info>
get-time: func() -> result<u64>
get-env: func(name: string) -> result<string>
set-env: func(name: string, value: string) -> result<_>
get-pid: func() -> result<u32>
```

#### Logging Interface

```wit
log: func(level: u32, message: string) -> _
debug: func(message: string) -> _
info: func(message: string) -> _
warn: func(message: string) -> _
error: func(message: string) -> _
```

### Appendix E: Migration Timeline

| Week | Tasks | Deliverables |
|------|-------|--------------|
| W1 | Tool inventory, analysis scripts | Tool analysis reports |
| W2 | WIT interface generation, Rust skeleton | WIT definitions, Rust templates |
| W3 | Build process setup, metadata generation | Build scripts, metadata schemas |
| W4 | Migrate filesystem tools (4) | 4 WASM components |
| W5 | Migrate network tools (3) | 3 WASM components |
| W6 | Migrate process tools (3) | 3 WASM components |
| W7 | Migrate data tools (3) | 3 WASM components |
| W8 | Migrate security tools (3) | 3 WASM components |
| W9 | Migrate system tools (3) | 3 WASM components |
| W10 | Integration testing, bug fixes | Test reports |
| W11 | Performance optimization | Benchmark results |
| W12 | Documentation, deployment | Migration report |

---

## Document Control

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 1.0.0 | 2026-02-24 | WASM Agent | Initial draft |

---

## References

1. **P1.1**: WIT Interface Specification (v2.0.0)
2. **P1.5**: cgroup v2 Resource Quotas
3. **P1.7**: IPC Protocol
4. **P2.6**: WASM Runtime Bridge
5. **SKILLS.md**: D-05, D-06 dependencies
6. **IronClaw**: nearai/ironclaw repository
7. **wasmtime**: https://github.com/bytecodealliance/wasmtime
8. **cargo-component**: https://github.com/bytecodealliance/cargo-component
9. **WIT**: https://github.com/WebAssembly/component-model

---

**END OF DOCUMENT**
