# P3.4 â€” Identity Files and Workspace Initialization Specification

**Status:** ðŸ“ **DRAFT**
**Version:** 1.0.0
**Date:** 2026-02-24
**Owner:** FS Engineer Agent
**Dependencies:** P1.4 ClawFS Spec (Section 5: Identity Files)

---

## Overview

This specification defines the initialization and management of **Identity Files** and **Agent Workspaces** in ClawOS. 
Identity Files serve as the persistent kernel memory mechanism for AI agents, 
storing learned patterns, heuristics, and execution state across sessions.

**Key Components:**
- **Identity Files**: Persistent agent state with learned patterns and heuristics
- **Workspace Structure**: Isolated directories for each of 8 agents
- **Initialization Scripts**: Automated data population and setup
- **Configuration Formats**: JSON schemas for agent and system configuration
- **Kernel Memory Storage**: Persistent storage format for agent knowledge
- **Checksum Verification**: SHA-256 integrity validation

---

## 1. Identity Files Schema

### 1.1 Purpose and Scope

Identity Files are the **persistent kernel memory** for ClawOS agents. They enable:
- **State Persistence**: Agent state survives restarts and reboots
- **Learning Retention**: Learned patterns and heuristics persist across sessions
- **Performance Tracking**: Historical execution metrics for optimization
- **Context Continuity**: Seamless resumption of interrupted tasks

### 1.2 File Location

```
/clawfs/agents/{agent-name}/identity.json
```

**Agent Names** (from SKILLS.md):
- `kernel-engine`
- `ebpf-agent`
- `security-agent`
- `core-dev-agent`
- `wasm-agent`
- `fs-engine`
- `observability`
- `build-engine`

### 1.3 Complete Identity File Schema

```json
{
  "agent_id": "kernel-engine",
  "version": 1,
  "created_at": "2024-02-24T00:00:00Z",
  "updated_at": "2024-02-24T12:34:56Z",

  "state": {
    "current_phase": "P2",
    "current_task": "A-01",
    "last_checkpoint": "2024-02-24T10:00:00Z",
    "status": "in_progress",
    "subtasks": {
      "active": ["subtask-001", "subtask-002"],
      "completed": ["subtask-000"],
      "blocked": []
    },
    "context": {
      "workspace_id": "default",
      "session_id": "ses_abc123",
      "parent_task_id": null
    }
  },

  "memory": {
    "learned_patterns": [
      {
        "pattern_id": "syscall-pattern-001",
        "description": "Tokio async runtime requires epoll_wait",
        "pattern_type": "syscall_dependency",
        "confidence": 0.95,
        "learned_at": "2024-02-20T15:30:00Z",
        "usage_count": 42,
        "last_used": "2024-02-24T10:00:00Z",
        "validation_count": 38,
        "validation_success_rate": 0.90,
        "source": "observation",
        "tags": ["tokio", "async", "epoll"]
      }
    ],
    "heuristics": [
      {
        "heuristic_id": "resource-estimation-001",
        "rule": "cgroup pids.max >= tokio_threads + wasm_workers + 10",
        "rule_type": "resource_allocation",
        "accuracy": 0.88,
        "last_validated": "2024-02-23T09:00:00Z",
        "validation_count": 25,
        "created_at": "2024-02-15T10:00:00Z",
        "applicable_phases": ["P2", "P3", "P4"],
        "confidence": 0.85
      }
    ],
    "knowledge_graph": {
      "nodes": [
        {
          "node_id": "tokio-runtime",
          "type": "component",
          "properties": {
            "name": "Tokio Async Runtime",
            "version": "1.35.0",
            "language": "Rust"
          }
        }
      ],
      "edges": [
        {
          "source": "tokio-runtime",
          "target": "epoll_wait",
          "relation": "requires",
          "weight": 0.95
        }
      ]
    }
  },

  "history": {
    "completed_tasks": ["A-01", "A-02", "B-01"],
    "failed_tasks": [],
    "total_executions": 156,
    "success_rate": 0.97,
    "avg_execution_time_ms": 2340,
    "task_breakdown": {
      "P1": { "completed": 12, "failed": 0, "avg_time_ms": 1800 },
      "P2": { "completed": 45, "failed": 1, "avg_time_ms": 2100 },
      "P3": { "completed": 89, "failed": 2, "avg_time_ms": 2500 },
      "P4": { "completed": 10, "failed": 0, "avg_time_ms": 3000 }
    },
    "recent_errors": [
      {
        "error_id": "err-001",
        "error_type": "timeout",
        "message": "Task execution exceeded timeout",
        "occurred_at": "2024-02-23T14:30:00Z",
        "task_id": "C-05",
        "resolved": true,
        "resolution": "Increased timeout threshold"
      }
    ]
  },

  "performance": {
    "avg_execution_time_ms": 2340,
    "peak_memory_mb": 512,
    "last_benchmark": "2024-02-23T18:00:00Z",
    "benchmark_results": {
      "task_throughput_per_hour": 15.5,
      "memory_efficiency": 0.78,
      "cpu_efficiency": 0.85,
      "io_efficiency": 0.72
    },
    "optimization_history": [
      {
        "optimization_id": "opt-001",
        "description": "Reduced memory allocation in pattern matching",
        "applied_at": "2024-02-22T10:00:00Z",
        "improvement": "memory_usage -15%"
      }
    ]
  },

  "preferences": {
    "default_workspace": "default",
    "log_level": "info",
    "parallel_tasks": 3,
    "timeout_seconds": 300,
    "retry_policy": {
      "max_retries": 3,
      "backoff_multiplier": 2.0,
      "initial_delay_ms": 1000
    },
    "resource_limits": {
      "max_memory_mb": 1024,
      "max_cpu_percent": 80,
      "max_io_ops_per_sec": 1000
    }
  },

  "checksum": "sha256:abc123..."
}
```

### 1.4 Schema Field Descriptions

#### State Section

| Field             | Type              | Description                               |
| ------------------| ------------------| ------------------------------------------|
| `current_phase`   | string            | Current development phase (P1-P4)         |
| `current_task`    | string            | Active task identifier                    |
| `last_checkpoint` | ISO8601 timestamp | Last state checkpoint time                |
| `status`          | enum              | `idle`, `in_progress`, `blocked`, `error` |
| `subtasks`        | object            | Active, completed, and blocked subtasks   |
| `context`         | object            | Current execution context                 |

#### Memory Section

| Field              | Type   | Description                               |
| -------------------| -------| ------------------------------------------|
| `learned_patterns` | array  | Array of learned execution patterns       |
| `heuristics`       | array  | Array of heuristic rules                  |
| `knowledge_graph`  | object | Graph representation of learned knowledge |

**Learned Pattern Schema:**
```json
{
  "pattern_id": "unique-identifier",
  "description": "Human-readable description",
| code_pattern |
  "confidence": 0.0-1.0,
  "learned_at": "ISO8601 timestamp",
  "usage_count": integer,
  "last_used": "ISO8601 timestamp",
  "validation_count": integer,
  "validation_success_rate": 0.0-1.0,
| user_input |
  "tags": ["tag1", "tag2"]
}
```

**Heuristic Schema:**
```json
{
  "heuristic_id": "unique-identifier",
  "rule": "Rule description or expression",
| error_prediction |
  "accuracy": 0.0-1.0,
  "last_validated": "ISO8601 timestamp",
  "validation_count": integer,
  "created_at": "ISO8601 timestamp",
  "applicable_phases": ["P1", "P2", "P3", "P4"],
  "confidence": 0.0-1.0
}
```

#### History Section

| Field              | Type    | Description                     |
| -------------------| --------| --------------------------------|
| `completed_tasks`  | array   | List of completed task IDs      |
| `failed_tasks`     | array   | List of failed task IDs         |
| `total_executions` | integer | Total number of task executions |
| `success_rate`     | float   | Overall success rate (0.0-1.0)  |
| `task_breakdown`   | object  | Per-phase statistics            |
| `recent_errors`    | array   | Recent error history            |

#### Performance Section

| Field                   | Type              | Description              |
| ------------------------| ------------------| -------------------------|
| `avg_execution_time_ms` | integer           | Average execution time   |
| `peak_memory_mb`        | integer           | Peak memory usage        |
| `last_benchmark`        | ISO8601 timestamp | Last benchmark timestamp |
| `benchmark_results`     | object            | Performance metrics      |
| `optimization_history`  | array             | Applied optimizations    |

#### Preferences Section

| Field               | Type    | Description          |
| --------------------| --------| ---------------------|
| `default_workspace` | string  | Default workspace ID |
| `log_level`         | string  | Logging level        |
| `parallel_tasks`    | integer | Max parallel tasks   |
| `timeout_seconds`   | integer | Default timeout      |
| `retry_policy`      | object  | Retry configuration  |
| `resource_limits`   | object  | Resource constraints |

---

## 2. Workspace Directory Structure

### 2.1 Complete Agent Workspace Layout

```
/clawfs/agents/
â”œâ”€â”€ kernel-engine/
â”‚   â”œâ”€â”€ identity.json                 # Agent identity file (Section 1)
â”‚   â”œâ”€â”€ workspace.db                  # SQLite + HNSW database
â”‚   â”œâ”€â”€ state.json                    # Runtime state snapshot
â”‚   â”œâ”€â”€ config.json                   # Agent-specific configuration
â”‚   â”œâ”€â”€ logs/
â”‚   â”‚   â”œâ”€â”€ agent-2024-02-24.log      # Daily logs (RULE-007)
â”‚   â”‚   â”œâ”€â”€ agent-2024-02-25.log
â”‚   â”‚   â””â”€â”€ .gitkeep
â”‚   â”œâ”€â”€ cache/                        # Temporary cache files
â”‚   â”‚   â”œâ”€â”€ embeddings/
â”‚   â”‚   â”œâ”€â”€ patterns/
â”‚   â”‚   â””â”€â”€ .gitkeep
â”‚   â”œâ”€â”€ checkpoints/                  # State checkpoints
â”‚   â”‚   â”œâ”€â”€ checkpoint-2024-02-24-100000.json
â”‚   â”‚   â””â”€â”€ .gitkeep
â”‚   â”œâ”€â”€ backups/                      # Identity file backups
â”‚   â”‚   â”œâ”€â”€ identity-2024-02-24-000000.json
â”‚   â”‚   â””â”€â”€ .gitkeep
â”‚   â””â”€â”€ .gitkeep
â”œâ”€â”€ ebpf-agent/
â”‚   â”œâ”€â”€ identity.json
â”‚   â”œâ”€â”€ workspace.db
â”‚   â”œâ”€â”€ state.json
â”‚   â”œâ”€â”€ config.json
â”‚   â”œâ”€â”€ logs/
â”‚   â”œâ”€â”€ cache/
â”‚   â”œâ”€â”€ checkpoints/
â”‚   â””â”€â”€ backups/
â”œâ”€â”€ security-agent/
â”‚   â”œâ”€â”€ identity.json
â”‚   â”œâ”€â”€ workspace.db
â”‚   â”œâ”€â”€ state.json
â”‚   â”œâ”€â”€ config.json
â”‚   â”œâ”€â”€ logs/
â”‚   â”œâ”€â”€ cache/
â”‚   â”œâ”€â”€ checkpoints/
â”‚   â””â”€â”€ backups/
â”œâ”€â”€ core-dev-agent/
â”‚   â”œâ”€â”€ identity.json
â”‚   â”œâ”€â”€ workspace.db
â”‚   â”œâ”€â”€ state.json
â”‚   â”œâ”€â”€ config.json
â”‚   â”œâ”€â”€ logs/
â”‚   â”œâ”€â”€ cache/
â”‚   â”œâ”€â”€ checkpoints/
â”‚   â””â”€â”€ backups/
â”œâ”€â”€ wasm-agent/
â”‚   â”œâ”€â”€ identity.json
â”‚   â”œâ”€â”€ workspace.db
â”‚   â”œâ”€â”€ state.json
â”‚   â”œâ”€â”€ config.json
â”‚   â”œâ”€â”€ logs/
â”‚   â”œâ”€â”€ cache/
â”‚   â”œâ”€â”€ checkpoints/
â”‚   â””â”€â”€ backups/
â”œâ”€â”€ fs-engine/
â”‚   â”œâ”€â”€ identity.json
â”‚   â”œâ”€â”€ workspace.db
â”‚   â”œâ”€â”€ state.json
â”‚   â”œâ”€â”€ config.json
â”‚   â”œâ”€â”€ logs/
â”‚   â”œâ”€â”€ cache/
â”‚   â”œâ”€â”€ checkpoints/
â”‚   â””â”€â”€ backups/
â”œâ”€â”€ observability/
â”‚   â”œâ”€â”€ identity.json
â”‚   â”œâ”€â”€ workspace.db
â”‚   â”œâ”€â”€ state.json
â”‚   â”œâ”€â”€ config.json
â”‚   â”œâ”€â”€ logs/
â”‚   â”œâ”€â”€ cache/
â”‚   â”œâ”€â”€ checkpoints/
â”‚   â””â”€â”€ backups/
â””â”€â”€ build-engine/
    â”œâ”€â”€ identity.json
    â”œâ”€â”€ workspace.db
    â”œâ”€â”€ state.json
    â”œâ”€â”€ config.json
    â”œâ”€â”€ logs/
    â”œâ”€â”€ cache/
    â”œâ”€â”€ checkpoints/
    â””â”€â”€ backups/
```

### 2.2 Directory Permissions

| Directory                              | Owner | Group         | Permissions | Purpose                    |
| ---------------------------------------| ------| --------------| ------------| ---------------------------|
| `/clawfs/agents/`                      | root  | clawos-agents | 0750        | Agent workspace root       |
| `/clawfs/agents/{agent}/`              | root  | clawos-agents | 0750        | Individual agent workspace |
| `/clawfs/agents/{agent}/identity.json` | root  | clawos-agents | 0640        | Identity file              |
| `/clawfs/agents/{agent}/workspace.db`  | root  | clawos-agents | 0640        | Workspace database         |
| `/clawfs/agents/{agent}/logs/`         | root  | clawos-agents | 0750        | Log files                  |
| `/clawfs/agents/{agent}/cache/`        | root  | clawos-agents | 0750        | Temporary cache            |
| `/clawfs/agents/{agent}/checkpoints/`  | root  | clawos-agents | 0750        | State checkpoints          |
| `/clawfs/agents/{agent}/backups/`      | root  | clawos-agents | 0750        | Identity backups           |

### 2.3 Directory Creation Rules

**RULE-001**: Agent cannot write outside its own directory
**RULE-002**: Each agent has isolated workspace.db
**RULE-003**: Identity files are backed up before modification
**RULE-004**: Log files are rotated daily (RULE-007 from P1.4)

---

## 3. Configuration File Formats

### 3.1 Agent Configuration Schema

**Location:** `/clawfs/agents/{agent-name}/config.json`

```json
{
  "agent_id": "kernel-engine",
  "version": 1,
  "created_at": "2024-02-24T00:00:00Z",
  "updated_at": "2024-02-24T12:34:56Z",

  "capabilities": {
    "allowed_operations": [
      "read_workspace",
      "write_workspace",
      "execute_task",
      "create_checkpoint",
      "learn_pattern"
    ],
    "restricted_operations": [
      "modify_system_files",
      "access_other_agents"
    ],
    "resource_limits": {
      "max_memory_mb": 1024,
      "max_cpu_percent": 80,
      "max_disk_io_mb_per_sec": 100,
      "max_network_connections": 10
    }
  },

  "workspace_config": {
    "default_workspace_id": "default",
    "vector_dimension": 1536,
    "hnsw_params": {
      "m": 16,
      "ef_construction": 200,
      "ef_search": 50
    },
    "max_cache_size_mb": 256
  },

  "learning_config": {
    "pattern_learning_enabled": true,
    "heuristic_learning_enabled": true,
    "min_confidence_threshold": 0.7,
    "max_patterns": 1000,
    "max_heuristics": 500,
    "pattern_decay_days": 90,
    "heuristic_validation_interval_hours": 24
  },

  "logging_config": {
    "log_level": "info",
    "log_format": "json",
    "log_retention_days": 30,
    "log_rotation": "daily",
    "log_to_file": true,
    "log_to_console": false
  },

  "checkpoint_config": {
    "auto_checkpoint_enabled": true,
    "checkpoint_interval_minutes": 30,
    "max_checkpoints": 10,
    "checkpoint_on_task_completion": true,
    "checkpoint_on_error": true
  },

  "backup_config": {
    "auto_backup_enabled": true,
    "backup_interval_hours": 6,
    "max_backups": 30,
    "backup_on_identity_change": true
  },

  "security_config": {
    "encryption_enabled": false,
    "require_checksum_verification": true,
    "audit_logging_enabled": true,
    "allowed_hosts": ["localhost", "127.0.0.1"]
  },

  "integration_config": {
    "ipc_protocol_version": "1.0",
    "message_queue": "/dev/shm/clawos/kernel-engine",
    "notification_channels": ["kernel-events"]
  }
}
```

### 3.2 System Configuration Schema

**Location:** `/clawfs/system/config.json`

```json
{
  "system_id": "clawos-instance-001",
  "version": "1.0.0",
  "created_at": "2024-02-24T00:00:00Z",
  "updated_at": "2024-02-24T12:34:56Z",

  "agents": {
    "enabled": [
      "kernel-engine",
      "ebpf-agent",
      "security-agent",
      "core-dev-agent",
      "wasm-agent",
      "fs-engine",
      "observability",
      "build-engine"
    ],
    "startup_order": [
      "kernel-engine",
      "security-agent",
      "ebpf-agent",
      "fs-engine",
      "core-dev-agent",
      "wasm-agent",
      "observability",
      "build-engine"
    ]
  },

  "workspaces": {
    "default_workspace_id": "default",
    "vector_dimension": 1536,
    "max_workspaces": 100,
    "workspace_defaults": {
      "hnsw_params": {
        "m": 16,
        "ef_construction": 200,
        "ef_search": 50
      }
    }
  },

  "security": {
    "tpm_enabled": true,
    "encryption_algorithm": "AES-256-GCM",
    "key_rotation_days": 90,
    "audit_log_enabled": true,
    "seccomp_enabled": true,
    "apparmor_enabled": true
  },

  "performance": {
    "max_total_memory_mb": 8192,
    "max_total_cpu_percent": 400,
    "sqlite_cache_size_mb": 64,
    "sqlite_wal_enabled": true
  },

  "network": {
    "allowed_hosts": ["localhost", "127.0.0.1"],
    "max_connections_per_agent": 10,
    "timeout_seconds": 300
  }
}
```

---

## 4. Initial Data Population Scripts

### 4.1 Initialization Script Overview

**Location:** `/clawfs/tools/scripts/initialize-identity.sh`

**Purpose:** Automated initialization of all agent workspaces with default Identity Files and configuration.

**Usage:**
```bash
sudo /clawfs/tools/scripts/initialize-identity.sh [--force] [--agent <agent-name>]
```

**Options:**
- `--force`: Overwrite existing identity files
- `--agent <name>`: Initialize only specific agent

### 4.2 Initialization Script (Bash)

```bash
#!/bin/bash
# initialize-identity.sh - Initialize agent workspaces with Identity Files
# Usage: sudo ./initialize-identity.sh [--force] [--agent <agent-name>]

set -euo pipefail

# Configuration
CLAWFS_ROOT="/clawfs"
AGENTS_ROOT="${CLAWFS_ROOT}/agents"
TOOLS_ROOT="${CLAWFS_ROOT}/tools"
SCRIPTS_ROOT="${TOOLS_ROOT}/scripts"
TEMPLATES_ROOT="${TOOLS_ROOT}/templates"

# Agent list
AGENTS=(
    "kernel-engine"
    "ebpf-agent"
    "security-agent"
    "core-dev-agent"
    "wasm-agent"
    "fs-engine"
    "observability"
    "build-engine"
)

# Parse arguments
FORCE=false
SPECIFIC_AGENT=""

while [[ $# -gt 0 ]]; do
    case $1 in
        --force)
            FORCE=true
            shift
            ;;
        --agent)
            SPECIFIC_AGENT="$2"
            shift 2
            ;;
        *)
            echo "Unknown option: $1"
            exit 1
            ;;
    esac
done

# Function to create directory structure
create_agent_structure() {
    local agent_name="$1"
    local agent_dir="${AGENTS_ROOT}/${agent_name}"

    echo "Creating directory structure for ${agent_name}..."

    # Create main directories
    mkdir -p "${agent_dir}/logs"
    mkdir -p "${agent_dir}/cache/embeddings"
    mkdir -p "${agent_dir}/cache/patterns"
    mkdir -p "${agent_dir}/checkpoints"
    mkdir -p "${agent_dir}/backups"

    # Create .gitkeep files
    touch "${agent_dir}/logs/.gitkeep"
    touch "${agent_dir}/cache/embeddings/.gitkeep"
    touch "${agent_dir}/cache/patterns/.gitkeep"
    touch "${agent_dir}/checkpoints/.gitkeep"
    touch "${agent_dir}/backups/.gitkeep"

    # Set permissions
    chmod 0750 "${agent_dir}"
    chmod 0750 "${agent_dir}/logs"
    chmod 0750 "${agent_dir}/cache"
    chmod 0750 "${agent_dir}/cache/embeddings"
    chmod 0750 "${agent_dir}/cache/patterns"
    chmod 0750 "${agent_dir}/checkpoints"
    chmod 0750 "${agent_dir}/backups"
}

# Function to initialize SQLite workspace database
initialize_workspace_db() {
    local agent_name="$1"
    local agent_dir="${AGENTS_ROOT}/${agent_name}"
    local workspace_db="${agent_dir}/workspace.db"

    echo "Initializing workspace database for ${agent_name}..."

    # Create SQLite database with FTS5 and HNSW
    sqlite3 "${workspace_db}" <<EOF
-- Documents table (FTS5 enabled)
CREATE VIRTUAL TABLE IF NOT EXISTS documents USING fts5(
    id INTEGER PRIMARY KEY,
    workspace_id TEXT NOT NULL,
    content TEXT,
    metadata TEXT,
    tokenize = 'porter unicode61'
);

-- Vector table (HNSW extension)
CREATE TABLE IF NOT EXISTS vectors (
    id INTEGER PRIMARY KEY,
    document_id INTEGER NOT NULL,
    embedding BLOB NOT NULL,
    created_at TEXT NOT NULL,
    FOREIGN KEY (document_id) REFERENCES documents(id)
);

-- HNSW index (created via extension)
CREATE VIRTUAL TABLE IF NOT EXISTS vectors_hnsw USING hnsw(
    vectors_embedding
) WITH (
    dimension = 1536,
    m = 16,
    ef_construction = 200
);

-- Metadata table
CREATE TABLE IF NOT EXISTS metadata (
    key TEXT PRIMARY KEY,
    value TEXT NOT NULL
);

-- Insert default metadata
INSERT OR REPLACE INTO metadata (key, value) VALUES
    ('workspace_id', '${agent_name}'),
    ('vector_dimension', '1536'),
    ('created_at', '$(date -u +"%Y-%m-%dT%H:%M:%SZ")'),
    ('version', '1.0.0');
EOF

    # Set permissions
    chmod 0640 "${workspace_db}"
}

# Function to generate Identity File
generate_identity_file() {
    local agent_name="$1"
    local agent_dir="${AGENTS_ROOT}/${agent_name}"
    local identity_file="${agent_dir}/identity.json"
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    echo "Generating Identity File for ${agent_name}..."

    # Generate Identity File JSON
    cat > "${identity_file}" <<EOF
{
  "agent_id": "${agent_name}",
  "version": 1,
  "created_at": "${timestamp}",
  "updated_at": "${timestamp}",

  "state": {
    "current_phase": "P1",
    "current_task": null,
    "last_checkpoint": "${timestamp}",
    "status": "idle",
    "subtasks": {
      "active": [],
      "completed": [],
      "blocked": []
    },
    "context": {
      "workspace_id": "default",
      "session_id": null,
      "parent_task_id": null
    }
  },

  "memory": {
    "learned_patterns": [],
    "heuristics": [],
    "knowledge_graph": {
      "nodes": [],
      "edges": []
    }
  },

  "history": {
    "completed_tasks": [],
    "failed_tasks": [],
    "total_executions": 0,
    "success_rate": 1.0,
    "task_breakdown": {
      "P1": { "completed": 0, "failed": 0, "avg_time_ms": 0 },
      "P2": { "completed": 0, "failed": 0, "avg_time_ms": 0 },
      "P3": { "completed": 0, "failed": 0, "avg_time_ms": 0 },
      "P4": { "completed": 0, "failed": 0, "avg_time_ms": 0 }
    },
    "recent_errors": []
  },

  "performance": {
    "avg_execution_time_ms": 0,
    "peak_memory_mb": 0,
    "last_benchmark": null,
    "benchmark_results": {
      "task_throughput_per_hour": 0,
      "memory_efficiency": 0,
      "cpu_efficiency": 0,
      "io_efficiency": 0
    },
    "optimization_history": []
  },

  "preferences": {
    "default_workspace": "default",
    "log_level": "info",
    "parallel_tasks": 3,
    "timeout_seconds": 300,
    "retry_policy": {
      "max_retries": 3,
      "backoff_multiplier": 2.0,
      "initial_delay_ms": 1000
    },
    "resource_limits": {
      "max_memory_mb": 1024,
      "max_cpu_percent": 80,
      "max_io_ops_per_sec": 1000
    }
  },

| sha256sum |
}
EOF

    # Calculate and update checksum
| jq -c 'del(.checksum)' | sha256sum |
    jq --arg checksum "sha256:${checksum}" '.checksum = $checksum' "${identity_file}" > "${identity_file}.tmp"
    mv "${identity_file}.tmp" "${identity_file}"

    # Set permissions
    chmod 0640 "${identity_file}"
}

# Function to generate config.json
generate_config_file() {
    local agent_name="$1"
    local agent_dir="${AGENTS_ROOT}/${agent_name}"
    local config_file="${agent_dir}/config.json"
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    echo "Generating config.json for ${agent_name}..."

    cat > "${config_file}" <<EOF
{
  "agent_id": "${agent_name}",
  "version": 1,
  "created_at": "${timestamp}",
  "updated_at": "${timestamp}",

  "capabilities": {
    "allowed_operations": [
      "read_workspace",
      "write_workspace",
      "execute_task",
      "create_checkpoint",
      "learn_pattern"
    ],
    "restricted_operations": [
      "modify_system_files",
      "access_other_agents"
    ],
    "resource_limits": {
      "max_memory_mb": 1024,
      "max_cpu_percent": 80,
      "max_disk_io_mb_per_sec": 100,
      "max_network_connections": 10
    }
  },

  "workspace_config": {
    "default_workspace_id": "default",
    "vector_dimension": 1536,
    "hnsw_params": {
      "m": 16,
      "ef_construction": 200,
      "ef_search": 50
    },
    "max_cache_size_mb": 256
  },

  "learning_config": {
    "pattern_learning_enabled": true,
    "heuristic_learning_enabled": true,
    "min_confidence_threshold": 0.7,
    "max_patterns": 1000,
    "max_heuristics": 500,
    "pattern_decay_days": 90,
    "heuristic_validation_interval_hours": 24
  },

  "logging_config": {
    "log_level": "info",
    "log_format": "json",
    "log_retention_days": 30,
    "log_rotation": "daily",
    "log_to_file": true,
    "log_to_console": false
  },

  "checkpoint_config": {
    "auto_checkpoint_enabled": true,
    "checkpoint_interval_minutes": 30,
    "max_checkpoints": 10,
    "checkpoint_on_task_completion": true,
    "checkpoint_on_error": true
  },

  "backup_config": {
    "auto_backup_enabled": true,
    "backup_interval_hours": 6,
    "max_backups": 30,
    "backup_on_identity_change": true
  },

  "security_config": {
    "encryption_enabled": false,
    "require_checksum_verification": true,
    "audit_logging_enabled": true,
    "allowed_hosts": ["localhost", "127.0.0.1"]
  },

  "integration_config": {
    "ipc_protocol_version": "1.0",
    "message_queue": "/dev/shm/clawos/${agent_name}",
    "notification_channels": ["kernel-events"]
  }
}
EOF

    chmod 0640 "${config_file}"
}

# Function to generate state.json
generate_state_file() {
    local agent_name="$1"
    local agent_dir="${AGENTS_ROOT}/${agent_name}"
    local state_file="${agent_dir}/state.json"
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    echo "Generating state.json for ${agent_name}..."

    cat > "${state_file}" <<EOF
{
  "agent_id": "${agent_name}",
  "version": 1,
  "created_at": "${timestamp}",
  "updated_at": "${timestamp}",

  "runtime_state": {
    "status": "idle",
    "current_task_id": null,
    "current_phase": "P1",
    "started_at": null,
    "last_activity": "${timestamp}"
  },

  "resource_usage": {
    "memory_mb": 0,
    "cpu_percent": 0,
    "disk_io_mb_per_sec": 0,
    "network_connections": 0
  },

  "active_sessions": []
}
EOF

    chmod 0640 "${state_file}"
}

# Main initialization function
initialize_agent() {
    local agent_name="$1"
    local agent_dir="${AGENTS_ROOT}/${agent_name}"

    echo "=========================================="
    echo "Initializing agent: ${agent_name}"
    echo "=========================================="

    # Check if agent directory exists
    if [[ -d "${agent_dir}" ]] && [[ "${FORCE}" != true ]]; then
        echo "Agent directory already exists: ${agent_dir}"
        echo "Use --force to overwrite"
        return 0
    fi

    # Create directory structure
    create_agent_structure "${agent_name}"

    # Initialize workspace database
    initialize_workspace_db "${agent_name}"

    # Generate Identity File
    generate_identity_file "${agent_name}"

    # Generate config.json
    generate_config_file "${agent_name}"

    # Generate state.json
    generate_state_file "${agent_name}"

    echo "Agent ${agent_name} initialized successfully!"
    echo ""
}

# Main execution
main() {
    echo "=========================================="
    echo "ClawOS Identity Files Initialization"
    echo "=========================================="
    echo ""

    # Check if running as root
    if [[ $EUID -ne 0 ]]; then
        echo "Error: This script must be run as root"
        exit 1
    fi

    # Determine which agents to initialize
    if [[ -n "${SPECIFIC_AGENT}" ]]; then
        # Initialize specific agent
        if [[ " ${AGENTS[@]} " =~ " ${SPECIFIC_AGENT} " ]]; then
            initialize_agent "${SPECIFIC_AGENT}"
        else
            echo "Error: Unknown agent: ${SPECIFIC_AGENT}"
            echo "Available agents: ${AGENTS[*]}"
            exit 1
        fi
    else
        # Initialize all agents
        for agent in "${AGENTS[@]}"; do
            initialize_agent "${agent}"
        done
    fi

    echo "=========================================="
    echo "Initialization complete!"
    echo "=========================================="
}

# Run main function
main "$@"
```

### 4.3 Rust Initialization Library

**Location:** `kernel/src/identity/initializer.rs`

```rust
use std::fs;
use std::path::{Path, PathBuf};
use serde_json::{json, Value};
use chrono::Utc;
use sha2::{Sha256, Digest};
use anyhow::{Result, Context};

/// Identity File Initializer
pub struct IdentityInitializer {
    clawfs_root: PathBuf,
    force: bool,
}

impl IdentityInitializer {
    /// Create new initializer
    pub fn new(clawfs_root: PathBuf, force: bool) -> Self {
        Self {
            clawfs_root,
            force,
        }
    }

    /// Initialize all agents
    pub fn initialize_all(&self) -> Result<()> {
        let agents = vec![
            "kernel-engine",
            "ebpf-agent",
            "security-agent",
            "core-dev-agent",
            "wasm-agent",
            "fs-engine",
            "observability",
            "build-engine",
        ];

        for agent in agents {
            self.initialize_agent(agent)?;
        }

        Ok(())
    }

    /// Initialize specific agent
    pub fn initialize_agent(&self, agent_name: &str) -> Result<()> {
        let agent_dir = self.clawfs_root.join("agents").join(agent_name);

        // Check if exists
        if agent_dir.exists() && !self.force {
            println!("Agent directory already exists: {:?}", agent_dir);
            return Ok(());
        }

        // Create directory structure
        self.create_directory_structure(&agent_dir)?;

        // Initialize workspace database
        self.initialize_workspace_db(&agent_dir, agent_name)?;

        // Generate Identity File
        self.generate_identity_file(&agent_dir, agent_name)?;

        // Generate config.json
        self.generate_config_file(&agent_dir, agent_name)?;

        // Generate state.json
        self.generate_state_file(&agent_dir, agent_name)?;

        println!("Agent {} initialized successfully!", agent_name);
        Ok(())
    }

    /// Create directory structure
    fn create_directory_structure(&self, agent_dir: &Path) -> Result<()> {
        let dirs = vec![
            "logs",
            "cache/embeddings",
            "cache/patterns",
            "checkpoints",
            "backups",
        ];

        for dir in &dirs {
            let dir_path = agent_dir.join(dir);
            fs::create_dir_all(&dir_path)
|  |

            // Create .gitkeep
            let gitkeep = dir_path.join(".gitkeep");
            fs::write(&gitkeep, "")
|  |

            // Set permissions (0750)
            #[cfg(unix)]
            {
                use std::os::unix::fs::PermissionsExt;
                let mut perms = fs::metadata(&dir_path)?.permissions();
                perms.set_mode(0o750);
                fs::set_permissions(&dir_path, perms)?;
            }
        }

        Ok(())
    }

    /// Initialize workspace database
    fn initialize_workspace_db(&self, agent_dir: &Path, agent_name: &str) -> Result<()> {
        let workspace_db = agent_dir.join("workspace.db");

        // Create SQLite database
        let conn = rusqlite::Connection::open(&workspace_db)?;

        // Create tables
        conn.execute(
            "CREATE VIRTUAL TABLE IF NOT EXISTS documents USING fts5(
                id INTEGER PRIMARY KEY,
                workspace_id TEXT NOT NULL,
                content TEXT,
                metadata TEXT,
                tokenize = 'porter unicode61'
            )",
            [],
        )?;

        conn.execute(
            "CREATE TABLE IF NOT EXISTS vectors (
                id INTEGER PRIMARY KEY,
                document_id INTEGER NOT NULL,
                embedding BLOB NOT NULL,
                created_at TEXT NOT NULL,
                FOREIGN KEY (document_id) REFERENCES documents(id)
            )",
            [],
        )?;

        conn.execute(
            "CREATE VIRTUAL TABLE IF NOT EXISTS vectors_hnsw USING hnsw(
                vectors_embedding
            ) WITH (
                dimension = 1536,
                m = 16,
                ef_construction = 200
            )",
            [],
        )?;

        conn.execute(
            "CREATE TABLE IF NOT EXISTS metadata (
                key TEXT PRIMARY KEY,
                value TEXT NOT NULL
            )",
            [],
        )?;

        // Insert default metadata
        let timestamp = Utc::now().to_rfc3339();
        conn.execute(
            "INSERT OR REPLACE INTO metadata (key, value) VALUES
                ('workspace_id', ?1),
                ('vector_dimension', '1536'),
                ('created_at', ?2),
                ('version', '1.0.0')",
            &[agent_name, &timestamp],
        )?;

        // Set permissions (0640)
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let mut perms = fs::metadata(&workspace_db)?.permissions();
            perms.set_mode(0o640);
            fs::set_permissions(&workspace_db, perms)?;
        }

        Ok(())
    }

    /// Generate Identity File
    fn generate_identity_file(&self, agent_dir: &Path, agent_name: &str) -> Result<()> {
        let identity_file = agent_dir.join("identity.json");
        let timestamp = Utc::now().to_rfc3339();

        let mut identity = json!({
            "agent_id": agent_name,
            "version": 1,
            "created_at": timestamp,
            "updated_at": timestamp,
            "state": {
                "current_phase": "P1",
                "current_task": null::<String>,
                "last_checkpoint": timestamp,
                "status": "idle",
                "subtasks": {
                    "active": [],
                    "completed": [],
                    "blocked": []
                },
                "context": {
                    "workspace_id": "default",
                    "session_id": null::<String>,
                    "parent_task_id": null::<String>
                }
            },
            "memory": {
                "learned_patterns": [],
                "heuristics": [],
                "knowledge_graph": {
                    "nodes": [],
                    "edges": []
                }
            },
            "history": {
                "completed_tasks": [],
                "failed_tasks": [],
                "total_executions": 0,
                "success_rate": 1.0,
                "task_breakdown": {
                    "P1": {"completed": 0, "failed": 0, "avg_time_ms": 0},
                    "P2": {"completed": 0, "failed": 0, "avg_time_ms": 0},
                    "P3": {"completed": 0, "failed": 0, "avg_time_ms": 0},
                    "P4": {"completed": 0, "failed": 0, "avg_time_ms": 0}
                },
                "recent_errors": []
            },
            "performance": {
                "avg_execution_time_ms": 0,
                "peak_memory_mb": 0,
                "last_benchmark": null::<String>,
                "benchmark_results": {
                    "task_throughput_per_hour": 0.0,
                    "memory_efficiency": 0.0,
                    "cpu_efficiency": 0.0,
                    "io_efficiency": 0.0
                },
                "optimization_history": []
            },
            "preferences": {
                "default_workspace": "default",
                "log_level": "info",
                "parallel_tasks": 3,
                "timeout_seconds": 300,
                "retry_policy": {
                    "max_retries": 3,
                    "backoff_multiplier": 2.0,
                    "initial_delay_ms": 1000
                },
                "resource_limits": {
                    "max_memory_mb": 1024,
                    "max_cpu_percent": 80,
                    "max_io_ops_per_sec": 1000
                }
            }
        });

        // Calculate checksum
        let checksum = self.calculate_checksum(&identity)?;
        identity["checksum"] = json!(format!("sha256:{}", checksum));

        // Write to file
        let identity_json = serde_json::to_string_pretty(&identity)?;
        fs::write(&identity_file, identity_json)?;

        // Set permissions (0640)
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let mut perms = fs::metadata(&identity_file)?.permissions();
            perms.set_mode(0o640);
            fs::set_permissions(&identity_file, perms)?;
        }

        Ok(())
    }

    /// Generate config.json
    fn generate_config_file(&self, agent_dir: &Path, agent_name: &str) -> Result<()> {
        let config_file = agent_dir.join("config.json");
        let timestamp = Utc::now().to_rfc3339();

        let config = json!({
            "agent_id": agent_name,
            "version": 1,
            "created_at": timestamp,
            "updated_at": timestamp,
            "capabilities": {
                "allowed_operations": [
                    "read_workspace",
                    "write_workspace",
                    "execute_task",
                    "create_checkpoint",
                    "learn_pattern"
                ],
                "restricted_operations": [
                    "modify_system_files",
                    "access_other_agents"
                ],
                "resource_limits": {
                    "max_memory_mb": 1024,
                    "max_cpu_percent": 80,
                    "max_disk_io_mb_per_sec": 100,
                    "max_network_connections": 10
                }
            },
            "workspace_config": {
                "default_workspace_id": "default",
                "vector_dimension": 1536,
                "hnsw_params": {
                    "m": 16,
                    "ef_construction": 200,
                    "ef_search": 50
                },
                "max_cache_size_mb": 256
            },
            "learning_config": {
                "pattern_learning_enabled": true,
                "heuristic_learning_enabled": true,
                "min_confidence_threshold": 0.7,
                "max_patterns": 1000,
                "max_heuristics": 500,
                "pattern_decay_days": 90,
                "heuristic_validation_interval_hours": 24
            },
            "logging_config": {
                "log_level": "info",
                "log_format": "json",
                "log_retention_days": 30,
                "log_rotation": "daily",
                "log_to_file": true,
                "log_to_console": false
            },
            "checkpoint_config": {
                "auto_checkpoint_enabled": true,
                "checkpoint_interval_minutes": 30,
                "max_checkpoints": 10,
                "checkpoint_on_task_completion": true,
                "checkpoint_on_error": true
            },
            "backup_config": {
                "auto_backup_enabled": true,
                "backup_interval_hours": 6,
                "max_backups": 30,
                "backup_on_identity_change": true
            },
            "security_config": {
                "encryption_enabled": false,
                "require_checksum_verification": true,
                "audit_logging_enabled": true,
                "allowed_hosts": ["localhost", "127.0.0.1"]
            },
            "integration_config": {
                "ipc_protocol_version": "1.0",
                "message_queue": format!("/dev/shm/clawos/{}", agent_name),
                "notification_channels": ["kernel-events"]
            }
        });

        let config_json = serde_json::to_string_pretty(&config)?;
        fs::write(&config_file, config_json)?;

        // Set permissions (0640)
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let mut perms = fs::metadata(&config_file)?.permissions();
            perms.set_mode(0o640);
            fs::set_permissions(&config_file, perms)?;
        }

        Ok(())
    }

    /// Generate state.json
    fn generate_state_file(&self, agent_dir: &Path, agent_name: &str) -> Result<()> {
        let state_file = agent_dir.join("state.json");
        let timestamp = Utc::now().to_rfc3339();

        let state = json!({
            "agent_id": agent_name,
            "version": 1,
            "created_at": timestamp,
            "updated_at": timestamp,
            "runtime_state": {
                "status": "idle",
                "current_task_id": null::<String>,
                "current_phase": "P1",
                "started_at": null::<String>,
                "last_activity": timestamp
            },
            "resource_usage": {
                "memory_mb": 0,
                "cpu_percent": 0,
                "disk_io_mb_per_sec": 0,
                "network_connections": 0
            },
            "active_sessions": []
        });

        let state_json = serde_json::to_string_pretty(&state)?;
        fs::write(&state_file, state_json)?;

        // Set permissions (0640)
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let mut perms = fs::metadata(&state_file)?.permissions();
            perms.set_mode(0o640);
            fs::set_permissions(&state_file, perms)?;
        }

        Ok(())
    }

    /// Calculate SHA-256 checksum of JSON value (excluding checksum field)
    fn calculate_checksum(&self, value: &Value) -> Result<String> {
        let json_str = serde_json::to_string(value)?;
        let mut hasher = Sha256::new();
        hasher.update(json_str.as_bytes());
        let result = hasher.finalize();
        Ok(format!("{:x}", result))
    }
}
```

---

## 5. Persistent Kernel Memory Storage Format

### 5.1 Kernel Memory Architecture

The **persistent kernel memory** is stored across multiple components:

1. **Identity Files** (`identity.json`): Agent state and learned knowledge
2. **Workspace Databases** (`workspace.db`): Vector-indexed documents and patterns
3. **Checkpoints** (`checkpoints/*.json`): State snapshots
4. **Backups** (`backups/*.json`): Historical identity file backups

### 5.2 Memory Storage Hierarchy

```
/clawfs/agents/{agent}/
â”œâ”€â”€ identity.json              # Primary memory (current state)
â”œâ”€â”€ workspace.db               # Vector-indexed knowledge base
â”œâ”€â”€ checkpoints/               # State snapshots
â”‚   â”œâ”€â”€ checkpoint-2024-02-24-100000.json
â”‚   â””â”€â”€ checkpoint-2024-02-24-110000.json
â””â”€â”€ backups/                   # Identity file backups
    â”œâ”€â”€ identity-2024-02-24-000000.json
    â”œâ”€â”€ identity-2024-02-24-060000.json
    â””â”€â”€ identity-2024-02-24-120000.json
```

### 5.3 Checkpoint Format

**Location:** `/clawfs/agents/{agent}/checkpoints/checkpoint-{timestamp}.json`

```json
{
  "checkpoint_id": "checkpoint-2024-02-24-100000",
  "agent_id": "kernel-engine",
  "timestamp": "2024-02-24T10:00:00Z",
  "version": 1,

  "state_snapshot": {
    "current_phase": "P2",
    "current_task": "A-01",
    "status": "in_progress",
    "subtasks": {
      "active": ["subtask-001", "subtask-002"],
      "completed": ["subtask-000"],
      "blocked": []
    }
  },

  "memory_snapshot": {
    "learned_patterns_count": 42,
    "heuristics_count": 15,
    "knowledge_graph_nodes": 128,
    "knowledge_graph_edges": 256
  },

  "workspace_snapshot": {
    "documents_count": 1523,
    "vectors_count": 1523,
    "last_document_id": 1523
  },

  "resource_snapshot": {
    "memory_mb": 512,
    "cpu_percent": 45,
    "disk_io_mb_per_sec": 12
  },

  "checksum": "sha256:abc123..."
}
```

### 5.4 Backup Format

**Location:** `/clawfs/agents/{agent}/backups/identity-{timestamp}.json`

Backups are **complete copies** of the Identity File at specific points in time.

```json
{
  "backup_id": "identity-2024-02-24-000000",
  "agent_id": "kernel-engine",
  "timestamp": "2024-02-24T00:00:00Z",
  "backup_type": "scheduled",

  "identity_file": {
    // Complete Identity File content
    "agent_id": "kernel-engine",
    "version": 1,
    "created_at": "2024-02-24T00:00:00Z",
    "updated_at": "2024-02-24T00:00:00Z",
    // ... rest of Identity File
  },

  "checksum": "sha256:abc123..."
}
```

### 5.5 Memory Persistence Workflow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Agent Execution                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Update Identity File (in-memory)                â”‚
â”‚  - Update state                                             â”‚
â”‚  - Add learned patterns                                     â”‚
â”‚  - Update history                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Calculate SHA-256 Checksum                     â”‚
â”‚  - Hash entire JSON (excluding checksum field)              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Create Backup (if changed)                     â”‚
â”‚  - Copy current identity.json to backups/                   â”‚
â”‚  - Timestamp: identity-{timestamp}.json                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Atomic Write                                   â”‚
â”‚  - Write to temp file: identity.json.tmp                   â”‚
â”‚  - Verify checksum                                          â”‚
â”‚  - Rename: identity.json.tmp â†’ identity.json               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Create Checkpoint (if task completed)          â”‚
â”‚  - Snapshot state to checkpoints/                           â”‚
â”‚  - Timestamp: checkpoint-{timestamp}.json                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 6. SHA-256 Checksum Verification Procedures

### 6.1 Checksum Calculation Algorithm

**Algorithm:** SHA-256 of entire JSON (excluding checksum field)

**Purpose:** Detect corruption or tampering of Identity Files

### 6.2 Checksum Calculation (Rust)

```rust
use sha2::{Sha256, Digest};
use serde_json::Value;

/// Calculate SHA-256 checksum of Identity File (excluding checksum field)
pub fn calculate_identity_checksum(identity: &Value) -> Result<String> {
    // Remove checksum field before hashing
    let mut identity_without_checksum = identity.clone();
    identity_without_checksum.as_object_mut()
|  |
        .remove("checksum");

    // Serialize to JSON string
    let json_str = serde_json::to_string(&identity_without_checksum)?;

    // Calculate SHA-256
    let mut hasher = Sha256::new();
    hasher.update(json_str.as_bytes());
    let result = hasher.finalize();

    // Return hex string
    Ok(format!("{:x}", result))
}

/// Verify Identity File checksum
pub fn verify_identity_checksum(identity: &Value) -> Result<bool> {
    // Extract stored checksum
    let stored_checksum = identity.get("checksum")
| c |
|   |

    // Remove "sha256:" prefix if present
    let stored_hash = stored_checksum.strip_prefix("sha256:")
        .unwrap_or(stored_checksum);

    // Calculate actual checksum
    let actual_hash = calculate_identity_checksum(identity)?;

    // Compare
    Ok(stored_hash == actual_hash)
}
```

### 6.3 Checksum Verification (Bash)

```bash
#!/bin/bash
# verify-identity-checksum.sh - Verify SHA-256 checksum of Identity File

set -euo pipefail

IDENTITY_FILE="$1"

if [[ -z "${IDENTITY_FILE}" ]]; then
    echo "Usage: $0 <identity-file>"
    exit 1
fi

if [[ ! -f "${IDENTITY_FILE}" ]]; then
    echo "Error: Identity file not found: ${IDENTITY_FILE}"
    exit 1
fi

# Extract stored checksum
STORED_CHECKSUM=$(jq -r '.checksum' "${IDENTITY_FILE}")

# Remove "sha256:" prefix
STORED_HASH="${STORED_CHECKSUM#sha256:}"

# Calculate actual checksum (excluding checksum field)
| sha256sum |

# Compare
if [[ "${STORED_HASH}" == "${ACTUAL_HASH}" ]]; then
    echo "âœ“ Checksum verified: ${IDENTITY_FILE}"
    echo "  SHA-256: ${ACTUAL_HASH}"
    exit 0
else
    echo "âœ— Checksum mismatch: ${IDENTITY_FILE}"
    echo "  Expected: ${STORED_HASH}"
    echo "  Actual:   ${ACTUAL_HASH}"
    exit 1
fi
```

### 6.4 Checksum Verification Workflow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Load Identity File                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Extract Stored Checksum                        â”‚
â”‚  - Read checksum field from identity.json                   â”‚
â”‚  - Remove "sha256:" prefix                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Calculate Actual Checksum                      â”‚
â”‚  - Remove checksum field from JSON                          â”‚
â”‚  - Serialize to string                                      â”‚
â”‚  - Calculate SHA-256                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Compare Checksums                              â”‚
â”‚  - Stored == Actual?                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚                           â”‚
                â–¼                           â–¼
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚  Match   â”‚              â”‚ Mismatch â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚                           â”‚
                â–¼                           â–¼
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚  Valid   â”‚              â”‚  Corrupt â”‚
         â”‚  Continueâ”‚              â”‚  Restore â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚  Backup  â”‚
                                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 6.5 Checksum Verification on Load

**Mandatory:** All Identity Files must be verified on load before use.

```rust
use std::fs;
use std::path::Path;

/// Load and verify Identity File
pub fn load_identity_file<P: AsRef<Path>>(path: P) -> Result<Value> {
    let path = path.as_ref();

    // Read file
    let content = fs::read_to_string(path)?;

    // Parse JSON
    let identity: Value = serde_json::from_str(&content)?;

    // Verify checksum
    if !verify_identity_checksum(&identity)? {
        anyhow::bail!("Checksum verification failed for: {:?}", path);
    }

    Ok(identity)
}
```

### 6.6 Checksum Update on Write

**Mandatory:** Checksum must be recalculated and updated on every write.

```rust
use std::fs;
use std::path::Path;

/// Save Identity File with updated checksum
pub fn save_identity_file<P: AsRef<Path>>(path: P, mut identity: Value) -> Result<()> {
    let path = path.as_ref();

    // Calculate new checksum
    let checksum = calculate_identity_checksum(&identity)?;
    identity["checksum"] = json!(format!("sha256:{}", checksum));

    // Serialize to JSON
    let content = serde_json::to_string_pretty(&identity)?;

    // Atomic write: write to temp file, then rename
    let temp_path = path.with_extension("tmp");
    fs::write(&temp_path, content)?;

    // Verify checksum of written file
    let written_identity: Value = serde_json::from_str(&content)?;
    if !verify_identity_checksum(&written_identity)? {
        fs::remove_file(&temp_path)?;
        anyhow::bail!("Checksum verification failed after write");
    }

    // Atomic rename
    fs::rename(&temp_path, path)?;

    Ok(())
}
```

### 6.7 Batch Verification Script

**Location:** `/clawfs/tools/scripts/verify-all-identities.sh`

```bash
#!/bin/bash
# verify-all-identities.sh - Verify all agent Identity Files

set -euo pipefail

CLAWFS_ROOT="/clawfs"
AGENTS_ROOT="${CLAWFS_ROOT}/agents"

AGENTS=(
    "kernel-engine"
    "ebpf-agent"
    "security-agent"
    "core-dev-agent"
    "wasm-agent"
    "fs-engine"
    "observability"
    "build-engine"
)

echo "=========================================="
echo "Verifying all Identity Files"
echo "=========================================="
echo ""

FAILED=0
SUCCESS=0

for agent in "${AGENTS[@]}"; do
    IDENTITY_FILE="${AGENTS_ROOT}/${agent}/identity.json"

    if [[ ! -f "${IDENTITY_FILE}" ]]; then
        echo "âœ— Missing: ${IDENTITY_FILE}"
        ((FAILED++))
        continue
    fi

    if /clawfs/tools/scripts/verify-identity-checksum.sh "${IDENTITY_FILE}"; then
        ((SUCCESS++))
    else
        ((FAILED++))
    fi
done

echo ""
echo "=========================================="
echo "Verification Summary"
echo "=========================================="
echo "Success: ${SUCCESS}"
echo "Failed:  ${FAILED}"
echo ""

if [[ ${FAILED} -gt 0 ]]; then
    exit 1
fi

exit 0
```

---

## 7. Validation Checklist

Before marking this specification as **COMPLETE**, verify:

- [ ] Identity Files schema is fully defined (Section 1)
- [ ] Workspace directory structure is specified (Section 2)
- [ ] Configuration file formats are documented (Section 3)
- [ ] Initialization scripts are provided (Section 4)
- [ ] Persistent kernel memory storage format is defined (Section 5)
- [ ] SHA-256 checksum verification procedures are complete (Section 6)
- [ ] All file permissions are specified
- [ ] Atomic write procedures are documented
- [ ] Backup and checkpoint strategies are defined
- [ ] Error handling and recovery procedures are specified

---

## 8. Dependencies and References

| Dependency       | Version      | Purpose                       |
| -----------------| -------------| ------------------------------|
| P1.4 ClawFS Spec | 1.0.0        | Base filesystem specification |
| SQLite           | 3.47+        | Workspace database            |
| HNSW extension   | usearch 2.0+ | Vector similarity             |
| serde_json       | 1.0+         | JSON serialization            |
| sha2             | 0.10+        | SHA-256 hashing               |
| chrono           | 0.4+         | Timestamp handling            |
| anyhow           | 1.0+         | Error handling                |

**References:**
- P1.4 ClawFS Spec Section 5: Identity Files Format
- SKILLS.md: Agent roster and capabilities
- P3.3 PostgreSQL Migration: Database migration strategy

---

## 9. Change History

| Version | Date       | Changes                     | Author            |
| --------| -----------| ----------------------------| ------------------|
| 1.0.0   | 2024-02-24 | Initial draft specification | FS Engineer Agent |

---

**END OF SPECIFICATION**

**Status:** ðŸ“ **DRAFT**
**Next Phase:** Implementation of Identity File initialization scripts
