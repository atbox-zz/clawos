# P3.8 ‚Äî Secrets Encryption Key Initialization Specification

**Status:** üìù **DRAFT**
**Version:** 0.1.0
**Date:** 2026-02-24
**Owner:** Security Agent
**Dependencies:** P1.4 ClawFS Spec (Section 3: Secrets Encryption Format)

---

## Overview

This specification defines the initialization and management of the secrets encryption key system for ClawOS using the Linux kernel keyring. The system provides hardware-bound security via TPM 2.0 when available, with secure fallback to software-based key derivation.

**Key Objectives:**
- Initialize kernel keyring for secrets encryption
- Implement TPM 2.0 key sealing for hardware-bound security
- Provide secure fallback key derivation (PBKDF2)
- Define AES-256-GCM key hierarchy
- Specify per-secret key generation
- Define key rotation procedures
- Document Vault storage locations
- Include recovery procedures

---

## 1. Kernel Keyring Architecture

### 1.1 Keyring Hierarchy

ClawOS uses a hierarchical keyring structure:

```
Keyring: .clawos (session keyring)
‚îú‚îÄ‚îÄ Key: clawos-master (type: user, 256-bit)
‚îÇ   ‚îî‚îÄ‚îÄ Purpose: Root master key for all secret encryption
‚îú‚îÄ‚îÄ Key: clawos-tpm-sealed (type: trusted, if TPM available)
‚îÇ   ‚îî‚îÄ‚îÄ Purpose: TPM-sealed master key blob
‚îú‚îÄ‚îÄ Key: clawos-derived-{secret-id} (type: logon, per-secret)
‚îÇ   ‚îî‚îÄ‚îÄ Purpose: Derived keys for individual secrets
‚îî‚îÄ‚îÄ Key: clawos-rotation-{timestamp} (type: user, during rotation)
    ‚îî‚îÄ‚îÄ Purpose: Temporary key during key rotation
```

### 1.2 Keyring Initialization Sequence

**Boot-time initialization (executed by init system):**

```bash
# Step 1: Create session keyring
keyctl session

# Step 2: Create .clawos keyring
keyctl newring .clawos @s

# Step 3: Link to user session keyring
keyctl link `keyctl search @s keyring .clawos` @u
```

**Verification:**
```bash
# Verify keyring exists
keyctl show

# Expected output:
# Session Keyring
#  -3: alnsrv-user-session
#      12345678: --alswrv   1000  1000 keyring: _uid.1000
#           87654321: --alswrv   1000  1000 keyring: .clawos
```

### 1.3 Keyring Permissions

| Key Type | Permissions | Description |
|----------|-------------|-------------|
| `user` | `0x3f3f0000` | All permissions for owner, read/search for group/other |
| `trusted` | `0x1f1f0000` | Write restricted to kernel, read/search for owner |
| `logon` | `0x1f1f0000` | Write restricted to kernel, read/search for owner |

**Permission bits:**
- `0x3f` = View, Read, Write, Search, Link, Set Attribute
- `0x1f` = View, Read, Search, Link, Set Attribute (no Write)

---

## 2. TPM 2.0 Key Sealing

### 2.1 TPM Detection and Initialization

**Detection sequence:**

```bash
# Check for TPM device
if [ -e /dev/tpm0 ] || [ -e /dev/tpmrm0 ]; then
    echo "TPM 2.0 detected"
    tpm_version=$(tpm2_getcap properties-fixed | grep TPM2_PT_FAMILY | awk '{print $3}')
    if [ "$tpm_version" = "2.0" ]; then
        echo "TPM 2.0 confirmed"
    fi
else
    echo "TPM not available, using software fallback"
fi
```

**TPM initialization:**

```bash
# Take ownership of TPM (if not already owned)
tpm2_takeownership -c

# Clear TPM (only during initial setup, DANGEROUS)
# tpm2_clear
```

### 2.2 Master Key Generation and Sealing

**Step 1: Generate random master key**

```bash
# Generate 256-bit (32-byte) random master key
openssl rand -out /tmp/master-key.bin 32

# Verify entropy
entropy_check=$(cat /tmp/master-key.bin | ent -t | grep "Entropy" | awk '{print $2}')
if [ $(echo "$entropy_check < 7.9" | bc) -eq 1 ]; then
    echo "ERROR: Insufficient entropy in master key"
    exit 1
fi
```

**Step 2: Create TPM primary key**

```bash
# Create primary key in endorsement hierarchy
tpm2_createprimary -C e -g sha256 -G rsa -c primary.ctx

# Output: primary.ctx (primary key context)
```

**Step 3: Seal master key in TPM**

```bash
# Create sealed key object
tpm2_create \
    -C primary.ctx \
    -g sha256 \
    -G aes256cfb \
    -u key.pub \
    -r key.priv \
    -i /tmp/master-key.bin \
    -A "fixedtpm|fixedparent|sensitivedataorigin|userwithauth|noda|locked"

# Load sealed key
tpm2_load -C primary.ctx -u key.pub -r key.priv -c key.ctx

# Unseal to verify
tpm2_unseal -c key.ctx -o /tmp/unsealed-key.bin

# Verify unsealed key matches original
if ! cmp -s /tmp/master-key.bin /tmp/unsealed-key.bin; then
    echo "ERROR: Key sealing verification failed"
    exit 1
fi
```

**Step 4: Store sealed key blob in Vault**

```bash
# Export sealed key blob
tpm2_evictcontrol -C o -c key.ctx 0x81000001

# Store sealed key in Vault
cp /tmp/master-key.bin /clawfs/vault/master-key.enc

# Secure cleanup
shred -u /tmp/master-key.bin /tmp/unsealed-key.bin
rm -f primary.ctx key.pub key.priv key.ctx
```

### 2.3 PCR-Based Sealing (Optional Enhanced Security)

**Purpose:** Bind key to specific boot state using Platform Configuration Registers (PCRs).

**PCR selection:**
- PCR 0: BIOS code
- PCR 1: BIOS configuration
- PCR 2: Option ROM code
- PCR 3: Option ROM configuration
- PCR 4: Master boot record
- PCR 7: Secure boot state

**Sealing with PCR policy:**

```bash
# Create PCR policy
tpm2_createpolicy \
    --policy-pcr \
    -l sha256:0,1,2,3,4,7 \
    -f policy.dat

# Create sealed key with PCR policy
tpm2_create \
    -C primary.ctx \
    -g sha256 \
    -G aes256cfb \
    -u key.pub \
    -r key.priv \
    -i /tmp/master-key.bin \
    -L policy.dat \
    -A "fixedtpm|fixedparent|sensitivedataorigin|userwithauth|noda|locked"

# Load and seal
tpm2_load -C primary.ctx -u key.pub -r key.priv -c key.ctx
tpm2_evictcontrol -C o -c key.ctx 0x81000001
```

**Unsealing with PCR verification:**

```bash
# Unseal only if PCR values match
tpm2_unseal \
    -c 0x81000001 \
    -p pcr:sha256:0,1,2,3,4,7 \
    -o /tmp/master-key.bin
```

### 2.4 TPM Fallback Detection

**Automatic fallback logic:**

```rust
// Rust implementation
use std::path::Path;

fn detect_tpm() -> bool {
    Path::new("/dev/tpm0").exists() || Path::new("/dev/tpmrm0").exists()
}

fn initialize_master_key() -> Result<Vec<u8>, Error> {
    if detect_tpm() {
        // Try TPM sealing
        match seal_key_in_tpm() {
            Ok(key) => {
                println!("TPM sealing successful");
                Ok(key)
            }
            Err(e) => {
                eprintln!("TPM sealing failed: {}, falling back to software", e);
                generate_software_master_key()
            }
        }
    } else {
        println!("TPM not available, using software fallback");
        generate_software_master_key()
    }
}
```

---

## 3. Software Fallback Key Derivation

### 3.1 PBKDF2-HMAC-SHA256 Master Key Generation

**When TPM is unavailable or fails:**

```rust
use pbkdf2::pbkdf2_hmac;
use sha2::Sha256;
use rand::Rng;

fn generate_software_master_key() -> Result<Vec<u8>, Error> {
    // Generate random salt (128 bits)
    let mut salt = [0u8; 16];
    rand::thread_rng().fill(&mut salt);

    // Use system-specific passphrase (derived from machine ID)
    let machine_id = std::fs::read_to_string("/etc/machine-id")?;
    let passphrase = format!("clawos:{}", machine_id.trim());

    // Derive master key using PBKDF2
    let mut master_key = [0u8; 32];
    pbkdf2_hmac::<Sha256>(
        passphrase.as_bytes(),
        &salt,
        600_000,  // OWASP 2024 recommendation
        &mut master_key
    );

    // Store salt in Vault for recovery
    std::fs::write("/clawfs/vault/master-key.salt", &salt)?;

    Ok(master_key.to_vec())
}
```

**Salt storage format:**

```json
{
  "salt": "base64-encoded-128-bit-salt",
  "algorithm": "PBKDF2-HMAC-SHA256",
  "iterations": 600000,
  "created_at": "2024-02-24T00:00:00Z"
}
```

### 3.2 Adding Master Key to Keyring

**Command-line:**

```bash
# Read master key
MASTER_KEY=$(cat /clawfs/vault/master-key.enc)

# Add to keyring (user type)
keyctl add user clawos-master "$MASTER_KEY" @u

# Verify key was added
keyctl show

# Expected output:
# Session Keyring
#  -3: alnsrv-user-session
#      12345678: --alswrv   1000  1000 keyring: _uid.1000
#           87654321: --alswrv   1000  1000 keyring: .clawos
#                98765432: --alswrv   1000  1000 \_user: clawos-master
```

**Rust implementation:**

```rust
use keyutils::{Key, KeyType};

fn add_master_key_to_keyring(master_key: &[u8]) -> Result<Key, Error> {
    let keyring = Key::request_key(KeyType::Keyring, ".clawos", None)?;

    let key = Key::add_key(
        KeyType::User,
        "clawos-master",
        master_key,
        keyring
    )?;

    // Set key permissions
    key.set_perm(0x3f3f0000)?;

    Ok(key)
}
```

---

## 4. AES-256-GCM Key Hierarchy

### 4.1 Key Derivation Tree

```
Master Key (256-bit)
‚îú‚îÄ‚îÄ Derived Key 1: openai-api-key (256-bit)
‚îÇ   ‚îî‚îÄ‚îÄ Salt: "openai-api-key:v1"
‚îú‚îÄ‚îÄ Derived Key 2: near-ai-token (256-bit)
‚îÇ   ‚îî‚îÄ‚îÄ Salt: "near-ai-token:v1"
‚îú‚îÄ‚îÄ Derived Key 3: github-pat (256-bit)
‚îÇ   ‚îî‚îÄ‚îÄ Salt: "github-pat:v1"
‚îî‚îÄ‚îÄ ...
```

### 4.2 Per-Secret Key Derivation

**Derivation function:**

```rust
use pbkdf2::pbkdf2_hmac;
use sha2::Sha256;

fn derive_secret_key(
    master_key: &[u8; 32],
    secret_id: &str,
    version: u32
) -> [u8; 32] {
    // Create salt from secret_id and version
    let salt = format!("{}:v{}", secret_id, version);

    // Derive per-secret key
    let mut derived_key = [0u8; 32];
    pbkdf2_hmac::<Sha256>(
        master_key,
        salt.as_bytes(),
        600_000,
        &mut derived_key
    );

    derived_key
}
```

**Adding derived key to keyring:**

```rust
fn add_derived_key_to_keyring(
    master_key: &[u8; 32],
    secret_id: &str,
    version: u32
) -> Result<Key, Error> {
    let derived_key = derive_secret_key(master_key, secret_id, version);
    let keyring = Key::request_key(KeyType::Keyring, ".clawos", None)?;

    let key_name = format!("clawos-derived-{}", secret_id);
    let key = Key::add_key(
        KeyType::Logon,
        &key_name,
        &derived_key,
        keyring
    )?;

    Ok(key)
}
```

### 4.3 Key Caching Strategy

**Cache derived keys in keyring for performance:**

```rust
// Cache TTL: 1 hour
const DERIVED_KEY_CACHE_TTL: Duration = Duration::from_secs(3600);

struct KeyCache {
    entries: HashMap<String, (Key, Instant)>,
}

impl KeyCache {
    fn get_or_derive(&mut self, secret_id: &str, version: u32) -> Result<Key, Error> {
        let key_name = format!("clawos-derived-{}", secret_id);

        // Check cache
        if let Some((key, timestamp)) = self.entries.get(&key_name) {
            if timestamp.elapsed() < DERIVED_KEY_CACHE_TTL {
                return Ok(key.clone());
            }
        }

        // Derive new key
        let master_key = get_master_key_from_keyring()?;
        let derived_key = derive_secret_key(&master_key, secret_id, version);
        let keyring = Key::request_key(KeyType::Keyring, ".clawos", None)?;

        let key = Key::add_key(
            KeyType::Logon,
            &key_name,
            &derived_key,
            keyring
        )?;

        // Update cache
        self.entries.insert(key_name, (key.clone(), Instant::now()));

        Ok(key)
    }
}
```

---

## 5. Secret Encryption and Decryption

### 5.1 Encryption Process

**Input:** Plaintext secret value

**Steps:**
1. Generate random 96-bit IV
2. Derive per-secret key from master key
3. Encrypt plaintext with AES-256-GCM
4. Extract 128-bit auth tag
5. Store encrypted secret in Vault

**Rust implementation:**

```rust
use aes_gcm::{
    aead::{Aead, KeyInit},
    Aes256Gcm, Nonce,
};
use rand::Rng;

fn encrypt_secret(
    plaintext: &[u8],
    secret_id: &str,
    version: u32
) -> Result<EncryptedSecret, Error> {
    // Get master key from keyring
    let master_key = get_master_key_from_keyring()?;

    // Derive per-secret key
    let derived_key = derive_secret_key(&master_key, secret_id, version);

    // Generate random IV (96 bits)
    let mut iv = [0u8; 12];
    rand::thread_rng().fill(&mut iv);

    // Encrypt
    let cipher = Aes256Gcm::new(derived_key.into());
    let nonce = Nonce::from_slice(&iv);
    let ciphertext = cipher.encrypt(nonce, plaintext)?;

    // Extract auth tag (last 16 bytes)
    let tag_len = 16;
    let ciphertext_len = ciphertext.len() - tag_len;
    let ciphertext_bytes = &ciphertext[..ciphertext_len];
    let auth_tag = &ciphertext[ciphertext_len..];

    Ok(EncryptedSecret {
        secret_id: secret_id.to_string(),
        encrypted_value: base64::encode(ciphertext_bytes),
        iv: base64::encode(&iv),
        auth_tag: base64::encode(auth_tag),
        algorithm: "AES-256-GCM".to_string(),
        key_id: format!("kernel-keyring:clawos-derived-{}", secret_id),
        kdf: KdfInfo {
            algorithm: "PBKDF2-HMAC-SHA256".to_string(),
            iterations: 600_000,
            salt: base64::encode(format!("{}:v{}", secret_id, version)),
        },
        created_at: Utc::now().to_rfc3339(),
        version,
    })
}

#[derive(Serialize)]
struct EncryptedSecret {
    secret_id: String,
    encrypted_value: String,
    iv: String,
    auth_tag: String,
    algorithm: String,
    key_id: String,
    kdf: KdfInfo,
    created_at: String,
    version: u32,
}

#[derive(Serialize)]
struct KdfInfo {
    algorithm: String,
    iterations: u32,
    salt: String,
}
```

### 5.2 Decryption Process

**Input:** Encrypted secret file

**Steps:**
1. Read IV, ciphertext, and auth tag
2. Derive per-secret key from master key
3. Decrypt with AES-256-GCM (auth tag verified automatically)
4. Return plaintext

**Rust implementation:**

```rust
fn decrypt_secret(encrypted: &EncryptedSecret) -> Result<Vec<u8>, Error> {
    // Get master key from keyring
    let master_key = get_master_key_from_keyring()?;

    // Derive per-secret key
    let derived_key = derive_secret_key(&master_key, &encrypted.secret_id, encrypted.version);

    // Decode base64
    let iv = base64::decode(&encrypted.iv)?;
    let ciphertext = base64::decode(&encrypted.encrypted_value)?;
    let auth_tag = base64::decode(&encrypted.auth_tag)?;

    // Combine ciphertext and auth tag
    let mut ciphertext_with_tag = ciphertext;
    ciphertext_with_tag.extend_from_slice(&auth_tag);

    // Decrypt
    let cipher = Aes256Gcm::new(derived_key.into());
    let nonce = Nonce::from_slice(&iv);
    let plaintext = cipher.decrypt(nonce, ciphertext_with_tag.as_ref())?;

    Ok(plaintext)
}
```

---

## 6. Key Rotation Procedures

### 6.1 Rotation Trigger Conditions

**Automatic rotation:**
- Every 90 days (configurable)
- On security incident detection
- After system compromise

**Manual rotation:**
- Admin-initiated via CLI
- After hardware change (TPM replacement)
- After OS reinstallation

### 6.2 Rotation Process

**Step 1: Generate new master key**

```bash
# Generate new random master key
openssl rand -out /tmp/new-master-key.bin 32

# If TPM available, seal new key
if [ -e /dev/tpm0 ]; then
    tpm2_createprimary -C e -g sha256 -G rsa -c primary.ctx
    tpm2_create -C primary.ctx -g sha256 -G aes256cfb \
        -u new-key.pub -r new-key.priv \
        -i /tmp/new-master-key.bin
    tpm2_load -C primary.ctx -u new-key.pub -r new-key.priv -c new-key.ctx
    tpm2_evictcontrol -C o -c new-key.ctx 0x81000002
fi
```

**Step 2: Add new master key to keyring**

```bash
# Add new master key with rotation suffix
NEW_MASTER_KEY=$(cat /tmp/new-master-key.bin)
TIMESTAMP=$(date +%s)
keyctl add user "clawos-rotation-$TIMESTAMP" "$NEW_MASTER_KEY" @u
```

**Step 3: Re-encrypt all secrets**

```rust
fn rotate_all_secrets(old_master_key: &[u8; 32], new_master_key: &[u8; 32]) -> Result<(), Error> {
    // List all secrets in Vault
    let secrets = list_secrets_in_vault()?;

    for secret in secrets {
        // Decrypt with old key
        let plaintext = decrypt_secret_with_key(&secret, old_master_key)?;

        // Encrypt with new key (increment version)
        let new_version = secret.version + 1;
        let encrypted = encrypt_secret_with_key(
            &plaintext,
            &secret.secret_id,
            new_master_key,
            new_version
        )?;

        // Write back to Vault
        write_secret_to_vault(&encrypted)?;
    }

    Ok(())
}
```

**Step 4: Update master key reference**

```bash
# Remove old master key
keyctl unlink $(keyctl search @u user clawos-master) @u

# Rename rotation key to master key
TIMESTAMP=$(date +%s)
ROTATION_KEY_ID=$(keyctl search @u user "clawos-rotation-$TIMESTAMP")
keyctl request_key user "clawos-master" @u 2>/dev/null || \
    keyctl add user clawos-master "$(keyctl print $ROTATION_KEY_ID)" @u

# Remove rotation key
keyctl unlink $ROTATION_KEY_ID @u
```

**Step 5: Archive old master key**

```bash
# Archive old master key for 30 days
ARCHIVE_DIR="/clawfs/vault/archive/$(date +%Y%m%d)"
mkdir -p "$ARCHIVE_DIR"
mv /clawfs/vault/master-key.enc "$ARCHIVE_DIR/master-key.enc.old"

# Schedule cleanup after 30 days
echo "find /clawfs/vault/archive -name '*.old' -mtime +30 -delete" | \
    at now + 30 days
```

### 6.3 Rotation Verification

**Verify all secrets can be decrypted:**

```rust
fn verify_rotation() -> Result<(), Error> {
    let secrets = list_secrets_in_vault()?;

    for secret in secrets {
        match decrypt_secret(&secret) {
            Ok(_) => continue,
            Err(e) => {
                eprintln!("ERROR: Failed to decrypt secret {}: {}", secret.secret_id, e);
                return Err(e);
            }
        }
    }

    println!("All secrets verified successfully");
    Ok(())
}
```

---

## 7. Vault Storage Locations

### 7.1 Vault Directory Structure

```
/clawfs/vault/
‚îú‚îÄ‚îÄ master-key.enc                    # Encrypted master key
‚îú‚îÄ‚îÄ master-key.salt                   # Salt for software fallback
‚îú‚îÄ‚îÄ master-key.tpm                    # TPM-sealed key blob (if TPM available)
‚îú‚îÄ‚îÄ secrets/                          # Encrypted secrets
‚îÇ   ‚îú‚îÄ‚îÄ openai-api-key.enc
‚îÇ   ‚îú‚îÄ‚îÄ near-ai-token.enc
‚îÇ   ‚îú‚îÄ‚îÄ github-pat.enc
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ archive/                          # Archived keys during rotation
‚îÇ   ‚îî‚îÄ‚îÄ 20240224/
‚îÇ       ‚îî‚îÄ‚îÄ master-key.enc.old
‚îú‚îÄ‚îÄ recovery/                         # Recovery keys
‚îÇ   ‚îî‚îÄ‚îÄ recovery-key.enc              # Emergency recovery key
‚îî‚îÄ‚îÄ metadata.json                     # Vault metadata
```

### 7.2 Secret File Format

**Location:** `/clawfs/vault/secrets/{secret-id}.enc`

**Format:**

```json
{
  "secret_id": "openai-api-key",
  "encrypted_value": "base64-encoded-aes-gcm-ciphertext",
  "iv": "base64-encoded-96-bit-iv",
  "auth_tag": "base64-encoded-128-bit-tag",
  "algorithm": "AES-256-GCM",
  "key_id": "kernel-keyring:clawos-derived-openai-api-key",
  "kdf": {
    "algorithm": "PBKDF2-HMAC-SHA256",
    "iterations": 600000,
    "salt": "base64-encoded-salt"
  },
  "created_at": "2024-02-24T00:00:00Z",
  "updated_at": "2024-02-24T12:34:56Z",
  "version": 1
}
```

### 7.3 Vault Metadata

**Location:** `/clawfs/vault/metadata.json`

**Format:**

```json
{
  "vault_id": "clawos-vault-001",
  "master_key_version": 1,
  "master_key_created_at": "2024-02-24T00:00:00Z",
  "master_key_rotated_at": null,
  "tpm_available": true,
  "tpm_sealed": true,
  "total_secrets": 3,
  "encryption_algorithm": "AES-256-GCM",
  "kdf_algorithm": "PBKDF2-HMAC-SHA256",
  "kdf_iterations": 600000,
  "last_rotation": null,
  "next_rotation": "2024-05-24T00:00:00Z"
}
```

---

## 8. Recovery Procedures

### 8.1 Recovery Key Generation

**Generate emergency recovery key during initial setup:**

```bash
# Generate recovery key (separate from master key)
openssl rand -out /tmp/recovery-key.bin 32

# Encrypt recovery key with master key
RECOVERY_KEY=$(cat /tmp/recovery-key.bin)
MASTER_KEY=$(keyctl print $(keyctl search @u user clawos-master))

# Encrypt recovery key
IV=$(openssl rand -hex 12)
ENCRYPTED=$(echo -n "$RECOVERY_KEY" | \
    openssl enc -aes-256-gcm -K "$MASTER_KEY" -iv "$IV" | \
    base64 -w 0)

# Store recovery key
cat > /clawfs/vault/recovery/recovery-key.enc <<EOF
{
  "encrypted_value": "$ENCRYPTED",
  "iv": "$IV",
  "algorithm": "AES-256-GCM",
  "created_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
}
EOF

# Secure cleanup
shred -u /tmp/recovery-key.bin
```

### 8.2 Master Key Recovery

**Scenario 1: TPM failure**

```bash
# If TPM fails, use software fallback
if ! tpm2_unseal -c 0x81000001 -o /tmp/master-key.bin 2>/dev/null; then
    echo "TPM unseal failed, using software fallback"

    # Read salt
    SALT=$(cat /clawfs/vault/master-key.salt | base64 -d)

    # Derive master key from machine ID
    MACHINE_ID=$(cat /etc/machine-id)
    PASSPHRASE="clawos:$MACHINE_ID"

    # Derive master key
    MASTER_KEY=$(echo -n "$PASSPHRASE" | \
        openssl pbkdf2 -sha256 -iter 600000 -salt "$SALT" -keylen 32 -binary | \
        base64 -w 0)

    # Add to keyring
    keyctl add user clawos-master "$MASTER_KEY" @u
fi
```

**Scenario 2: Keyring corruption**

```bash
# If keyring is corrupted, reinitialize
keyctl session
keyctl newring .clawos @s

# Recover master key from Vault
if [ -e /clawfs/vault/master-key.tpm ]; then
    # Unseal from TPM
    tpm2_unseal -c 0x81000001 -o /tmp/master-key.bin
else
    # Use software fallback
    # (same as Scenario 1)
fi

# Add to keyring
MASTER_KEY=$(cat /tmp/master-key.bin | base64 -w 0)
keyctl add user clawos-master "$MASTER_KEY" @u
```

**Scenario 3: Complete vault loss (catastrophic)**

```bash
# Use recovery key (requires manual intervention)
echo "WARNING: Complete vault loss detected"
echo "Please provide recovery key from backup"

# Read recovery key from backup media
read -p "Enter recovery key (base64): " RECOVERY_KEY

# Decrypt recovery key
# (requires manual decryption process)

# Rebuild vault from recovery key
# (requires manual intervention)
```

### 8.3 Recovery Key Backup

**Generate recovery key backup:**

```bash
# Generate recovery key backup
RECOVERY_KEY=$(cat /clawfs/vault/recovery/recovery-key.enc)

# Encrypt with user-provided passphrase
read -s -p "Enter backup passphrase: " PASSPHRASE
echo

# Derive encryption key from passphrase
SALT=$(openssl rand -hex 16)
BACKUP_KEY=$(echo -n "$PASSPHRASE" | \
    openssl pbkdf2 -sha256 -iter 600000 -salt "$SALT" -keylen 32 -binary | \
    base64 -w 0)

# Encrypt recovery key
IV=$(openssl rand -hex 12)
ENCRYPTED=$(echo -n "$RECOVERY_KEY" | \
    openssl enc -aes-256-gcm -K "$BACKUP_KEY" -iv "$IV" | \
    base64 -w 0)

# Write backup file
cat > /tmp/clawos-recovery-backup.json <<EOF
{
  "encrypted_recovery_key": "$ENCRYPTED",
  "iv": "$IV",
  "salt": "$SALT",
  "algorithm": "AES-256-GCM",
  "kdf": {
    "algorithm": "PBKDF2-HMAC-SHA256",
    "iterations": 600000
  },
  "created_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
}
EOF

# Output backup file
echo "Recovery backup written to: /tmp/clawos-recovery-backup.json"
echo "Store this file in a secure location"
```

---

## 9. Security Considerations

### 9.1 Keyring Security

**Protection measures:**
- Keys are stored in kernel memory (not accessible to userspace)
- Keyring permissions restrict access to owner only
- Keys are never written to disk in plaintext
- Keys are cleared from memory after use

**Verification:**

```bash
# Verify keys are not in swap
grep -i "clawos-master" /proc/swaps || echo "No keys in swap"

# Verify keys are not in core dumps
grep -r "clawos-master" /var/lib/systemd/coredump/ || echo "No keys in core dumps"
```

### 9.2 TPM Security

**Protection measures:**
- Keys are sealed in TPM hardware
- Keys are bound to PCR values (boot state)
- TPM provides anti-hammering protection
- Keys cannot be extracted from TPM

**Verification:**

```bash
# Verify TPM is owned
tpm2_getcap properties-variable | grep TPM2_PT_OWNER

# Verify sealed key exists
tpm2_getcap handles-persistent | grep 0x81000001
```

### 9.3 Software Fallback Security

**Protection measures:**
- High iteration count (600,000) for PBKDF2
- Salt is unique per installation
- Passphrase is derived from machine ID
- Salt is stored in Vault (not in code)

**Verification:**

```bash
# Verify salt exists and is random
SALT=$(cat /clawfs/vault/master-key.salt)
echo "$SALT" | base64 -d | ent -t | grep "Entropy"
# Should show entropy > 7.9
```

### 9.4 Vault Security

**Protection measures:**
- Vault directory has 0700 permissions (root-only)
- All secrets are encrypted at rest
- Vault is backed up to secure location
- Vault access is logged

**Verification:**

```bash
# Verify vault permissions
ls -ld /clawfs/vault
# Should show: drwx------

# Verify all secrets are encrypted
for file in /clawfs/vault/secrets/*.enc; do
    if ! grep -q '"encrypted_value"' "$file"; then
        echo "ERROR: Unencrypted secret found: $file"
    fi
done
```

---

## 10. Implementation Checklist

### 10.1 Initialization

- [ ] Create .clawos keyring at boot
- [ ] Detect TPM 2.0 availability
- [ ] Generate master key (TPM or software)
- [ ] Add master key to keyring
- [ ] Generate recovery key
- [ ] Initialize Vault directory structure
- [ ] Create Vault metadata

### 10.2 Key Management

- [ ] Implement per-secret key derivation
- [ ] Implement key caching in keyring
- [ ] Implement key rotation (90-day schedule)
- [ ] Implement key archival (30-day retention)
- [ ] Implement key verification

### 10.3 Secret Operations

- [ ] Implement secret encryption
- [ ] Implement secret decryption
- [ ] Implement secret storage in Vault
- [ ] Implement secret retrieval from Vault
- [ ] Implement secret deletion

### 10.4 Recovery

- [ ] Implement recovery key generation
- [ ] Implement recovery key backup
- [ ] Implement TPM failure recovery
- [ ] Implement keyring corruption recovery
- [ ] Implement catastrophic recovery

### 10.5 Security

- [ ] Implement keyring permission checks
- [ ] Implement TPM sealing verification
- [ ] Implement software fallback entropy checks
- [ ] Implement Vault permission checks
- [ ] Implement audit logging

---

## 11. Testing Procedures

### 11.1 Unit Tests

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_master_key_generation() {
        let key = generate_software_master_key().unwrap();
        assert_eq!(key.len(), 32);
    }

    #[test]
    fn test_key_derivation() {
        let master_key = [0u8; 32];
        let derived_key = derive_secret_key(&master_key, "test-secret", 1);
        assert_eq!(derived_key.len(), 32);
    }

    #[test]
    fn test_encryption_decryption() {
        let plaintext = b"test secret value";
        let encrypted = encrypt_secret(plaintext, "test-secret", 1).unwrap();
        let decrypted = decrypt_secret(&encrypted).unwrap();
        assert_eq!(plaintext, decrypted.as_slice());
    }

    #[test]
    fn test_key_rotation() {
        let old_key = [0u8; 32];
        let new_key = [1u8; 32];
        // Test rotation logic
    }
}
```

### 11.2 Integration Tests

```bash
# Test TPM sealing
if [ -e /dev/tpm0 ]; then
    ./test-tpm-sealing.sh
fi

# Test software fallback
./test-software-fallback.sh

# Test key rotation
./test-key-rotation.sh

# Test recovery
./test-recovery.sh
```

### 11.3 Security Tests

```bash
# Test keyring permissions
./test-keyring-permissions.sh

# Test vault permissions
./test-vault-permissions.sh

# Test entropy
./test-entropy.sh

# Test anti-hammering (TPM)
./test-anti-hammering.sh
```

---

## 12. Dependencies

| Component | Version | Purpose |
|-----------|---------|---------|
| Linux kernel | 5.15+ | Keyring support |
| TPM 2.0 tools | 5.0+ | TPM sealing |
| OpenSSL | 3.0+ | Cryptographic operations |
| Rust | 1.70+ | Implementation language |
| keyutils | 1.6+ | Keyring management |
| aes-gcm | 0.10+ | AES-256-GCM encryption |
| pbkdf2 | 0.12+ | Key derivation |
| sha2 | 0.10+ | SHA-256 hashing |
| serde_json | 1.0+ | JSON serialization |

---

## 13. References

- P1.4 ClawFS Spec (Section 3: Secrets Encryption Format)
- Linux Keyring Documentation: https://www.kernel.org/doc/html/latest/security/keys/core.html
- TPM 2.0 Specification: https://trustedcomputinggroup.org/
- AES-GCM RFC: https://tools.ietf.org/html/rfc5116
- PBKDF2 RFC: https://tools.ietf.org/html/rfc2898
- OWASP Password Storage Cheat Sheet: https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html

---

## 14. Change History

| Version | Date | Changes | Author |
|---------|------|---------|--------|
| 0.1.0 | 2026-02-24 | Initial draft | Security Agent |

---

**END OF SPECIFICATION**
